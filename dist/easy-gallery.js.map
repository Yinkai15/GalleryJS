{"version":3,"sources":["webpack:///easy-gallery.js","webpack:///webpack/bootstrap 3fb1c3b41d436bac17f7","webpack:///./src/Gallery.js","webpack:///./~/hammerjs/hammer.js","webpack:///./src/Gallery.less?45ca","webpack:///./src/Gallery.less","webpack:///./~/css-loader/lib/css-base.js","webpack:///./~/style-loader/addStyles.js","webpack:///./src/assets/fullscreen.png","webpack:///./src/assets/back-nav.png","webpack:///./src/assets/forward-nav.png","webpack:///./src/items/ItemBuilder.js","webpack:///./src/items/ItemFactory.js","webpack:///./src/items/ImageItem.js","webpack:///./src/items/GalleryItem.js","webpack:///./src/items/YouTubeItem.js"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","id","loaded","call","m","c","p","_interopRequireDefault","obj","__esModule","default","_classCallCheck","instance","Constructor","TypeError","Object","defineProperty","value","_createClass","defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","key","protoProps","staticProps","prototype","_hammerjs","_hammerjs2","_fullscreen","_fullscreen2","_backNav","_backNav2","_forwardNav","_forwardNav2","_ItemBuilder","_ItemBuilder2","_ItemFactory","_ItemFactory2","Gallery","itemStubs","_this","this","_navigationStatus","_gallery","_galleryContentContainer","_itemTitle","_index","_isFullscreen","_onKeyUp","bind","_items","window","addEventListener","e","_resetItems","_build","_onNavigation","classList","toggle","document","body","removeEventListener","_this2","gallery","createElement","className","galleryContentContainer","appendChild","mc","Manager","Swipe","Pan","add","on","console","log","next","previous","item","build","push","backNavIcon","src","mc1","Tap1","Tap","forwardNavIcon","mc2","Tap2","statusBar","navigationStatus","fullScreenIcon","itemTitle","mc3","Tap3","toggleFullscreen","reset","newItem","oldItem","onHidden","onShown","innerHTML","style","left","title","which","get","__WEBPACK_AMD_DEFINE_RESULT__","_typeof","Symbol","iterator","constructor","exportName","undefined","setTimeoutContext","fn","timeout","context","setTimeout","bindFn","invokeArrayArg","arg","Array","isArray","each","forEach","hasOwnProperty","deprecate","method","name","message","deprecationMessage","Error","stack","replace","warn","apply","arguments","inherit","child","base","properties","childP","baseP","create","_super","assign","boolOrFn","val","args","TYPE_FUNCTION","ifUndefined","val1","val2","addEventListeners","types","handler","splitStr","type","removeEventListeners","hasParent","node","parent","parentNode","inStr","str","find","indexOf","trim","split","inArray","findByKey","toArray","slice","uniqueArray","sort","results","values","a","b","prefixed","property","prefix","prop","camelProp","toUpperCase","VENDOR_PREFIXES","uniqueId","_uniqueId","getWindowForElement","element","doc","ownerDocument","defaultView","parentWindow","Input","manager","callback","self","options","inputTarget","domHandler","ev","enable","init","createInputInstance","Type","inputClass","SUPPORT_POINTER_EVENTS","PointerEventInput","SUPPORT_ONLY_TOUCH","TouchInput","SUPPORT_TOUCH","TouchMouseInput","MouseInput","inputHandler","eventType","input","pointersLen","pointers","changedPointersLen","changedPointers","isFirst","INPUT_START","isFinal","INPUT_END","INPUT_CANCEL","session","computeInputData","emit","recognize","prevInput","pointersLength","firstInput","simpleCloneInputData","firstMultiple","offsetCenter","center","getCenter","timeStamp","now","deltaTime","angle","getAngle","distance","getDistance","computeDeltaXY","offsetDirection","getDirection","deltaX","deltaY","overallVelocity","getVelocity","overallVelocityX","x","overallVelocityY","y","abs","scale","getScale","rotation","getRotation","maxPointers","computeIntervalInputData","srcEvent","offset","offsetDelta","prevDelta","velocity","velocityX","velocityY","direction","last","lastInterval","COMPUTE_INTERVAL","v","clientX","round","clientY","DIRECTION_NONE","DIRECTION_LEFT","DIRECTION_RIGHT","DIRECTION_UP","DIRECTION_DOWN","p1","p2","PROPS_XY","Math","sqrt","atan2","PI","start","end","PROPS_CLIENT_XY","evEl","MOUSE_ELEMENT_EVENTS","evWin","MOUSE_WINDOW_EVENTS","pressed","POINTER_ELEMENT_EVENTS","POINTER_WINDOW_EVENTS","store","pointerEvents","SingleTouchInput","evTarget","SINGLE_TOUCH_TARGET_EVENTS","SINGLE_TOUCH_WINDOW_EVENTS","started","normalizeSingleTouches","all","touches","changed","changedTouches","concat","TOUCH_TARGET_EVENTS","targetIds","getTouches","allTouches","INPUT_MOVE","identifier","targetTouches","changedTargetTouches","filter","touch","mouse","primaryTouch","lastTouches","recordTouches","eventData","setLastTouch","lastTouch","lts","removeLastTouch","splice","DEDUP_TIMEOUT","isSyntheticEvent","t","dx","dy","DEDUP_DISTANCE","TouchAction","set","cleanTouchActions","actions","TOUCH_ACTION_NONE","hasPanX","TOUCH_ACTION_PAN_X","hasPanY","TOUCH_ACTION_PAN_Y","TOUCH_ACTION_MANIPULATION","TOUCH_ACTION_AUTO","getTouchActionProps","NATIVE_TOUCH_ACTION","touchMap","cssSupports","CSS","supports","Recognizer","defaults","state","STATE_POSSIBLE","simultaneous","requireFail","stateStr","STATE_CANCELLED","STATE_ENDED","STATE_CHANGED","STATE_BEGAN","directionStr","getRecognizerByNameIfManager","otherRecognizer","recognizer","AttrRecognizer","PanRecognizer","pX","pY","PinchRecognizer","PressRecognizer","_timer","_input","RotateRecognizer","SwipeRecognizer","TapRecognizer","pTime","pCenter","count","Hammer","recognizers","preset","handlers","oldCssProps","touchAction","toggleCssProps","recognizeWith","requireFailure","cssProps","triggerDomEvent","event","data","gestureEvent","createEvent","initEvent","gesture","dispatchEvent","TEST_ELEMENT","Date","output","index","source","nextKey","extend","dest","merge","keys","MOBILE_REGEX","test","navigator","userAgent","INPUT_TYPE_TOUCH","INPUT_TYPE_PEN","INPUT_TYPE_MOUSE","INPUT_TYPE_KINECT","DIRECTION_HORIZONTAL","DIRECTION_VERTICAL","DIRECTION_ALL","destroy","MOUSE_INPUT_MAP","mousedown","mousemove","mouseup","button","pointerType","POINTER_INPUT_MAP","pointerdown","pointermove","pointerup","pointercancel","pointerout","IE10_POINTER_TYPE_ENUM","2","3","4","5","MSPointerEvent","PointerEvent","removePointer","eventTypeNormalized","toLowerCase","isTouch","storeIndex","pointerId","SINGLE_TOUCH_INPUT_MAP","touchstart","touchmove","touchend","touchcancel","TOUCH_INPUT_MAP","inputEvent","inputData","isMouse","sourceCapabilities","firesTouchEvents","PREFIXED_TOUCH_ACTION","TOUCH_ACTION_COMPUTE","TOUCH_ACTION_MAP","compute","update","getTouchAction","join","preventDefaults","prevented","preventDefault","hasNone","isTapPointer","isTapMovement","isTapTouchTime","preventSrc","STATE_RECOGNIZED","STATE_FAILED","dropRecognizeWith","dropRequireFailure","hasRequireFailures","canRecognizeWith","additionalEvent","tryEmit","canEmit","inputDataClone","process","attrTest","optionPointers","isRecognized","isValid","threshold","directionTest","hasMoved","inOut","time","validPointers","validMovement","validTime","clearTimeout","taps","interval","posThreshold","validTouchTime","failTimeout","validInterval","validMultiTap","tapCount","VERSION","domEvents","userSelect","touchSelect","touchCallout","contentZooming","userDrag","tapHighlightColor","STOP","FORCED_STOP","stop","force","stopped","curRecognizer","existing","remove","events","off","Pinch","Rotate","Press","freeGlobal","content","locals","list","toString","result","mediaQuery","alreadyImportedModules","addStylesToDom","styles","domStyle","stylesInDom","refs","j","parts","addStyle","listToStyles","newStyles","css","media","sourceMap","part","insertStyleElement","styleElement","head","getHeadElement","lastStyleElementInsertedAtTop","styleElementsInsertedAtTop","insertAt","nextSibling","insertBefore","firstChild","removeStyleElement","removeChild","idx","createStyleElement","createLinkElement","linkElement","rel","singleton","styleIndex","singletonCounter","singletonElement","applyToSingletonTag","URL","createObjectURL","revokeObjectURL","Blob","btoa","updateLink","href","applyToTag","newObj","styleSheet","cssText","replaceText","cssNode","createTextNode","childNodes","setAttribute","unescape","encodeURIComponent","JSON","stringify","blob","oldSrc","memoize","memo","isOldIE","getElementsByTagName","newList","mayRemove","textStore","replacement","Boolean","ItemBuilder","itemContainer","_attachEvents","pinch","pan","pinchStartW","pinchStartH","pinchStartX","pinchStartY","pinchStartPointerX","pinchStartPointerY","focusPoint","pinchOffset","imageStartX","imageStartY","panStartX","panStartY","offsetWidth","offsetHeight","offsetLeft","offsetTop","x1","x2","y1","y2","pinchFn","resize","move","_ImageItem","_ImageItem2","_YouTubeItem","_YouTubeItem2","ItemFactory","itemStub","url","video_id","player_vars","_possibleConstructorReturn","ReferenceError","_inherits","subClass","superClass","setPrototypeOf","__proto__","_GalleryItem2","_GalleryItem3","ImageItem","_GalleryItem","getPrototypeOf","_url","_element","onload","GalleryItem","_type","_title","w","h","startX","startY","displayAR","elementAR","destination","display","top","floor","width","height","removeProperty","imageAR","YouTubeItem","contentWindow","postMessage"],"mappings":"CAAS,SAAUA,GCInB,QAAAC,GAAAC,GAGA,GAAAC,EAAAD,GACA,MAAAC,GAAAD,GAAAE,OAGA,IAAAC,GAAAF,EAAAD,IACAE,WACAE,GAAAJ,EACAK,QAAA,EAUA,OANAP,GAAAE,GAAAM,KAAAH,EAAAD,QAAAC,IAAAD,QAAAH,GAGAI,EAAAE,QAAA,EAGAF,EAAAD,QAvBA,GAAAD,KAqCA,OATAF,GAAAQ,EAAAT,EAGAC,EAAAS,EAAAP,EAGAF,EAAAU,EAAA,GAGAV,EAAA,KDMM,SAASI,EAAQD,EAASH,GAE/B,YAkCA,SAASW,GAAuBC,GAAO,MAAOA,IAAOA,EAAIC,WAAaD,GAAQE,QAASF,GAEvF,QAASG,GAAgBC,EAAUC,GAAe,KAAMD,YAAoBC,IAAgB,KAAM,IAAIC,WAAU,qCAlChHC,OAAOC,eAAejB,EAAS,cAC3BkB,OAAO,GAGX,IAAIC,GAAe,WAAc,QAASC,GAAiBC,EAAQC,GAAS,IAAK,GAAIC,GAAI,EAAGA,EAAID,EAAME,OAAQD,IAAK,CAAE,GAAIE,GAAaH,EAAMC,EAAIE,GAAWC,WAAaD,EAAWC,aAAc,EAAOD,EAAWE,cAAe,EAAU,SAAWF,KAAYA,EAAWG,UAAW,GAAMZ,OAAOC,eAAeI,EAAQI,EAAWI,IAAKJ,IAAiB,MAAO,UAAUX,EAAagB,EAAYC,GAAiJ,MAA9HD,IAAYV,EAAiBN,EAAYkB,UAAWF,GAAiBC,GAAaX,EAAiBN,EAAaiB,GAAqBjB,MEpDjiBmB,EAAApC,EAAA,GFwDKqC,EAAa1B,EAAuByB,EEvDzCpC,GAAA,EAEA,IAAAsC,GAAAtC,EAAA,GF2DKuC,EAAe5B,EAAuB2B,GE1D3CE,EAAAxC,EAAA,GF8DKyC,EAAY9B,EAAuB6B,GE7DxCE,EAAA1C,EAAA,GFiEK2C,EAAehC,EAAuB+B,GEhE3CE,EAAA5C,EAAA,GFoEK6C,EAAgBlC,EAAuBiC,GEnE5CE,EAAA9C,EAAA,IFuEK+C,EAAgBpC,EAAuBmC,GErEvBE,EF2EN,WE1EX,QAAAA,GAAaC,GAAW,GAAAC,GAAAC,IAAApC,GAAAoC,KAAAH,GACpBG,KAAKC,kBAAoB,KACzBD,KAAKE,SAAW,KAChBF,KAAKG,yBAA2B,KAChCH,KAAKI,WAAa,KAElBJ,KAAKK,OAAS,EACdL,KAAKM,eAAgB,EACrBN,KAAKO,SAAWP,KAAKO,SAASC,KAAKR,MAEnCA,KAAKS,UAELC,OAAOC,iBAAiB,SAAU,SAACC,GAC/Bb,EAAKc,gBAGTb,KAAKc,OAAOhB,GFmQf,MAjLA3B,GAAa0B,IACThB,IAAK,OACLX,MAAO,WE5EJ8B,KAAKK,OAASL,KAAKS,OAAOjC,OAAS,IACnCwB,KAAKK,QAAU,EACfL,KAAKe,cAAcf,KAAKS,OAAOT,KAAKK,QAASL,KAAKS,OAAOT,KAAKK,OAAS,QFiF1ExB,IAAK,WACLX,MAAO,WE7EJ8B,KAAKK,OAAS,IACdL,KAAKK,QAAU,EACfL,KAAKe,cAAcf,KAAKS,OAAOT,KAAKK,QAASL,KAAKS,OAAOT,KAAKK,OAAS,QFkF1ExB,IAAK,mBACLX,MAAO,WE9ER8B,KAAKE,SAASc,UAAUC,OAAO,cAC/BjB,KAAKM,eAAiBN,KAAKM,cACvBN,KAAKM,cACLY,SAASC,KAAKR,iBAAiB,QAASX,KAAKO,UAE7CW,SAASC,KAAKC,oBAAoB,QAASpB,KAAKO,UAGpDP,KAAKa,iBFkFJhC,IAAK,SACLX,MAAO,SEhFJ4B,GAAW,GAAAuB,GAAArB,KACXsB,EAAUJ,SAASK,cAAc,MACrCvB,MAAKE,SAAWoB,EAChBA,EAAQE,UAAY,SAGpB,IAAIC,GAA0BP,SAASK,cAAc,MACrDvB,MAAKG,yBAA2BsB,EAChCA,EAAwBD,UAAY,kBACpCF,EAAQI,YAAYD,EAEpB,IAAIE,GAAK,GAAIzC,GAAAvB,QAAOiE,QAAQN,GACxBO,EAAQ,GAAI3C,GAAAvB,QAAOkE,MACnBC,EAAM,GAAI5C,GAAAvB,QAAOmE,GACrBH,GAAGI,IAAIF,GACPF,EAAGI,IAAID,GACPH,EAAGK,GAAG,WAAY,SAACpB,GACfqB,QAAQC,IAAItB,EAAG,WAEnBe,EAAGK,GAAG,UAAW,SAACpB,GAEdqB,QAAQC,IAAItB,EAAG,QACfS,EAAKc,SAETR,EAAGK,GAAG,WAAY,SAACpB,GACfqB,QAAQC,IAAItB,EAAG,SACfS,EAAKe,YAKT,KAAK,GAAI7D,KAAKuB,GAAW,CACrB,GAAIuC,GAAOzC,EAAAjC,QAAY2E,MAAMxC,EAAUvB,GACvCyB,MAAKS,OAAO8B,KAAKF,GACjBZ,EAAwBC,YAAYhC,EAAA/B,QAAY2E,MAAMD,IAI1D,GAAIG,GAActB,SAASK,cAAc,MACzCiB,GAAYhB,UAAY,gBACxBgB,EAAYC,IAAZnD,EAAA3B,QACA2D,EAAQI,YAAYc,EAEpB,IAAIE,GAAM,GAAIxD,GAAAvB,QAAOiE,QAAQY,GACzBG,EAAO,GAAIzD,GAAAvB,QAAOiF,GACtBF,GAAIX,IAAIY,GACRD,EAAIV,GAAG,MAAO,SAACpB,GACXS,EAAKe,YAGT,IAAIS,GAAiB3B,SAASK,cAAc,MAC5CsB,GAAerB,UAAY,mBAC3BqB,EAAeJ,IAAfjD,EAAA7B,QACA2D,EAAQI,YAAYmB,EAEpB,IAAIC,GAAM,GAAI5D,GAAAvB,QAAOiE,QAAQiB,GACzBE,EAAO,GAAI7D,GAAAvB,QAAOiF,GACtBE,GAAIf,IAAIgB,GACRD,EAAId,GAAG,MAAO,SAACpB,GACXS,EAAKc,QAIT,IAAIa,GAAY9B,SAASK,cAAc,MACvCyB,GAAUxB,UAAY,aACtBF,EAAQI,YAAYsB,EAGpB,IAAIC,GAAmB/B,SAASK,cAAc,MAC9C0B,GAAiBzB,UAAY,oBAC7BxB,KAAKC,kBAAoBgD,EACzBD,EAAUtB,YAAYuB,EAGtB,IAAIC,GAAiBhC,SAASK,cAAc,MAC5C2B,GAAe1B,UAAY,kBAC3B0B,EAAeT,IAAfrD,EAAAzB,QACAqF,EAAUtB,YAAYwB,EAGtB,IAAIC,GAAYjC,SAASK,cAAc,OACvCvB,MAAKI,WAAa+C,EAClBH,EAAUtB,YAAYyB,EAEtB,IAAIC,GAAM,GAAIlE,GAAAvB,QAAOiE,QAAQsB,GACzBG,EAAO,GAAInE,GAAAvB,QAAOiF,GAStB,OARAQ,GAAIrB,IAAIsB,GACRD,EAAIpB,GAAG,MAAO,SAACpB,GAEXS,EAAKiC,qBAGTtD,KAAKe,cAAcf,KAAKS,OAAOT,KAAKK,SAE7BiB,KFsFNzC,IAAK,cACLX,MAAO,WElFR,IAAK,GAAIK,KAAKyB,MAAKS,OACfT,KAAKS,OAAOlC,GAAGgF,WFuFlB1E,IAAK,gBACLX,MAAO,SEpFGsF,EAASC,GAChBA,GACAA,EAAQC,WAEZF,EAAQG,UAGR3D,KAAKC,kBAAkB2D,UAAa5D,KAAKK,OAAS,EAAK,IAAML,KAAKS,OAAOjC,OAEzEwB,KAAKG,yBAAyB0D,MAAMC,KAAyB,IAAf9D,KAAKK,QAAiB,EAAM,IAE1EL,KAAKI,WAAWwD,UAAY5D,KAAKS,OAAOT,KAAKK,QAAQ0D,OAAS,MFuF7DlF,IAAK,WACLX,MAAO,SErFF0C,GACN,OAAQA,EAAEoD,OACN,IAAK,IAEDhE,KAAKoC,UACL,MACJ,KAAK,IAEDpC,KAAKmC,MACL,MACJ,KAAK,IAEDnC,KAAKsD,uBF0FZzE,IAAK,UACLoF,IAAK,WE1PN,MAAOjE,MAAKE,aF+PRL,IAGX7C,GAAQW,QEvRYkC,EA0LrBa,OAAOb,QAAUA,EACjB5C,EAAOD,QAAU6C,GFoGX,SAAS5C,EAAQD,EAASH,GAE/B,GAAIqH,GAEAC,EAA4B,kBAAXC,SAAoD,gBAApBA,QAAOC,SAAwB,SAAU5G,GAAO,aAAcA,IAAS,SAAUA,GAAO,MAAOA,IAAyB,kBAAX2G,SAAyB3G,EAAI6G,cAAgBF,QAAU3G,IAAQ2G,OAAOpF,UAAY,eAAkBvB;;;;;CGvSvQ,SAAUiD,EAAQQ,EAAUqD,EAAYC,GACtC,YAkBF,SAASC,GAAkBC,EAAIC,EAASC,GACpC,MAAOC,YAAWC,EAAOJ,EAAIE,GAAUD,GAY3C,QAASI,GAAeC,EAAKN,EAAIE,GAC7B,QAAIK,MAAMC,QAAQF,KACdG,EAAKH,EAAKJ,EAAQF,GAAKE,IAChB,GAWf,QAASO,GAAK1H,EAAK4G,EAAUO,GACzB,GAAIrG,EAEJ,IAAKd,EAIL,GAAIA,EAAI2H,QACJ3H,EAAI2H,QAAQf,EAAUO,OACnB,IAAInH,EAAIe,SAAWgG,EAEtB,IADAjG,EAAI,EACGA,EAAId,EAAIe,QACX6F,EAASjH,KAAKwH,EAASnH,EAAIc,GAAIA,EAAGd,GAClCc,QAGJ,KAAKA,IAAKd,GACNA,EAAI4H,eAAe9G,IAAM8F,EAASjH,KAAKwH,EAASnH,EAAIc,GAAIA,EAAGd,GAYvE,QAAS6H,GAAUC,EAAQC,EAAMC,GAC7B,GAAIC,GAAqB,sBAAwBF,EAAO,KAAOC,EAAU,QACzE,OAAO,YACH,GAAI7E,GAAI,GAAI+E,OAAM,mBACdC,EAAQhF,GAAKA,EAAEgF,MAAQhF,EAAEgF,MAAMC,QAAQ,kBAAmB,IACzDA,QAAQ,cAAe,IACvBA,QAAQ,6BAA8B,kBAAoB,sBAE3D3D,EAAMxB,EAAOuB,UAAYvB,EAAOuB,QAAQ6D,MAAQpF,EAAOuB,QAAQC,IAInE,OAHIA,IACAA,EAAI9E,KAAKsD,EAAOuB,QAASyD,EAAoBE,GAE1CL,EAAOQ,MAAM/F,KAAMgG,YAwElC,QAASC,GAAQC,EAAOC,EAAMC,GAC1B,GACIC,GADAC,EAAQH,EAAKnH,SAGjBqH,GAASH,EAAMlH,UAAYhB,OAAOuI,OAAOD,GACzCD,EAAO/B,YAAc4B,EACrBG,EAAOG,OAASF,EAEZF,GACAK,GAAOJ,EAAQD,GAUvB,QAAStB,GAAOJ,EAAIE,GAChB,MAAO,YACH,MAAOF,GAAGqB,MAAMnB,EAASoB,YAWjC,QAASU,GAASC,EAAKC,GACnB,OAAI,mBAAOD,GAAP,YAAAxC,EAAOwC,KAAOE,GACPF,EAAIZ,MAAMa,EAAOA,EAAK,IAAMpC,EAAYA,EAAWoC,GAEvDD,EASX,QAASG,GAAYC,EAAMC,GACvB,MAAQD,KAASvC,EAAawC,EAAOD,EASzC,QAASE,GAAkB5I,EAAQ6I,EAAOC,GACtChC,EAAKiC,EAASF,GAAQ,SAASG,GAC3BhJ,EAAOsC,iBAAiB0G,EAAMF,GAAS,KAU/C,QAASG,GAAqBjJ,EAAQ6I,EAAOC,GACzChC,EAAKiC,EAASF,GAAQ,SAASG,GAC3BhJ,EAAO+C,oBAAoBiG,EAAMF,GAAS,KAWlD,QAASI,GAAUC,EAAMC,GACrB,KAAOD,GAAM,CACT,GAAIA,GAAQC,EACR,OAAO,CAEXD,GAAOA,EAAKE,WAEhB,OAAO,EASX,QAASC,GAAMC,EAAKC,GAChB,MAAOD,GAAIE,QAAQD,IAAQ,EAQ/B,QAAST,GAASQ,GACd,MAAOA,GAAIG,OAAOC,MAAM,QAU5B,QAASC,GAAQxF,EAAKoF,EAAMK,GACxB,GAAIzF,EAAIqF,UAAYI,EAChB,MAAOzF,GAAIqF,QAAQD,EAGnB,KADA,GAAItJ,GAAI,EACDA,EAAIkE,EAAIjE,QAAQ,CACnB,GAAK0J,GAAazF,EAAIlE,GAAG2J,IAAcL,IAAWK,GAAazF,EAAIlE,KAAOsJ,EACtE,MAAOtJ,EAEXA,KAEJ,OAAO,EASf,QAAS4J,GAAQ1K,GACb,MAAOwH,OAAMjG,UAAUoJ,MAAMhL,KAAKK,EAAK,GAU3C,QAAS4K,GAAY5F,EAAK5D,EAAKyJ,GAK3B,IAJA,GAAIC,MACAC,KACAjK,EAAI,EAEDA,EAAIkE,EAAIjE,QAAQ,CACnB,GAAImI,GAAM9H,EAAM4D,EAAIlE,GAAGM,GAAO4D,EAAIlE,EAC9B0J,GAAQO,EAAQ7B,GAAO,GACvB4B,EAAQhG,KAAKE,EAAIlE,IAErBiK,EAAOjK,GAAKoI,EACZpI,IAaJ,MAVI+J,KAIIC,EAHC1J,EAGS0J,EAAQD,KAAK,SAAyBG,EAAGC,GAC/C,MAAOD,GAAE5J,GAAO6J,EAAE7J,KAHZ0J,EAAQD,QAQnBC,EASX,QAASI,GAASlL,EAAKmL,GAKnB,IAJA,GAAIC,GAAQC,EACRC,EAAYH,EAAS,GAAGI,cAAgBJ,EAASR,MAAM,GAEvD7J,EAAI,EACDA,EAAI0K,GAAgBzK,QAAQ,CAI/B,GAHAqK,EAASI,GAAgB1K,GACzBuK,EAAQD,EAAUA,EAASE,EAAYH,EAEnCE,IAAQrL,GACR,MAAOqL,EAEXvK,KAEJ,MAAOiG,GAQX,QAAS0E,KACL,MAAOC,MAQX,QAASC,GAAoBC,GACzB,GAAIC,GAAMD,EAAQE,eAAiBF,CACnC,OAAQC,GAAIE,aAAeF,EAAIG,cAAgB/I,EAyCnD,QAASgJ,GAAMC,EAASC,GACpB,GAAIC,GAAO7J,IACXA,MAAK2J,QAAUA,EACf3J,KAAK4J,SAAWA,EAChB5J,KAAKqJ,QAAUM,EAAQN,QACvBrJ,KAAK3B,OAASsL,EAAQG,QAAQC,YAI9B/J,KAAKgK,WAAa,SAASC,GACnBvD,EAASiD,EAAQG,QAAQI,QAASP,KAClCE,EAAK1C,QAAQ8C,IAIrBjK,KAAKmK,OAoCT,QAASC,GAAoBT,GACzB,GAAIU,GACAC,EAAaX,EAAQG,QAAQQ,UAajC,OAAO,KAVHD,EADAC,EACOA,EACAC,GACAC,EACAC,GACAC,EACCC,GAGDC,EAFAC,GAIOlB,EAASmB,GAS/B,QAASA,GAAanB,EAASoB,EAAWC,GACtC,GAAIC,GAAcD,EAAME,SAAS1M,OAC7B2M,EAAqBH,EAAMI,gBAAgB5M,OAC3C6M,EAAWN,EAAYO,IAAgBL,EAAcE,IAAuB,EAC5EI,EAAWR,GAAaS,GAAYC,KAAkBR,EAAcE,IAAuB,CAE/FH,GAAMK,UAAYA,EAClBL,EAAMO,UAAYA,EAEdF,IACA1B,EAAQ+B,YAKZV,EAAMD,UAAYA,EAGlBY,EAAiBhC,EAASqB,GAG1BrB,EAAQiC,KAAK,eAAgBZ,GAE7BrB,EAAQkC,UAAUb,GAClBrB,EAAQ+B,QAAQI,UAAYd,EAQhC,QAASW,GAAiBhC,EAASqB,GAC/B,GAAIU,GAAU/B,EAAQ+B,QAClBR,EAAWF,EAAME,SACjBa,EAAiBb,EAAS1M,MAGzBkN,GAAQM,aACTN,EAAQM,WAAaC,EAAqBjB,IAI1Ce,EAAiB,IAAML,EAAQQ,cAC/BR,EAAQQ,cAAgBD,EAAqBjB,GACnB,IAAnBe,IACPL,EAAQQ,eAAgB,EAG5B,IAAIF,GAAaN,EAAQM,WACrBE,EAAgBR,EAAQQ,cACxBC,EAAeD,EAAgBA,EAAcE,OAASJ,EAAWI,OAEjEA,EAASpB,EAAMoB,OAASC,EAAUnB,EACtCF,GAAMsB,UAAYC,KAClBvB,EAAMwB,UAAYxB,EAAMsB,UAAYN,EAAWM,UAE/CtB,EAAMyB,MAAQC,EAASP,EAAcC,GACrCpB,EAAM2B,SAAWC,EAAYT,EAAcC,GAE3CS,EAAenB,EAASV,GACxBA,EAAM8B,gBAAkBC,EAAa/B,EAAMgC,OAAQhC,EAAMiC,OAEzD,IAAIC,GAAkBC,EAAYnC,EAAMwB,UAAWxB,EAAMgC,OAAQhC,EAAMiC,OACvEjC,GAAMoC,iBAAmBF,EAAgBG,EACzCrC,EAAMsC,iBAAmBJ,EAAgBK,EACzCvC,EAAMkC,gBAAmBM,GAAIN,EAAgBG,GAAKG,GAAIN,EAAgBK,GAAML,EAAgBG,EAAIH,EAAgBK,EAEhHvC,EAAMyC,MAAQvB,EAAgBwB,EAASxB,EAAchB,SAAUA,GAAY,EAC3EF,EAAM2C,SAAWzB,EAAgB0B,EAAY1B,EAAchB,SAAUA,GAAY,EAEjFF,EAAM6C,YAAenC,EAAQI,UAAsCd,EAAME,SAAS1M,OAC9EkN,EAAQI,UAAU+B,YAAe7C,EAAME,SAAS1M,OAASkN,EAAQI,UAAU+B,YADtC7C,EAAME,SAAS1M,OAGxDsP,EAAyBpC,EAASV,EAGlC,IAAI3M,GAASsL,EAAQN,OACjB9B,GAAUyD,EAAM+C,SAAS1P,OAAQA,KACjCA,EAAS2M,EAAM+C,SAAS1P,QAE5B2M,EAAM3M,OAASA,EAGnB,QAASwO,GAAenB,EAASV,GAC7B,GAAIoB,GAASpB,EAAMoB,OACf4B,EAAStC,EAAQuC,gBACjBC,EAAYxC,EAAQwC,cACpBpC,EAAYJ,EAAQI,aAEpBd,GAAMD,YAAcO,IAAeQ,EAAUf,YAAcS,KAC3D0C,EAAYxC,EAAQwC,WAChBb,EAAGvB,EAAUkB,QAAU,EACvBO,EAAGzB,EAAUmB,QAAU,GAG3Be,EAAStC,EAAQuC,aACbZ,EAAGjB,EAAOiB,EACVE,EAAGnB,EAAOmB,IAIlBvC,EAAMgC,OAASkB,EAAUb,GAAKjB,EAAOiB,EAAIW,EAAOX,GAChDrC,EAAMiC,OAASiB,EAAUX,GAAKnB,EAAOmB,EAAIS,EAAOT,GAQpD,QAASO,GAAyBpC,EAASV,GACvC,GAEImD,GAAUC,EAAWC,EAAWC,EAFhCC,EAAO7C,EAAQ8C,cAAgBxD,EAC/BwB,EAAYxB,EAAMsB,UAAYiC,EAAKjC,SAGvC,IAAItB,EAAMD,WAAaU,KAAiBe,EAAYiC,IAAoBF,EAAKJ,WAAa3J,GAAY,CAClG,GAAIwI,GAAShC,EAAMgC,OAASuB,EAAKvB,OAC7BC,EAASjC,EAAMiC,OAASsB,EAAKtB,OAE7ByB,EAAIvB,EAAYX,EAAWQ,EAAQC,EACvCmB,GAAYM,EAAErB,EACdgB,EAAYK,EAAEnB,EACdY,EAAYX,GAAIkB,EAAErB,GAAKG,GAAIkB,EAAEnB,GAAMmB,EAAErB,EAAIqB,EAAEnB,EAC3Ce,EAAYvB,EAAaC,EAAQC,GAEjCvB,EAAQ8C,aAAexD,MAGvBmD,GAAWI,EAAKJ,SAChBC,EAAYG,EAAKH,UACjBC,EAAYE,EAAKF,UACjBC,EAAYC,EAAKD,SAGrBtD,GAAMmD,SAAWA,EACjBnD,EAAMoD,UAAYA,EAClBpD,EAAMqD,UAAYA,EAClBrD,EAAMsD,UAAYA,EAQtB,QAASrC,GAAqBjB,GAK1B,IAFA,GAAIE,MACA3M,EAAI,EACDA,EAAIyM,EAAME,SAAS1M,QACtB0M,EAAS3M,IACLoQ,QAASC,GAAM5D,EAAME,SAAS3M,GAAGoQ,SACjCE,QAASD,GAAM5D,EAAME,SAAS3M,GAAGsQ,UAErCtQ,GAGJ,QACI+N,UAAWC,KACXrB,SAAUA,EACVkB,OAAQC,EAAUnB,GAClB8B,OAAQhC,EAAMgC,OACdC,OAAQjC,EAAMiC,QAStB,QAASZ,GAAUnB,GACf,GAAIa,GAAiBb,EAAS1M,MAG9B,IAAuB,IAAnBuN,EACA,OACIsB,EAAGuB,GAAM1D,EAAS,GAAGyD,SACrBpB,EAAGqB,GAAM1D,EAAS,GAAG2D,SAK7B,KADA,GAAIxB,GAAI,EAAGE,EAAI,EAAGhP,EAAI,EACfA,EAAIwN,GACPsB,GAAKnC,EAAS3M,GAAGoQ,QACjBpB,GAAKrC,EAAS3M,GAAGsQ,QACjBtQ,GAGJ,QACI8O,EAAGuB,GAAMvB,EAAItB,GACbwB,EAAGqB,GAAMrB,EAAIxB,IAWrB,QAASoB,GAAYX,EAAWa,EAAGE,GAC/B,OACIF,EAAGA,EAAIb,GAAa,EACpBe,EAAGA,EAAIf,GAAa,GAU5B,QAASO,GAAaM,EAAGE,GACrB,MAAIF,KAAME,EACCuB,GAGPtB,GAAIH,IAAMG,GAAID,GACPF,EAAI,EAAI0B,GAAiBC,GAE7BzB,EAAI,EAAI0B,GAAeC,GAUlC,QAAStC,GAAYuC,EAAIC,EAAI9Q,GACpBA,IACDA,EAAQ+Q,GAEZ,IAAIhC,GAAI+B,EAAG9Q,EAAM,IAAM6Q,EAAG7Q,EAAM,IAC5BiP,EAAI6B,EAAG9Q,EAAM,IAAM6Q,EAAG7Q,EAAM,GAEhC,OAAOgR,MAAKC,KAAMlC,EAAIA,EAAME,EAAIA,GAUpC,QAASb,GAASyC,EAAIC,EAAI9Q,GACjBA,IACDA,EAAQ+Q,GAEZ,IAAIhC,GAAI+B,EAAG9Q,EAAM,IAAM6Q,EAAG7Q,EAAM,IAC5BiP,EAAI6B,EAAG9Q,EAAM,IAAM6Q,EAAG7Q,EAAM,GAChC,OAA0B,KAAnBgR,KAAKE,MAAMjC,EAAGF,GAAWiC,KAAKG,GASzC,QAAS7B,GAAY8B,EAAOC,GACxB,MAAOjD,GAASiD,EAAI,GAAIA,EAAI,GAAIC,IAAmBlD,EAASgD,EAAM,GAAIA,EAAM,GAAIE,IAUpF,QAASlC,GAASgC,EAAOC,GACrB,MAAO/C,GAAY+C,EAAI,GAAIA,EAAI,GAAIC,IAAmBhD,EAAY8C,EAAM,GAAIA,EAAM,GAAIE,IAiB1F,QAAS/E,KACL7K,KAAK6P,KAAOC,GACZ9P,KAAK+P,MAAQC,GAEbhQ,KAAKiQ,SAAU,EAEfvG,EAAM3D,MAAM/F,KAAMgG,WAoEtB,QAASwE,KACLxK,KAAK6P,KAAOK,GACZlQ,KAAK+P,MAAQI,GAEbzG,EAAM3D,MAAM/F,KAAMgG,WAElBhG,KAAKoQ,MAASpQ,KAAK2J,QAAQ+B,QAAQ2E,iBAoEvC,QAASC,KACLtQ,KAAKuQ,SAAWC,GAChBxQ,KAAK+P,MAAQU,GACbzQ,KAAK0Q,SAAU,EAEfhH,EAAM3D,MAAM/F,KAAMgG,WAsCtB,QAAS2K,GAAuB1G,EAAI5C,GAChC,GAAIuJ,GAAMzI,EAAQ8B,EAAG4G,SACjBC,EAAU3I,EAAQ8B,EAAG8G,eAMzB,OAJI1J,IAAQmE,GAAYC,MACpBmF,EAAMvI,EAAYuI,EAAII,OAAOF,GAAU,cAAc,KAGjDF,EAAKE,GAiBjB,QAASpG,KACL1K,KAAKuQ,SAAWU,GAChBjR,KAAKkR,aAELxH,EAAM3D,MAAM/F,KAAMgG,WA0BtB,QAASmL,GAAWlH,EAAI5C,GACpB,GAAI+J,GAAajJ,EAAQ8B,EAAG4G,SACxBK,EAAYlR,KAAKkR,SAGrB,IAAI7J,GAAQiE,GAAc+F,KAAqC,IAAtBD,EAAW5S,OAEhD,MADA0S,GAAUE,EAAW,GAAGE,aAAc,GAC9BF,EAAYA,EAGxB,IAAI7S,GACAgT,EACAR,EAAiB5I,EAAQ8B,EAAG8G,gBAC5BS,KACAnT,EAAS2B,KAAK3B,MAQlB,IALAkT,EAAgBH,EAAWK,OAAO,SAASC,GACvC,MAAOnK,GAAUmK,EAAMrT,OAAQA,KAI/BgJ,IAASiE,GAET,IADA/M,EAAI,EACGA,EAAIgT,EAAc/S,QACrB0S,EAAUK,EAAchT,GAAG+S,aAAc,EACzC/S,GAMR,KADAA,EAAI,EACGA,EAAIwS,EAAevS,QAClB0S,EAAUH,EAAexS,GAAG+S,aAC5BE,EAAqBjP,KAAKwO,EAAexS,IAIzC8I,GAAQmE,GAAYC,WACbyF,GAAUH,EAAexS,GAAG+S,YAEvC/S,GAGJ,OAAKiT,GAAqBhT,QAMtB6J,EAAYkJ,EAAcP,OAAOQ,GAAuB,cAAc,GACtEA,GAPJ,OAwBJ,QAAS5G,KACLlB,EAAM3D,MAAM/F,KAAMgG,UAElB,IAAImB,GAAUrC,EAAO9E,KAAKmH,QAASnH,KACnCA,MAAK0R,MAAQ,GAAIhH,GAAW1K,KAAK2J,QAASxC,GAC1CnH,KAAK2R,MAAQ,GAAI9G,GAAW7K,KAAK2J,QAASxC,GAE1CnH,KAAK4R,aAAe,KACpB5R,KAAK6R,eAqCT,QAASC,GAAc/G,EAAWgH,GAC1BhH,EAAYO,IACZtL,KAAK4R,aAAeG,EAAU3G,gBAAgB,GAAGkG,WACjDU,EAAa5U,KAAK4C,KAAM+R,IACjBhH,GAAaS,GAAYC,KAChCuG,EAAa5U,KAAK4C,KAAM+R,GAIhC,QAASC,GAAaD,GAClB,GAAIL,GAAQK,EAAU3G,gBAAgB,EAEtC,IAAIsG,EAAMJ,aAAetR,KAAK4R,aAAc,CACxC,GAAIK,IAAa5E,EAAGqE,EAAM/C,QAASpB,EAAGmE,EAAM7C,QAC5C7O,MAAK6R,YAAYtP,KAAK0P,EACtB,IAAIC,GAAMlS,KAAK6R,YACXM,EAAkB,WAClB,GAAI5T,GAAI2T,EAAIpK,QAAQmK,EAChB1T,IAAI,GACJ2T,EAAIE,OAAO7T,EAAG,GAGtBsG,YAAWsN,EAAiBE,KAIpC,QAASC,GAAiBP,GAEtB,IAAK,GADD1E,GAAI0E,EAAUhE,SAASY,QAASpB,EAAIwE,EAAUhE,SAASc,QAClDtQ,EAAI,EAAGA,EAAIyB,KAAK6R,YAAYrT,OAAQD,IAAK,CAC9C,GAAIgU,GAAIvS,KAAK6R,YAAYtT,GACrBiU,EAAKlD,KAAK9B,IAAIH,EAAIkF,EAAElF,GAAIoF,EAAKnD,KAAK9B,IAAID,EAAIgF,EAAEhF,EAChD,IAAIiF,GAAME,IAAkBD,GAAMC,GAC9B,OAAO,EAGf,OAAO,EAsBX,QAASC,GAAYhJ,EAASzL,GAC1B8B,KAAK2J,QAAUA,EACf3J,KAAK4S,IAAI1U,GAmGb,QAAS2U,GAAkBC,GAEvB,GAAInL,EAAMmL,EAASC,IACf,MAAOA,GAGX,IAAIC,GAAUrL,EAAMmL,EAASG,IACzBC,EAAUvL,EAAMmL,EAASK,GAM7B,OAAIH,IAAWE,EACJH,GAIPC,GAAWE,EACJF,EAAUC,GAAqBE,GAItCxL,EAAMmL,EAASM,IACRA,GAGJC,GAGX,QAASC,MACL,IAAKC,GACD,OAAO,CAEX,IAAIC,MACAC,EAAc/S,EAAOgT,KAAOhT,EAAOgT,IAAIC,QAO3C,QANC,OAAQ,eAAgB,QAAS,QAAS,cAAe,QAAQvO,QAAQ,SAASuB,GAI/E6M,EAAS7M,IAAO8M,GAAc/S,EAAOgT,IAAIC,SAAS,eAAgBhN,KAE/D6M,EA4CX,QAASI,IAAW9J,GAChB9J,KAAK8J,QAAUrD,MAAWzG,KAAK6T,SAAU/J,OAEzC9J,KAAK9C,GAAKgM,IAEVlJ,KAAK2J,QAAU,KAGf3J,KAAK8J,QAAQI,OAASpD,EAAY9G,KAAK8J,QAAQI,QAAQ,GAEvDlK,KAAK8T,MAAQC,GAEb/T,KAAKgU,gBACLhU,KAAKiU,eAqOT,QAASC,IAASJ,GACd,MAAIA,GAAQK,GACD,SACAL,EAAQM,GACR,MACAN,EAAQO,GACR,OACAP,EAAQQ,GACR,QAEJ,GAQX,QAASC,IAAajG,GAClB,MAAIA,IAAaY,GACN,OACAZ,GAAaW,GACb,KACAX,GAAaS,GACb,OACAT,GAAaU,GACb,QAEJ,GASX,QAASwF,IAA6BC,EAAiBC,GACnD,GAAI/K,GAAU+K,EAAW/K,OACzB,OAAIA,GACOA,EAAQ1F,IAAIwQ,GAEhBA,EAQX,QAASE,MACLf,GAAW7N,MAAM/F,KAAMgG,WA6D3B,QAAS4O,MACLD,GAAe5O,MAAM/F,KAAMgG,WAE3BhG,KAAK6U,GAAK,KACV7U,KAAK8U,GAAK,KA4Ed,QAASC,MACLJ,GAAe5O,MAAM/F,KAAMgG,WAsC/B,QAASgP,MACLpB,GAAW7N,MAAM/F,KAAMgG,WAEvBhG,KAAKiV,OAAS,KACdjV,KAAKkV,OAAS,KAmElB,QAASC,MACLR,GAAe5O,MAAM/F,KAAMgG,WA8B/B,QAASoP,MACLT,GAAe5O,MAAM/F,KAAMgG,WA2D/B,QAASqP,MACLzB,GAAW7N,MAAM/F,KAAMgG,WAIvBhG,KAAKsV,OAAQ,EACbtV,KAAKuV,SAAU,EAEfvV,KAAKiV,OAAS,KACdjV,KAAKkV,OAAS,KACdlV,KAAKwV,MAAQ,EAqGjB,QAASC,IAAOpM,EAASS,GAGrB,MAFAA,GAAUA,MACVA,EAAQ4L,YAAc5O,EAAYgD,EAAQ4L,YAAaD,GAAO5B,SAAS8B,QAChE,GAAI/T,IAAQyH,EAASS,GAiIhC,QAASlI,IAAQyH,EAASS,GACtB9J,KAAK8J,QAAUrD,MAAWgP,GAAO5B,SAAU/J,OAE3C9J,KAAK8J,QAAQC,YAAc/J,KAAK8J,QAAQC,aAAeV,EAEvDrJ,KAAK4V,YACL5V,KAAK0L,WACL1L,KAAK0V,eACL1V,KAAK6V,eAEL7V,KAAKqJ,QAAUA,EACfrJ,KAAKgL,MAAQZ,EAAoBpK,MACjCA,KAAK8V,YAAc,GAAInD,GAAY3S,KAAMA,KAAK8J,QAAQgM,aAEtDC,GAAe/V,MAAM,GAErBmF,EAAKnF,KAAK8J,QAAQ4L,YAAa,SAASrT,GACpC,GAAIqS,GAAa1U,KAAK+B,IAAI,GAAKM,GAAK,GAAIA,EAAK,IAC7CA,GAAK,IAAMqS,EAAWsB,cAAc3T,EAAK,IACzCA,EAAK,IAAMqS,EAAWuB,eAAe5T,EAAK,KAC3CrC,MA4PP,QAAS+V,IAAepM,EAAS5H,GAC7B,GAAIsH,GAAUM,EAAQN,OACtB,IAAKA,EAAQxF,MAAb,CAGA,GAAIiF,EACJ3D,GAAKwE,EAAQG,QAAQoM,SAAU,SAAShY,EAAOsH,GAC3CsD,EAAOH,EAASU,EAAQxF,MAAO2B,GAC3BzD,GACA4H,EAAQkM,YAAY/M,GAAQO,EAAQxF,MAAMiF,GAC1CO,EAAQxF,MAAMiF,GAAQ5K,GAEtBmL,EAAQxF,MAAMiF,GAAQa,EAAQkM,YAAY/M,IAAS,KAGtD/G,IACD4H,EAAQkM,iBAShB,QAASM,IAAgBC,EAAOC,GAC5B,GAAIC,GAAepV,EAASqV,YAAY,QACxCD,GAAaE,UAAUJ,GAAO,GAAM,GACpCE,EAAaG,QAAUJ,EACvBA,EAAKhY,OAAOqY,cAAcJ,GAngF9B,GA+FI7P,IA/FAwC,IAAmB,GAAI,SAAU,MAAO,KAAM,KAAM,KACpD0N,GAAezV,EAASK,cAAc,OAEtCsF,GAAgB,WAEhB+H,GAAQU,KAAKV,MACbpB,GAAM8B,KAAK9B,IACXjB,GAAMqK,KAAKrK,GA0FX9F,IADyB,kBAAlBzI,QAAOyI,OACL,SAAgBpI,GACrB,GAAIA,IAAWmG,GAAwB,OAAXnG,EACxB,KAAM,IAAIN,WAAU,6CAIxB,KAAK,GADD8Y,GAAS7Y,OAAOK,GACXyY,EAAQ,EAAGA,EAAQ9Q,UAAUxH,OAAQsY,IAAS,CACnD,GAAIC,GAAS/Q,UAAU8Q,EACvB,IAAIC,IAAWvS,GAAwB,OAAXuS,EACxB,IAAK,GAAIC,KAAWD,GACZA,EAAO1R,eAAe2R,KACtBH,EAAOG,GAAWD,EAAOC,IAKzC,MAAOH,IAGF7Y,OAAOyI,MAWpB,IAAIwQ,IAAS3R,EAAU,SAAgB4R,EAAMzU,EAAK0U,GAG9C,IAFA,GAAIC,GAAOpZ,OAAOoZ,KAAK3U,GACnBlE,EAAI,EACDA,EAAI6Y,EAAK5Y,UACP2Y,GAAUA,GAASD,EAAKE,EAAK7Y,MAAQiG,KACtC0S,EAAKE,EAAK7Y,IAAMkE,EAAI2U,EAAK7Y,KAE7BA,GAEJ,OAAO2Y,IACR,SAAU,iBASTC,GAAQ7R,EAAU,SAAe4R,EAAMzU,GACvC,MAAOwU,IAAOC,EAAMzU,GAAK,IAC1B,QAAS,iBAiNR0G,GAAY,EAeZkO,GAAe,wCAEf1M,GAAiB,gBAAkBjK,GACnC6J,GAAyB5B,EAASjI,EAAQ,kBAAoB8D,EAC9DiG,GAAqBE,IAAiB0M,GAAaC,KAAKC,UAAUC,WAElEC,GAAmB,QACnBC,GAAiB,MACjBC,GAAmB,QACnBC,GAAoB,SAEpBnJ,GAAmB,GAEnBnD,GAAc,EACd+F,GAAa,EACb7F,GAAY,EACZC,GAAe,EAEfqD,GAAiB,EACjBC,GAAiB,EACjBC,GAAkB,EAClBC,GAAe,EACfC,GAAiB,GAEjB2I,GAAuB9I,GAAiBC,GACxC8I,GAAqB7I,GAAeC,GACpC6I,GAAgBF,GAAuBC,GAEvCzI,IAAY,IAAK,KACjBO,IAAmB,UAAW,UA4BlClG,GAAM1K,WAKFmI,QAAS,aAKTgD,KAAM,WACFnK,KAAK6P,MAAQ5I,EAAkBjH,KAAKqJ,QAASrJ,KAAK6P,KAAM7P,KAAKgK,YAC7DhK,KAAKuQ,UAAYtJ,EAAkBjH,KAAK3B,OAAQ2B,KAAKuQ,SAAUvQ,KAAKgK,YACpEhK,KAAK+P,OAAS9I,EAAkBmC,EAAoBpJ,KAAKqJ,SAAUrJ,KAAK+P,MAAO/P,KAAKgK,aAMxFgO,QAAS,WACLhY,KAAK6P,MAAQvI,EAAqBtH,KAAKqJ,QAASrJ,KAAK6P,KAAM7P,KAAKgK,YAChEhK,KAAKuQ,UAAYjJ,EAAqBtH,KAAK3B,OAAQ2B,KAAKuQ,SAAUvQ,KAAKgK,YACvEhK,KAAK+P,OAASzI,EAAqB8B,EAAoBpJ,KAAKqJ,SAAUrJ,KAAK+P,MAAO/P,KAAKgK,aA4T/F,IAAIiO,KACAC,UAAW5M,GACX6M,UAAW9G,GACX+G,QAAS5M,IAGTsE,GAAuB,YACvBE,GAAsB,mBAgB1B/J,GAAQ4E,EAAYnB,GAKhBvC,QAAS,SAAmB8C,GACxB,GAAIc,GAAYkN,GAAgBhO,EAAG5C,KAG/B0D,GAAYO,IAA6B,IAAdrB,EAAGoO,SAC9BrY,KAAKiQ,SAAU,GAGflF,EAAYsG,IAA2B,IAAbpH,EAAGjG,QAC7B+G,EAAYS,IAIXxL,KAAKiQ,UAINlF,EAAYS,KACZxL,KAAKiQ,SAAU,GAGnBjQ,KAAK4J,SAAS5J,KAAK2J,QAASoB,GACxBG,UAAWjB,GACXmB,iBAAkBnB,GAClBqO,YAAaX,GACb5J,SAAU9D,OAKtB,IAAIsO,KACAC,YAAalN,GACbmN,YAAapH,GACbqH,UAAWlN,GACXmN,cAAelN,GACfmN,WAAYnN,IAIZoN,IACAC,EAAGrB,GACHsB,EAAGrB,GACHsB,EAAGrB,GACHsB,EAAGrB,IAGH1H,GAAyB,cACzBC,GAAwB,qCAGxBzP,GAAOwY,iBAAmBxY,EAAOyY,eACjCjJ,GAAyB,gBACzBC,GAAwB,6CAiB5BlK,EAAQuE,EAAmBd,GAKvBvC,QAAS,SAAmB8C,GACxB,GAAImG,GAAQpQ,KAAKoQ,MACbgJ,GAAgB,EAEhBC,EAAsBpP,EAAG5C,KAAKiS,cAAczT,QAAQ,KAAM,IAC1DkF,EAAYwN,GAAkBc,GAC9Bf,EAAcO,GAAuB5O,EAAGqO,cAAgBrO,EAAGqO,YAE3DiB,EAAWjB,GAAeb,GAG1B+B,EAAavR,EAAQmI,EAAOnG,EAAGwP,UAAW,YAG1C1O,GAAYO,KAA8B,IAAdrB,EAAGoO,QAAgBkB,GAC3CC,EAAa,IACbpJ,EAAM7N,KAAK0H,GACXuP,EAAapJ,EAAM5R,OAAS,GAEzBuM,GAAaS,GAAYC,MAChC2N,GAAgB,GAIhBI,EAAa,IAKjBpJ,EAAMoJ,GAAcvP,EAEpBjK,KAAK4J,SAAS5J,KAAK2J,QAASoB,GACxBG,SAAUkF,EACVhF,iBAAkBnB,GAClBqO,YAAaA,EACbvK,SAAU9D,IAGVmP,GAEAhJ,EAAMgC,OAAOoH,EAAY,MAKrC,IAAIE,KACAC,WAAYrO,GACZsO,UAAWvI,GACXwI,SAAUrO,GACVsO,YAAarO,IAGb+E,GAA6B,aAC7BC,GAA6B,2CAejCxK,GAAQqK,EAAkB5G,GACtBvC,QAAS,SAAmB8C,GACxB,GAAI5C,GAAOqS,GAAuBzP,EAAG5C,KAOrC,IAJIA,IAASiE,KACTtL,KAAK0Q,SAAU,GAGd1Q,KAAK0Q,QAAV,CAIA,GAAIG,GAAUF,EAAuBvT,KAAK4C,KAAMiK,EAAI5C,EAGhDA,IAAQmE,GAAYC,KAAiBoF,EAAQ,GAAGrS,OAASqS,EAAQ,GAAGrS,SAAW,IAC/EwB,KAAK0Q,SAAU,GAGnB1Q,KAAK4J,SAAS5J,KAAK2J,QAAStC,GACxB6D,SAAU2F,EAAQ,GAClBzF,gBAAiByF,EAAQ,GACzByH,YAAab,GACb1J,SAAU9D,OAsBtB,IAAI8P,KACAJ,WAAYrO,GACZsO,UAAWvI,GACXwI,SAAUrO,GACVsO,YAAarO,IAGbwF,GAAsB,2CAc1BhL,GAAQyE,EAAYhB,GAChBvC,QAAS,SAAoB8C,GACzB,GAAI5C,GAAO0S,GAAgB9P,EAAG5C,MAC1BwJ,EAAUM,EAAW/T,KAAK4C,KAAMiK,EAAI5C,EACnCwJ,IAIL7Q,KAAK4J,SAAS5J,KAAK2J,QAAStC,GACxB6D,SAAU2F,EAAQ,GAClBzF,gBAAiByF,EAAQ,GACzByH,YAAab,GACb1J,SAAU9D,MA4EtB,IAAIoI,IAAgB,KAChBK,GAAiB,EAarBzM,GAAQ2E,EAAiBlB,GAOrBvC,QAAS,SAAoBwC,EAASqQ,EAAYC,GAC9C,GAAIV,GAAWU,EAAU3B,aAAeb,GACpCyC,EAAWD,EAAU3B,aAAeX,EAExC,MAAIuC,GAAWD,EAAUE,oBAAsBF,EAAUE,mBAAmBC,kBAA5E,CAKA,GAAIb,EACAzH,EAAc1U,KAAK4C,KAAMga,EAAYC,OAClC,IAAIC,GAAW5H,EAAiBlV,KAAK4C,KAAMia,GAC9C,MAGJja,MAAK4J,SAASD,EAASqQ,EAAYC,KAMvCjC,QAAS,WACLhY,KAAK0R,MAAMsG,UACXhY,KAAK2R,MAAMqG,YA0CnB,IAAIqC,IAAwB1R,EAASgO,GAAa9S,MAAO,eACrD0P,GAAsB8G,KAA0B7V,EAGhD8V,GAAuB,UACvBjH,GAAoB,OACpBD,GAA4B,eAC5BL,GAAoB,OACpBE,GAAqB,QACrBE,GAAqB,QACrBoH,GAAmBjH,IAcvBX,GAAY3T,WAKR4T,IAAK,SAAS1U,GAENA,GAASoc,KACTpc,EAAQ8B,KAAKwa,WAGbjH,IAAuBvT,KAAK2J,QAAQN,QAAQxF,OAAS0W,GAAiBrc,KACtE8B,KAAK2J,QAAQN,QAAQxF,MAAMwW,IAAyBnc,GAExD8B,KAAK8S,QAAU5U,EAAMob,cAAcvR,QAMvC0S,OAAQ,WACJza,KAAK4S,IAAI5S,KAAK2J,QAAQG,QAAQgM,cAOlC0E,QAAS,WACL,GAAI1H,KAMJ,OALA3N,GAAKnF,KAAK2J,QAAQ+L,YAAa,SAAShB,GAChChO,EAASgO,EAAW5K,QAAQI,QAASwK,MACrC5B,EAAUA,EAAQ9B,OAAO0D,EAAWgG,qBAGrC7H,EAAkBC,EAAQ6H,KAAK,OAO1CC,gBAAiB,SAAS5P,GACtB,GAAI+C,GAAW/C,EAAM+C,SACjBO,EAAYtD,EAAM8B,eAGtB,IAAI9M,KAAK2J,QAAQ+B,QAAQmP,UAErB,WADA9M,GAAS+M,gBAIb,IAAIhI,GAAU9S,KAAK8S,QACfiI,EAAUpT,EAAMmL,EAASC,MAAuBwH,GAAiBxH,IACjEG,EAAUvL,EAAMmL,EAASK,MAAwBoH,GAAiBpH,IAClEH,EAAUrL,EAAMmL,EAASG,MAAwBsH,GAAiBtH,GAEtE,IAAI8H,EAAS,CAGT,GAAIC,GAAyC,IAA1BhQ,EAAME,SAAS1M,OAC9Byc,EAAgBjQ,EAAM2B,SAAW,EACjCuO,EAAiBlQ,EAAMwB,UAAY,GAEvC,IAAIwO,GAAgBC,GAAiBC,EACjC,OAIR,MAAIlI,IAAWE,EAAf,OAKI6H,GACC7H,GAAW5E,EAAYuJ,IACvB7E,GAAW1E,EAAYwJ,GACjB9X,KAAKmb,WAAWpN,GAH3B,QAWJoN,WAAY,SAASpN,GACjB/N,KAAK2J,QAAQ+B,QAAQmP,WAAY,EACjC9M,EAAS+M,kBAiFjB,IAAI/G,IAAiB,EACjBO,GAAc,EACdD,GAAgB,EAChBD,GAAc,EACdgH,GAAmBhH,GACnBD,GAAkB,GAClBkH,GAAe,EAwBnBzH,IAAW5U,WAKP6U,YAOAjB,IAAK,SAAS9I,GAKV,MAJArD,IAAOzG,KAAK8J,QAASA,GAGrB9J,KAAK2J,SAAW3J,KAAK2J,QAAQmM,YAAY2E,SAClCza,MAQXgW,cAAe,SAASvB,GACpB,GAAI1P,EAAe0P,EAAiB,gBAAiBzU,MACjD,MAAOA,KAGX,IAAIgU,GAAehU,KAAKgU,YAMxB,OALAS,GAAkBD,GAA6BC,EAAiBzU,MAC3DgU,EAAaS,EAAgBvX,MAC9B8W,EAAaS,EAAgBvX,IAAMuX,EACnCA,EAAgBuB,cAAchW,OAE3BA,MAQXsb,kBAAmB,SAAS7G,GACxB,MAAI1P,GAAe0P,EAAiB,oBAAqBzU,MAC9CA,MAGXyU,EAAkBD,GAA6BC,EAAiBzU,YACzDA,MAAKgU,aAAaS,EAAgBvX,IAClC8C,OAQXiW,eAAgB,SAASxB,GACrB,GAAI1P,EAAe0P,EAAiB,iBAAkBzU,MAClD,MAAOA,KAGX,IAAIiU,GAAcjU,KAAKiU,WAMvB,OALAQ,GAAkBD,GAA6BC,EAAiBzU,MAC5DiI,EAAQgM,EAAaQ,MAAqB,IAC1CR,EAAY1R,KAAKkS,GACjBA,EAAgBwB,eAAejW,OAE5BA,MAQXub,mBAAoB,SAAS9G,GACzB,GAAI1P,EAAe0P,EAAiB,qBAAsBzU,MACtD,MAAOA,KAGXyU,GAAkBD,GAA6BC,EAAiBzU,KAChE,IAAI8W,GAAQ7O,EAAQjI,KAAKiU,YAAaQ,EAItC,OAHIqC,IAAQ,GACR9W,KAAKiU,YAAY7B,OAAO0E,EAAO,GAE5B9W,MAOXwb,mBAAoB,WAChB,MAAOxb,MAAKiU,YAAYzV,OAAS,GAQrCid,iBAAkB,SAAShH,GACvB,QAASzU,KAAKgU,aAAaS,EAAgBvX,KAQ/C0O,KAAM,QAAAA,GAASZ,GAIX,QAASY,GAAKwK,GACVvM,EAAKF,QAAQiC,KAAKwK,EAAOpL,GAJ7B,GAAInB,GAAO7J,KACP8T,EAAQ9T,KAAK8T,KAObA,GAAQM,IACRxI,EAAK/B,EAAKC,QAAQsM,MAAQlC,GAASJ,IAGvClI,EAAK/B,EAAKC,QAAQsM,OAEdpL,EAAM0Q,iBACN9P,EAAKZ,EAAM0Q,iBAIX5H,GAASM,IACTxI,EAAK/B,EAAKC,QAAQsM,MAAQlC,GAASJ,KAU3C6H,QAAS,SAAS3Q,GACd,MAAIhL,MAAK4b,UACE5b,KAAK4L,KAAKZ,QAGrBhL,KAAK8T,MAAQuH,KAOjBO,QAAS,WAEL,IADA,GAAIrd,GAAI,EACDA,EAAIyB,KAAKiU,YAAYzV,QAAQ,CAChC,KAAMwB,KAAKiU,YAAY1V,GAAGuV,OAASuH,GAAetH,KAC9C,OAAO,CAEXxV,KAEJ,OAAO,GAOXsN,UAAW,SAASoO,GAGhB,GAAI4B,GAAiBpV,MAAWwT,EAGhC,OAAKvT,GAAS1G,KAAK8J,QAAQI,QAASlK,KAAM6b,KAOtC7b,KAAK8T,OAASsH,GAAmBjH,GAAkBkH,MACnDrb,KAAK8T,MAAQC,IAGjB/T,KAAK8T,MAAQ9T,KAAK8b,QAAQD,QAItB7b,KAAK8T,OAASQ,GAAcD,GAAgBD,GAAcD,KAC1DnU,KAAK2b,QAAQE,MAfb7b,KAAKuD,aACLvD,KAAK8T,MAAQuH,MAyBrBS,QAAS,SAAS7B,KAOlBS,eAAgB,aAOhBnX,MAAO,cA8DX0C,EAAQ0O,GAAgBf,IAKpBC,UAKI3I,SAAU,GASd6Q,SAAU,SAAS/Q,GACf,GAAIgR,GAAiBhc,KAAK8J,QAAQoB,QAClC,OAA0B,KAAnB8Q,GAAwBhR,EAAME,SAAS1M,SAAWwd,GAS7DF,QAAS,SAAS9Q,GACd,GAAI8I,GAAQ9T,KAAK8T,MACb/I,EAAYC,EAAMD,UAElBkR,EAAenI,GAASQ,GAAcD,IACtC6H,EAAUlc,KAAK+b,SAAS/Q,EAG5B,OAAIiR,KAAiBlR,EAAYU,KAAiByQ,GACvCpI,EAAQK,GACR8H,GAAgBC,EACnBnR,EAAYS,GACLsI,EAAQM,GACNN,EAAQQ,GAGdR,EAAQO,GAFJC,GAIR+G,MAiBfpV,EAAQ2O,GAAeD,IAKnBd,UACIuC,MAAO,MACP+F,UAAW,GACXjR,SAAU,EACVoD,UAAWyJ,IAGf2C,eAAgB,WACZ,GAAIpM,GAAYtO,KAAK8J,QAAQwE,UACzBwE,IAOJ,OANIxE,GAAYuJ,IACZ/E,EAAQvQ,KAAK4Q,IAEb7E,EAAYwJ,IACZhF,EAAQvQ,KAAK0Q,IAEVH,GAGXsJ,cAAe,SAASpR,GACpB,GAAIlB,GAAU9J,KAAK8J,QACfuS,GAAW,EACX1P,EAAW3B,EAAM2B,SACjB2B,EAAYtD,EAAMsD,UAClBjB,EAAIrC,EAAMgC,OACVO,EAAIvC,EAAMiC,MAed,OAZMqB,GAAYxE,EAAQwE,YAClBxE,EAAQwE,UAAYuJ,IACpBvJ,EAAmB,IAANjB,EAAWyB,GAAkBzB,EAAI,EAAK0B,GAAiBC,GACpEqN,EAAWhP,GAAKrN,KAAK6U,GACrBlI,EAAW2C,KAAK9B,IAAIxC,EAAMgC,UAE1BsB,EAAmB,IAANf,EAAWuB,GAAkBvB,EAAI,EAAK0B,GAAeC,GAClEmN,EAAW9O,GAAKvN,KAAK8U,GACrBnI,EAAW2C,KAAK9B,IAAIxC,EAAMiC,UAGlCjC,EAAMsD,UAAYA,EACX+N,GAAY1P,EAAW7C,EAAQqS,WAAa7N,EAAYxE,EAAQwE,WAG3EyN,SAAU,SAAS/Q,GACf,MAAO2J,IAAe3V,UAAU+c,SAAS3e,KAAK4C,KAAMgL,KAC/ChL,KAAK8T,MAAQQ,MAAkBtU,KAAK8T,MAAQQ,KAAgBtU,KAAKoc,cAAcpR,KAGxFY,KAAM,SAASZ,GAEXhL,KAAK6U,GAAK7J,EAAMgC,OAChBhN,KAAK8U,GAAK9J,EAAMiC,MAEhB,IAAIqB,GAAYiG,GAAavJ,EAAMsD,UAE/BA,KACAtD,EAAM0Q,gBAAkB1b,KAAK8J,QAAQsM,MAAQ9H,GAEjDtO,KAAKwG,OAAOoF,KAAKxO,KAAK4C,KAAMgL,MAcpC/E,EAAQ8O,GAAiBJ,IAKrBd,UACIuC,MAAO,QACP+F,UAAW,EACXjR,SAAU,GAGdwP,eAAgB,WACZ,OAAQ3H,KAGZgJ,SAAU,SAAS/Q,GACf,MAAOhL,MAAKwG,OAAOuV,SAAS3e,KAAK4C,KAAMgL,KAClCsE,KAAK9B,IAAIxC,EAAMyC,MAAQ,GAAKzN,KAAK8J,QAAQqS,WAAanc,KAAK8T,MAAQQ,KAG5E1I,KAAM,SAASZ,GACX,GAAoB,IAAhBA,EAAMyC,MAAa,CACnB,GAAI6O,GAAQtR,EAAMyC,MAAQ,EAAI,KAAO,KACrCzC,GAAM0Q,gBAAkB1b,KAAK8J,QAAQsM,MAAQkG,EAEjDtc,KAAKwG,OAAOoF,KAAKxO,KAAK4C,KAAMgL,MAiBpC/E,EAAQ+O,GAAiBpB,IAKrBC,UACIuC,MAAO,QACPlL,SAAU,EACVqR,KAAM,IACNJ,UAAW,GAGfzB,eAAgB,WACZ,OAAQrH,KAGZyI,QAAS,SAAS9Q,GACd,GAAIlB,GAAU9J,KAAK8J,QACf0S,EAAgBxR,EAAME,SAAS1M,SAAWsL,EAAQoB,SAClDuR,EAAgBzR,EAAM2B,SAAW7C,EAAQqS,UACzCO,EAAY1R,EAAMwB,UAAY1C,EAAQyS,IAM1C,IAJAvc,KAAKkV,OAASlK,GAITyR,IAAkBD,GAAkBxR,EAAMD,WAAaS,GAAYC,MAAkBiR,EACtF1c,KAAKuD,YACF,IAAIyH,EAAMD,UAAYO,GACzBtL,KAAKuD,QACLvD,KAAKiV,OAASxQ,EAAkB,WAC5BzE,KAAK8T,MAAQsH,GACbpb,KAAK2b,WACN7R,EAAQyS,KAAMvc,UACd,IAAIgL,EAAMD,UAAYS,GACzB,MAAO4P,GAEX,OAAOC,KAGX9X,MAAO,WACHoZ,aAAa3c,KAAKiV,SAGtBrJ,KAAM,SAASZ,GACPhL,KAAK8T,QAAUsH,KAIfpQ,GAAUA,EAAMD,UAAYS,GAC5BxL,KAAK2J,QAAQiC,KAAK5L,KAAK8J,QAAQsM,MAAQ,KAAMpL,IAE7ChL,KAAKkV,OAAO5I,UAAYC,KACxBvM,KAAK2J,QAAQiC,KAAK5L,KAAK8J,QAAQsM,MAAOpW,KAAKkV,aAevDjP,EAAQkP,GAAkBR,IAKtBd,UACIuC,MAAO,SACP+F,UAAW,EACXjR,SAAU,GAGdwP,eAAgB,WACZ,OAAQ3H,KAGZgJ,SAAU,SAAS/Q,GACf,MAAOhL,MAAKwG,OAAOuV,SAAS3e,KAAK4C,KAAMgL,KAClCsE,KAAK9B,IAAIxC,EAAM2C,UAAY3N,KAAK8J,QAAQqS,WAAanc,KAAK8T,MAAQQ,OAc/ErO,EAAQmP,GAAiBT,IAKrBd,UACIuC,MAAO,QACP+F,UAAW,GACXhO,SAAU,GACVG,UAAWuJ,GAAuBC,GAClC5M,SAAU,GAGdwP,eAAgB,WACZ,MAAO9F,IAAc5V,UAAU0b,eAAetd,KAAK4C,OAGvD+b,SAAU,SAAS/Q,GACf,GACImD,GADAG,EAAYtO,KAAK8J,QAAQwE,SAW7B,OARIA,IAAauJ,GAAuBC,IACpC3J,EAAWnD,EAAMkC,gBACVoB,EAAYuJ,GACnB1J,EAAWnD,EAAMoC,iBACVkB,EAAYwJ,KACnB3J,EAAWnD,EAAMsC,kBAGdtN,KAAKwG,OAAOuV,SAAS3e,KAAK4C,KAAMgL,IACnCsD,EAAYtD,EAAM8B,iBAClB9B,EAAM2B,SAAW3M,KAAK8J,QAAQqS,WAC9BnR,EAAM6C,aAAe7N,KAAK8J,QAAQoB,UAClCsC,GAAIW,GAAYnO,KAAK8J,QAAQqE,UAAYnD,EAAMD,UAAYS,IAGnEI,KAAM,SAASZ,GACX,GAAIsD,GAAYiG,GAAavJ,EAAM8B,gBAC/BwB,IACAtO,KAAK2J,QAAQiC,KAAK5L,KAAK8J,QAAQsM,MAAQ9H,EAAWtD,GAGtDhL,KAAK2J,QAAQiC,KAAK5L,KAAK8J,QAAQsM,MAAOpL,MA2B9C/E,EAAQoP,GAAezB,IAKnBC,UACIuC,MAAO,MACPlL,SAAU,EACV0R,KAAM,EACNC,SAAU,IACVN,KAAM,IACNJ,UAAW,EACXW,aAAc,IAGlBpC,eAAgB,WACZ,OAAQtH,KAGZ0I,QAAS,SAAS9Q,GACd,GAAIlB,GAAU9J,KAAK8J,QAEf0S,EAAgBxR,EAAME,SAAS1M,SAAWsL,EAAQoB,SAClDuR,EAAgBzR,EAAM2B,SAAW7C,EAAQqS,UACzCY,EAAiB/R,EAAMwB,UAAY1C,EAAQyS,IAI/C,IAFAvc,KAAKuD,QAEAyH,EAAMD,UAAYO,IAAgC,IAAftL,KAAKwV,MACzC,MAAOxV,MAAKgd,aAKhB,IAAIP,GAAiBM,GAAkBP,EAAe,CAClD,GAAIxR,EAAMD,WAAaS,GACnB,MAAOxL,MAAKgd,aAGhB,IAAIC,IAAgBjd,KAAKsV,OAAStK,EAAMsB,UAAYtM,KAAKsV,MAAQxL,EAAQ+S,SACrEK,GAAiBld,KAAKuV,SAAW3I,EAAY5M,KAAKuV,QAASvK,EAAMoB,QAAUtC,EAAQgT,YAEvF9c,MAAKsV,MAAQtK,EAAMsB,UACnBtM,KAAKuV,QAAUvK,EAAMoB,OAEhB8Q,GAAkBD,EAGnBjd,KAAKwV,OAAS,EAFdxV,KAAKwV,MAAQ,EAKjBxV,KAAKkV,OAASlK,CAId,IAAImS,GAAWnd,KAAKwV,MAAQ1L,EAAQ8S,IACpC,IAAiB,IAAbO,EAGA,MAAKnd,MAAKwb,sBAGNxb,KAAKiV,OAASxQ,EAAkB,WAC5BzE,KAAK8T,MAAQsH,GACbpb,KAAK2b,WACN7R,EAAQ+S,SAAU7c,MACdsU,IANA8G,GAUnB,MAAOC,KAGX2B,YAAa,WAIT,MAHAhd,MAAKiV,OAASxQ,EAAkB,WAC5BzE,KAAK8T,MAAQuH,IACdrb,KAAK8J,QAAQ+S,SAAU7c,MACnBqb,IAGX9X,MAAO,WACHoZ,aAAa3c,KAAKiV,SAGtBrJ,KAAM,WACE5L,KAAK8T,OAASsH,KACdpb,KAAKkV,OAAOiI,SAAWnd,KAAKwV,MAC5BxV,KAAK2J,QAAQiC,KAAK5L,KAAK8J,QAAQsM,MAAOpW,KAAKkV,YAoBvDO,GAAO2H,QAAU,QAMjB3H,GAAO5B,UAOHwJ,WAAW,EAQXvH,YAAawE,GAMbpQ,QAAQ,EASRH,YAAa,KAObO,WAAY,KAOZqL,SAEKR,IAAmBjL,QAAQ,KAC3B6K,IAAkB7K,QAAQ,IAAS,YACnCkL,IAAkB9G,UAAWuJ,MAC7BjD,IAAgBtG,UAAWuJ,KAAwB,WACnDxC,KACAA,IAAgBe,MAAO,YAAawG,KAAM,IAAK,SAC/C5H,KAQLkB,UAMIoH,WAAY,OAOZC,YAAa,OASbC,aAAc,OAOdC,eAAgB,OAOhBC,SAAU,OAQVC,kBAAmB,iBAI3B,IAAIC,IAAO,EACPC,GAAc,CA+BlBjc,IAAQ5C,WAMJ4T,IAAK,SAAS9I,GAaV,MAZArD,IAAOzG,KAAK8J,QAASA,GAGjBA,EAAQgM,aACR9V,KAAK8V,YAAY2E,SAEjB3Q,EAAQC,cAER/J,KAAKgL,MAAMgN,UACXhY,KAAKgL,MAAM3M,OAASyL,EAAQC,YAC5B/J,KAAKgL,MAAMb,QAERnK,MASX8d,KAAM,SAASC,GACX/d,KAAK0L,QAAQsS,QAAUD,EAAQF,GAAcD,IASjD/R,UAAW,SAASoO,GAChB,GAAIvO,GAAU1L,KAAK0L,OACnB,KAAIA,EAAQsS,QAAZ,CAKAhe,KAAK8V,YAAY8E,gBAAgBX,EAEjC,IAAIvF,GACAgB,EAAc1V,KAAK0V,YAKnBuI,EAAgBvS,EAAQuS,gBAIvBA,GAAkBA,GAAiBA,EAAcnK,MAAQsH,MAC1D6C,EAAgBvS,EAAQuS,cAAgB,KAI5C,KADA,GAAI1f,GAAI,EACDA,EAAImX,EAAYlX,QACnBkW,EAAagB,EAAYnX,GAQrBmN,EAAQsS,UAAYH,IACfI,GAAiBvJ,GAAcuJ,IAChCvJ,EAAW+G,iBAAiBwC,GAGhCvJ,EAAWnR,QAFXmR,EAAW7I,UAAUoO,IAOpBgE,GAAiBvJ,EAAWZ,OAASQ,GAAcD,GAAgBD,MACpE6J,EAAgBvS,EAAQuS,cAAgBvJ,GAE5CnW,MASR0F,IAAK,SAASyQ,GACV,GAAIA,YAAsBd,IACtB,MAAOc,EAIX,KAAK,GADDgB,GAAc1V,KAAK0V,YACdnX,EAAI,EAAGA,EAAImX,EAAYlX,OAAQD,IACpC,GAAImX,EAAYnX,GAAGuL,QAAQsM,OAAS1B,EAChC,MAAOgB,GAAYnX,EAG3B,OAAO,OASXwD,IAAK,SAAS2S,GACV,GAAI3P,EAAe2P,EAAY,MAAO1U,MAClC,MAAOA,KAIX,IAAIke,GAAWle,KAAKiE,IAAIyQ,EAAW5K,QAAQsM,MAS3C,OARI8H,IACAle,KAAKme,OAAOD,GAGhBle,KAAK0V,YAAYnT,KAAKmS,GACtBA,EAAW/K,QAAU3J,KAErBA,KAAK8V,YAAY2E,SACV/F,GAQXyJ,OAAQ,SAASzJ,GACb,GAAI3P,EAAe2P,EAAY,SAAU1U,MACrC,MAAOA,KAMX,IAHA0U,EAAa1U,KAAKiE,IAAIyQ,GAGN,CACZ,GAAIgB,GAAc1V,KAAK0V,YACnBoB,EAAQ7O,EAAQyN,EAAahB,EAE7BoC,MAAU,IACVpB,EAAYtD,OAAO0E,EAAO,GAC1B9W,KAAK8V,YAAY2E,UAIzB,MAAOza,OASXgC,GAAI,SAASoc,EAAQjX,GACjB,GAAIiX,IAAW5Z,GAGX2C,IAAY3C,EAAhB,CAIA,GAAIoR,GAAW5V,KAAK4V,QAKpB,OAJAzQ,GAAKiC,EAASgX,GAAS,SAAShI,GAC5BR,EAASQ,GAASR,EAASQ,OAC3BR,EAASQ,GAAO7T,KAAK4E,KAElBnH,OASXqe,IAAK,SAASD,EAAQjX,GAClB,GAAIiX,IAAW5Z,EAAf,CAIA,GAAIoR,GAAW5V,KAAK4V,QAQpB,OAPAzQ,GAAKiC,EAASgX,GAAS,SAAShI,GACvBjP,EAGDyO,EAASQ,IAAUR,EAASQ,GAAOhE,OAAOnK,EAAQ2N,EAASQ,GAAQjP,GAAU,SAFtEyO,GAASQ,KAKjBpW,OAQX4L,KAAM,SAASwK,EAAOC,GAEdrW,KAAK8J,QAAQuT,WACblH,GAAgBC,EAAOC,EAI3B,IAAIT,GAAW5V,KAAK4V,SAASQ,IAAUpW,KAAK4V,SAASQ,GAAOhO,OAC5D,IAAKwN,GAAaA,EAASpX,OAA3B,CAIA6X,EAAKhP,KAAO+O,EACZC,EAAKyE,eAAiB,WAClBzE,EAAKtI,SAAS+M,iBAIlB,KADA,GAAIvc,GAAI,EACDA,EAAIqX,EAASpX,QAChBoX,EAASrX,GAAG8X,GACZ9X,MAQRyZ,QAAS,WACLhY,KAAKqJ,SAAW0M,GAAe/V,MAAM,GAErCA,KAAK4V,YACL5V,KAAK0L,WACL1L,KAAKgL,MAAMgN,UACXhY,KAAKqJ,QAAU,OAyCvB5C,GAAOgP,IACHnK,YAAaA,GACb+F,WAAYA,GACZ7F,UAAWA,GACXC,aAAcA,GAEdsI,eAAgBA,GAChBO,YAAaA,GACbD,cAAeA,GACfD,YAAaA,GACbgH,iBAAkBA,GAClBjH,gBAAiBA,GACjBkH,aAAcA,GAEdvM,eAAgBA,GAChBC,eAAgBA,GAChBC,gBAAiBA,GACjBC,aAAcA,GACdC,eAAgBA,GAChB2I,qBAAsBA,GACtBC,mBAAoBA,GACpBC,cAAeA,GAEfnW,QAASA,GACT8H,MAAOA,EACPiJ,YAAaA,EAEbjI,WAAYA,EACZG,WAAYA,EACZL,kBAAmBA,EACnBI,gBAAiBA,EACjB0F,iBAAkBA,EAElBsD,WAAYA,GACZe,eAAgBA,GAChB/R,IAAKyS,GACLvT,IAAK8S,GACL/S,MAAOuT,GACPkJ,MAAOvJ,GACPwJ,OAAQpJ,GACRqJ,MAAOxJ,GAEPhT,GAAIiF,EACJoX,IAAK/W,EACLnC,KAAMA,EACNgS,MAAOA,GACPF,OAAQA,GACRxQ,OAAQA,GACRR,QAASA,EACTnB,OAAQA,EACR6D,SAAUA,GAKd,IAAI8V,IAAgC,mBAAX/d,GAAyBA,EAA0B,mBAATmJ,MAAuBA,OAC1F4U,IAAWhJ,OAASA,GAGhBvR,EAAO,WACH,MAAOuR,KADXrY,KAAAJ,EAAAH,EAAAG,EAAAC,KAAAiH,IAAAM,IAAAvH,EAAAD,QAAAkH,KASDxD,OAAQQ,SAAU,WHoSf,SAASjE,EAAQD,EAASH,GIn3FhC,GAAA6hB,GAAA7hB,EAAA,EACA,iBAAA6hB,SAAAzhB,EAAAC,GAAAwhB,EAAA,KAEA7hB,GAAA,GAAA6hB,KACAA,GAAAC,SAAA1hB,EAAAD,QAAA0hB,EAAAC,SJy4FM,SAAS1hB,EAAQD,EAASH,GKh5FhCG,EAAAC,EAAAD,QAAAH,EAAA,KAKAG,EAAAuF,MAAAtF,EAAAC,GAAA,wxDAA+yD,MLy5FzyD,SAASD,EAAQD,GAEtB,YM35FDC,GAAOD,QAAU,WAChB,GAAI4hB,KA0CJ,OAvCAA,GAAKC,SAAW,WAEf,IAAI,GADAC,MACIvgB,EAAI,EAAGA,EAAIyB,KAAKxB,OAAQD,IAAK,CACpC,GAAI8D,GAAOrC,KAAKzB,EACb8D,GAAK,GACPyc,EAAOvc,KAAK,UAAYF,EAAK,GAAK,IAAMA,EAAK,GAAK,KAElDyc,EAAOvc,KAAKF,EAAK,IAGnB,MAAOyc,GAAOnE,KAAK,KAIpBiE,EAAKrgB,EAAI,SAAS3B,EAASmiB,GACJ,gBAAZniB,KACTA,IAAY,KAAMA,EAAS,KAE5B,KAAI,GADAoiB,MACIzgB,EAAI,EAAGA,EAAIyB,KAAKxB,OAAQD,IAAK,CACpC,GAAIrB,GAAK8C,KAAKzB,GAAG,EACA,iBAAPrB,KACT8hB,EAAuB9hB,IAAM,GAE/B,IAAIqB,EAAI,EAAGA,EAAI3B,EAAQ4B,OAAQD,IAAK,CACnC,GAAI8D,GAAOzF,EAAQ2B,EAKG,iBAAZ8D,GAAK,IAAoB2c,EAAuB3c,EAAK,MAC3D0c,IAAe1c,EAAK,GACtBA,EAAK,GAAK0c,EACDA,IACT1c,EAAK,GAAK,IAAMA,EAAK,GAAK,UAAY0c,EAAa,KAEpDH,EAAKrc,KAAKF,MAINuc,INq6FF,SAAS3hB,EAAQD,EAASH,GOx5FhC,QAAAoiB,GAAAC,EAAApV,GACA,OAAAvL,GAAA,EAAeA,EAAA2gB,EAAA1gB,OAAmBD,IAAA,CAClC,GAAA8D,GAAA6c,EAAA3gB,GACA4gB,EAAAC,EAAA/c,EAAAnF,GACA,IAAAiiB,EAAA,CACAA,EAAAE,MACA,QAAAC,GAAA,EAAiBA,EAAAH,EAAAI,MAAA/gB,OAA2B8gB,IAC5CH,EAAAI,MAAAD,GAAAjd,EAAAkd,MAAAD,GAEA,MAAQA,EAAAjd,EAAAkd,MAAA/gB,OAAuB8gB,IAC/BH,EAAAI,MAAAhd,KAAAid,EAAAnd,EAAAkd,MAAAD,GAAAxV,QAEG,CAEH,OADAyV,MACAD,EAAA,EAAiBA,EAAAjd,EAAAkd,MAAA/gB,OAAuB8gB,IACxCC,EAAAhd,KAAAid,EAAAnd,EAAAkd,MAAAD,GAAAxV,GAEAsV,GAAA/c,EAAAnF,KAA2BA,GAAAmF,EAAAnF,GAAAmiB,KAAA,EAAAE,WAK3B,QAAAE,GAAAb,GAGA,OAFAM,MACAQ,KACAnhB,EAAA,EAAeA,EAAAqgB,EAAApgB,OAAiBD,IAAA,CAChC,GAAA8D,GAAAuc,EAAArgB,GACArB,EAAAmF,EAAA,GACAsd,EAAAtd,EAAA,GACAud,EAAAvd,EAAA,GACAwd,EAAAxd,EAAA,GACAyd,GAAcH,MAAAC,QAAAC,YACdH,GAAAxiB,GAGAwiB,EAAAxiB,GAAAqiB,MAAAhd,KAAAud,GAFAZ,EAAA3c,KAAAmd,EAAAxiB,IAAgCA,KAAAqiB,OAAAO,KAIhC,MAAAZ,GAGA,QAAAa,GAAAjW,EAAAkW,GACA,GAAAC,GAAAC,IACAC,EAAAC,IAAA5hB,OAAA,EACA,YAAAsL,EAAAuW,SACAF,EAEGA,EAAAG,YACHL,EAAAM,aAAAP,EAAAG,EAAAG,aAEAL,EAAAve,YAAAse,GAJAC,EAAAM,aAAAP,EAAAC,EAAAO,YAMAJ,EAAA7d,KAAAyd,OACE,eAAAlW,EAAAuW,SAGF,SAAA1a,OAAA,qEAFAsa,GAAAve,YAAAse,IAMA,QAAAS,GAAAT,GACAA,EAAAtY,WAAAgZ,YAAAV,EACA,IAAAW,GAAAP,EAAAtY,QAAAkY,EACAW,IAAA,GACAP,EAAAhO,OAAAuO,EAAA,GAIA,QAAAC,GAAA9W,GACA,GAAAkW,GAAA9e,SAAAK,cAAA,QAGA,OAFAye,GAAA3Y,KAAA,WACA0Y,EAAAjW,EAAAkW,GACAA,EAGA,QAAAa,GAAA/W,GACA,GAAAgX,GAAA5f,SAAAK,cAAA,OAGA,OAFAuf,GAAAC,IAAA,aACAhB,EAAAjW,EAAAgX,GACAA,EAGA,QAAAtB,GAAA/hB,EAAAqM,GACA,GAAAkW,GAAAvF,EAAA0D,CAEA,IAAArU,EAAAkX,UAAA,CACA,GAAAC,GAAAC,GACAlB,GAAAmB,MAAAP,EAAA9W,IACA2Q,EAAA2G,EAAA5gB,KAAA,KAAAwf,EAAAiB,GAAA,GACA9C,EAAAiD,EAAA5gB,KAAA,KAAAwf,EAAAiB,GAAA,OACExjB,GAAAoiB,WACF,kBAAAwB,MACA,kBAAAA,KAAAC,iBACA,kBAAAD,KAAAE,iBACA,kBAAAC,OACA,kBAAAC,OACAzB,EAAAa,EAAA/W,GACA2Q,EAAAiH,EAAAlhB,KAAA,KAAAwf,GACA7B,EAAA,WACAsC,EAAAT,GACAA,EAAA2B,MACAN,IAAAE,gBAAAvB,EAAA2B,SAGA3B,EAAAY,EAAA9W,GACA2Q,EAAAmH,EAAAphB,KAAA,KAAAwf,GACA7B,EAAA,WACAsC,EAAAT,IAMA,OAFAvF,GAAAhd,GAEA,SAAAokB,GACA,GAAAA,EAAA,CACA,GAAAA,EAAAlC,MAAAliB,EAAAkiB,KAAAkC,EAAAjC,QAAAniB,EAAAmiB,OAAAiC,EAAAhC,YAAApiB,EAAAoiB,UACA,MACApF,GAAAhd,EAAAokB,OAEA1D,MAcA,QAAAiD,GAAApB,EAAAlJ,EAAAqH,EAAA1gB,GACA,GAAAkiB,GAAAxB,EAAA,GAAA1gB,EAAAkiB,GAEA,IAAAK,EAAA8B,WACA9B,EAAA8B,WAAAC,QAAAC,EAAAlL,EAAA6I,OACE,CACF,GAAAsC,GAAA/gB,SAAAghB,eAAAvC,GACAwC,EAAAnC,EAAAmC,UACAA,GAAArL,IAAAkJ,EAAAU,YAAAyB,EAAArL,IACAqL,EAAA3jB,OACAwhB,EAAAO,aAAA0B,EAAAE,EAAArL,IAEAkJ,EAAAte,YAAAugB,IAKA,QAAAL,GAAA5B,EAAAviB,GACA,GAAAkiB,GAAAliB,EAAAkiB,IACAC,EAAAniB,EAAAmiB,KAMA,IAJAA,GACAI,EAAAoC,aAAA,QAAAxC,GAGAI,EAAA8B,WACA9B,EAAA8B,WAAAC,QAAApC,MACE,CACF,KAAAK,EAAAQ,YACAR,EAAAU,YAAAV,EAAAQ,WAEAR,GAAAte,YAAAR,SAAAghB,eAAAvC,KAIA,QAAA+B,GAAAZ,EAAArjB,GACA,GAAAkiB,GAAAliB,EAAAkiB,IACAE,EAAApiB,EAAAoiB,SAEAA,KAEAF,GAAA,uDAAuD8B,KAAAY,SAAAC,mBAAAC,KAAAC,UAAA3C,MAAA,MAGvD,IAAA4C,GAAA,GAAAjB,OAAA7B,IAA6BtY,KAAA,aAE7Bqb,EAAA5B,EAAAa,IAEAb,GAAAa,KAAAN,IAAAC,gBAAAmB,GAEAC,GACArB,IAAAE,gBAAAmB,GAhPA,GAAAtD,MACAuD,EAAA,SAAAje,GACA,GAAAke,EACA,mBAEA,MADA,mBAAAA,OAAAle,EAAAqB,MAAA/F,KAAAgG,YACA4c,IAGAC,EAAAF,EAAA,WACA,qBAAArL,KAAA5W,OAAA6W,UAAAC,UAAA8B,iBAEA4G,EAAAyC,EAAA,WACA,MAAAzhB,UAAA+e,MAAA/e,SAAA4hB,qBAAA,aAEA3B,EAAA,KACAD,EAAA,EACAd,IAEAnjB,GAAAD,QAAA,SAAA4hB,EAAA9U,GAKAA,QAGA,mBAAAA,GAAAkX,YAAAlX,EAAAkX,UAAA6B,KAGA,mBAAA/Y,GAAAuW,WAAAvW,EAAAuW,SAAA,SAEA,IAAAnB,GAAAO,EAAAb,EAGA,OAFAK,GAAAC,EAAApV,GAEA,SAAAiZ,GAEA,OADAC,MACAzkB,EAAA,EAAgBA,EAAA2gB,EAAA1gB,OAAmBD,IAAA,CACnC,GAAA8D,GAAA6c,EAAA3gB,GACA4gB,EAAAC,EAAA/c,EAAAnF,GACAiiB,GAAAE,OACA2D,EAAAzgB,KAAA4c,GAEA,GAAA4D,EAAA,CACA,GAAArD,GAAAD,EAAAsD,EACA9D,GAAAS,EAAA5V,GAEA,OAAAvL,GAAA,EAAgBA,EAAAykB,EAAAxkB,OAAsBD,IAAA,CACtC,GAAA4gB,GAAA6D,EAAAzkB,EACA,QAAA4gB,EAAAE,KAAA,CACA,OAAAC,GAAA,EAAkBA,EAAAH,EAAAI,MAAA/gB,OAA2B8gB,IAC7CH,EAAAI,MAAAD,WACAF,GAAAD,EAAAjiB,OAiIA,IAAA8kB,GAAA,WACA,GAAAiB,KAEA,iBAAAnM,EAAAoM,GAEA,MADAD,GAAAnM,GAAAoM,EACAD,EAAAxR,OAAA0R,SAAAxI,KAAA,WPohGM,SAAS1d,EAAQD,GQjtGvBC,EAAAD,QAAA,sZRutGM,SAASC,EAAQD,GSvtGvBC,EAAAD,QAAA,0gCT6tGM,SAASC,EAAQD,GU7tGvBC,EAAAD,QAAA,8hCVmuGM,SAASC,EAAQD,GAEtB,YAQA,SAASY,GAAgBC,EAAUC,GAAe,KAAMD,YAAoBC,IAAgB,KAAM,IAAIC,WAAU,qCANhHC,OAAOC,eAAejB,EAAS,cAC3BkB,OAAO,GAGX,IAAIC,GAAe,WAAc,QAASC,GAAiBC,EAAQC,GAAS,IAAK,GAAIC,GAAI,EAAGA,EAAID,EAAME,OAAQD,IAAK,CAAE,GAAIE,GAAaH,EAAMC,EAAIE,GAAWC,WAAaD,EAAWC,aAAc,EAAOD,EAAWE,cAAe,EAAU,SAAWF,KAAYA,EAAWG,UAAW,GAAMZ,OAAOC,eAAeI,EAAQI,EAAWI,IAAKJ,IAAiB,MAAO,UAAUX,EAAagB,EAAYC,GAAiJ,MAA9HD,IAAYV,EAAiBN,EAAYkB,UAAWF,GAAiBC,GAAaX,EAAiBN,EAAaiB,GAAqBjB,MW3uG3hBslB,EX+uGa,WACd,QAASA,KACLxlB,EAAgBoC,KAAMojB,GAyE1B,MAtEAjlB,GAAailB,IACTvkB,IAAK,QACLX,MAAO,SWrvGLmE,GACH,GAAIghB,GAAgBniB,SAASK,cAAc,MAG3C,OAFA8hB,GAAc3hB,YAAYW,EAAKgH,SAC/BrJ,KAAKsjB,cAAcD,EAAehhB,GAC3BghB,KXwvGNxkB,IAAK,gBACLX,MAAO,SWtvGEmlB,EAAehhB,GACzB,GAAIV,GAAK,GAAI8T,QAAO7T,QAAQyhB,GACxBE,EAAQ,GAAI9N,QAAO6I,MACnBkF,EAAM,GAAI/N,QAAO3T,GACrBH,GAAGI,IAAIwhB,GACP5hB,EAAGI,IAAIyhB,EAEP,IAAIC,GAAc,EACdC,EAAc,EACdC,EAAc,EACdC,EAAc,EACdC,EAAqB,EACrBC,EAAqB,EACrBC,KACAC,EAAc,EACdC,EAAc,EACdC,EAAc,EACdC,EAAY,EACZC,EAAY,CAEhBziB,GAAGK,GAAG,aAAc,SAACpB,GACjB6iB,EAAcphB,EAAKgH,QAAQgb,YAC3BX,EAAcrhB,EAAKgH,QAAQib,aAC3BX,EAActhB,EAAKgH,QAAQkb,WAC3BX,EAAcvhB,EAAKgH,QAAQmb,UAC3BX,EAAqBjjB,EAAEsK,SAAS,GAAGyD,QACnCmV,EAAqBljB,EAAEsK,SAAS,GAAG2D,QACnCoV,EAAc5hB,EAAKgH,QAAQkb,WAC3BL,EAAc7hB,EAAKgH,QAAQmb,SAE3B,IAAIC,GAAK7jB,EAAEsK,SAAS,GAAGyD,QACnB+V,EAAK9jB,EAAEsK,SAAS,GAAGyD,QACnBgW,EAAK/jB,EAAEsK,SAAS,GAAG2D,QACnB+V,EAAKhkB,EAAEsK,SAAS,GAAG2D,OACvBkV,GAAW1W,EAAIoX,GAAOC,EAAKD,GAAM,EACjCV,EAAWxW,EAAIoX,GAAOC,EAAKD,GAAM,GAGrC,IAAIE,GAAU,SAACjkB,GACXyB,EAAKyiB,OAAQrB,EAAc7iB,EAAE6M,MAASiW,EAAc9iB,EAAE6M,MAAQsW,EAAYJ,EAAaC,EAAaI,GAGxGriB,GAAGK,GAAG,UAAW6iB,GACjBljB,EAAGK,GAAG,WAAW6iB,GACjBljB,EAAGK,GAAG,WAAY,SAACpB,GACfujB,EAAYvjB,EAAEsK,SAAS,GAAGyD,QAC1ByV,EAAYxjB,EAAEsK,SAAS,GAAG2D,QAC1BoV,EAAc5hB,EAAKgH,QAAQkb,WAC3BL,EAAc7hB,EAAKgH,QAAQmb,YAE/B7iB,EAAGK,GAAG,YAAa,SAACpB,GAChBojB,GAAe3W,EAAGzM,EAAEsK,SAAS,GAAGyD,QAAUkV,EAAmBtW,EAAI3M,EAAEsK,SAAS,GAAG2D,QAAUiV,KAG7FniB,EAAGK,GAAG,UAAW,SAACpB,GACdyB,EAAK0iB,KAAKd,GAAeE,EAAYvjB,EAAEsK,SAAS,GAAGyD,SAAWuV,GAAeE,EAAYxjB,EAAEsK,SAAS,GAAG2D,gBX2vGvGuU,IAMXpmB,GAAQW,QW3vGM,GAAIylB,IX+vGb,SAASnmB,EAAQD,EAASH,GAE/B,YAkBA,SAASW,GAAuBC,GAAO,MAAOA,IAAOA,EAAIC,WAAaD,GAAQE,QAASF,GAEvF,QAASG,GAAgBC,EAAUC,GAAe,KAAMD,YAAoBC,IAAgB,KAAM,IAAIC,WAAU,qCAlBhHC,OAAOC,eAAejB,EAAS,cAC3BkB,OAAO,GAGX,IAAIC,GAAe,WAAc,QAASC,GAAiBC,EAAQC,GAAS,IAAK,GAAIC,GAAI,EAAGA,EAAID,EAAME,OAAQD,IAAK,CAAE,GAAIE,GAAaH,EAAMC,EAAIE,GAAWC,WAAaD,EAAWC,aAAc,EAAOD,EAAWE,cAAe,EAAU,SAAWF,KAAYA,EAAWG,UAAW,GAAMZ,OAAOC,eAAeI,EAAQI,EAAWI,IAAKJ,IAAiB,MAAO,UAAUX,EAAagB,EAAYC,GAAiJ,MAA9HD,IAAYV,EAAiBN,EAAYkB,UAAWF,GAAiBC,GAAaX,EAAiBN,EAAaiB,GAAqBjB,MYx0GjiBknB,EAAAnoB,EAAA,IZ80GKooB,EAAcznB,EAAuBwnB,GY70G1CE,EAAAroB,EAAA,IZi1GKsoB,EAAgB3nB,EAAuB0nB,GY/0GtCE,EZq1Ga,WACd,QAASA,KACLxnB,EAAgBoC,KAAMolB,GAoB1B,MAjBAjnB,GAAainB,IACTvmB,IAAK,QACLX,MAAO,SY31GLmnB,GACH,OAAQA,EAAShe,MACb,IAAK,QACD,MAAO,IAAA4d,GAAAtnB,QAAc0nB,EAASthB,MAAOshB,EAASC,IAElD,KAAK,UACD,MAAO,IAAAH,GAAAxnB,QAAgB0nB,EAASthB,MAAOshB,EAASE,SAAUF,EAASG,YAEvE,SACI,KAAM,IAAIznB,WAAU,2CZi2GxBqnB,IAGXpoB,GAAQW,QY91GM,GAAIynB,IZk2Gb,SAASnoB,EAAQD,EAASH,GAE/B,YAYA,SAASW,GAAuBC,GAAO,MAAOA,IAAOA,EAAIC,WAAaD,GAAQE,QAASF,GAEvF,QAASG,GAAgBC,EAAUC,GAAe,KAAMD,YAAoBC,IAAgB,KAAM,IAAIC,WAAU,qCAEhH,QAAS0nB,GAA2B5b,EAAMzM,GAAQ,IAAKyM,EAAQ,KAAM,IAAI6b,gBAAe,4DAAgE,QAAOtoB,GAAyB,gBAATA,IAAqC,kBAATA,GAA8ByM,EAAPzM,EAElO,QAASuoB,GAAUC,EAAUC,GAAc,GAA0B,kBAAfA,IAA4C,OAAfA,EAAuB,KAAM,IAAI9nB,WAAU,iEAAoE8nB,GAAeD,GAAS5mB,UAAYhB,OAAOuI,OAAOsf,GAAcA,EAAW7mB,WAAasF,aAAepG,MAAO0nB,EAAUlnB,YAAY,EAAOE,UAAU,EAAMD,cAAc,KAAeknB,IAAY7nB,OAAO8nB,eAAiB9nB,OAAO8nB,eAAeF,EAAUC,GAAcD,EAASG,UAAYF,GAhBje7nB,OAAOC,eAAejB,EAAS,cAC3BkB,OAAO,GAGX,IAAIC,GAAe,WAAc,QAASC,GAAiBC,EAAQC,GAAS,IAAK,GAAIC,GAAI,EAAGA,EAAID,EAAME,OAAQD,IAAK,CAAE,GAAIE,GAAaH,EAAMC,EAAIE,GAAWC,WAAaD,EAAWC,aAAc,EAAOD,EAAWE,cAAe,EAAU,SAAWF,KAAYA,EAAWG,UAAW,GAAMZ,OAAOC,eAAeI,EAAQI,EAAWI,IAAKJ,IAAiB,MAAO,UAAUX,EAAagB,EAAYC,GAAiJ,MAA9HD,IAAYV,EAAiBN,EAAYkB,UAAWF,GAAiBC,GAAaX,EAAiBN,EAAaiB,GAAqBjB,Ma93GjiBkoB,EAAAnpB,EAAA,Ibk4GKopB,EAAgBzoB,EAAuBwoB,Gaj4GvBE,Eb84GJ,SAAUC,Ga74GvB,QAAAD,GAAaniB,EAAOuhB,GAAK1nB,EAAAoC,KAAAkmB,EAAA,IAAAnmB,GAAA0lB,EAAAzlB,MAAAkmB,EAAAH,WAAA/nB,OAAAooB,eAAAF,IAAA9oB,KAAA4C,KACf,QAAS+D;AADM,MAErBhE,GAAKsmB,KAAOf,EAGZvlB,EAAKumB,SAAWplB,SAASK,cAAc,OACvCxB,EAAKumB,SAASC,OAAS,SAAC3lB,GACpBb,EAAKwD,SAETxD,EAAKumB,SAAS7jB,IAAM1C,EAAKsmB,KATJtmB,Eb46GxB,MA9BA4lB,GAAUO,EAAWC,GAkBrBhoB,EAAa+nB,IACTrnB,IAAK,WACLX,MAAO,Waj5GR8B,KAAKuD,Wbq5GJ1E,IAAK,MACLoF,IAAK,Wa15GN,MAAOjE,MAAKqmB,Sb+5GRH,GACTD,EAActoB,QAEhBX,GAAQW,Qah7GYuoB,Gbo7Gf,SAASjpB,EAAQD,GAEtB,YAQA,SAASY,GAAgBC,EAAUC,GAAe,KAAMD,YAAoBC,IAAgB,KAAM,IAAIC,WAAU,qCANhHC,OAAOC,eAAejB,EAAS,cAC3BkB,OAAO,GAGX,IAAIC,GAAe,WAAc,QAASC,GAAiBC,EAAQC,GAAS,IAAK,GAAIC,GAAI,EAAGA,EAAID,EAAME,OAAQD,IAAK,CAAE,GAAIE,GAAaH,EAAMC,EAAIE,GAAWC,WAAaD,EAAWC,aAAc,EAAOD,EAAWE,cAAe,EAAU,SAAWF,KAAYA,EAAWG,UAAW,GAAMZ,OAAOC,eAAeI,EAAQI,EAAWI,IAAKJ,IAAiB,MAAO,UAAUX,EAAagB,EAAYC,GAAiJ,MAA9HD,IAAYV,EAAiBN,EAAYkB,UAAWF,GAAiBC,GAAaX,EAAiBN,EAAaiB,GAAqBjB,Mc77G5gB0oB,Edo8GF,Wcn8Gf,QAAAA,GAAanf,EAAMtD,GAAOnG,EAAAoC,KAAAwmB,GACtBxmB,KAAKymB,MAAQpf,EACbrH,KAAK0mB,OAAS3iB,EACd/D,KAAKsmB,SAAW,KdgmHnB,MAvJAnoB,GAAaqoB,IACT3nB,IAAK,SACLX,MAAO,Sc57GJyoB,EAAGC,EAAG7C,EAAY8C,EAAQC,EAAQ9Y,GACtC,GAAIX,UACAE,SAGAwZ,EAAY/mB,KAAKqJ,QAAQ3B,WAAW2c,YAAcrkB,KAAKqJ,QAAQ3B,WAAW4c,aAC1E0C,EAAYhnB,KAAKqJ,QAAQgb,YAAcrkB,KAAKqJ,QAAQib,YAEpDyC,GAAYC,GAAaJ,EAAI5mB,KAAKqJ,QAAQ3B,WAAW4c,cACrDsC,EAAI5mB,KAAKqJ,QAAQ3B,WAAW4c,aAC5BqC,EAAI3mB,KAAKqJ,QAAQgb,aACV0C,EAAYC,GAAaL,EAAI3mB,KAAKqJ,QAAQ3B,WAAW2c,cAC5DuC,EAAI5mB,KAAKqJ,QAAQib,aACjBqC,EAAI3mB,KAAKqJ,QAAQ3B,WAAW2c,cAI5BuC,EAA2C,EAAvC5mB,KAAKqJ,QAAQ3B,WAAW4c,cAAoBqC,EAA0C,EAAtC3mB,KAAKqJ,QAAQ3B,WAAW2c,eAC5EuC,EAAI5mB,KAAKqJ,QAAQib,aACjBqC,EAAI3mB,KAAKqJ,QAAQgb,YAGrB,IAAI5W,SAEAA,GADAsZ,EAAYC,EACHhnB,KAAKqJ,QAAQib,aAAetkB,KAAKqJ,QAAQ3B,WAAW4c,aAAgB,EAEpEtkB,KAAKqJ,QAAQgb,YAAcrkB,KAAKqJ,QAAQ3B,WAAW2c,YAAe,CAK/E,IAAI4C,IAAe5Z,EAAGwZ,EAA0B,EAAf9C,EAAW1W,EAAQE,EAAGuZ,EAAyB,EAAf/C,EAAWxW,EAE5EF,IAAKwZ,EAAUI,EAAY5Z,GAAMI,EACjCF,GAAKuZ,EAAUG,EAAY1Z,GAAME,EAEjCJ,GAAKW,EAAOX,EACZE,GAAKS,EAAOT,EAIRqZ,EAAI5mB,KAAKqJ,QAAQ3B,WAAW4c,aAC5B/W,GAAKvN,KAAKqJ,QAAQ3B,WAAW4c,aAAesC,GAAK,EACzCA,EAAI5mB,KAAKqJ,QAAQ3B,WAAW4c,cAAgB/W,EAAI,EACxDA,EAAI,EACGqZ,EAAI5mB,KAAKqJ,QAAQ3B,WAAW4c,cAAgB/W,EAAI,GAAIqZ,EAAI5mB,KAAKqJ,QAAQ3B,WAAW4c,cACvF/W,EAAI,GAAIqZ,EAAI5mB,KAAKqJ,QAAQ3B,WAAW4c,cAC7BsC,IAAM5mB,KAAKqJ,QAAQ3B,WAAW4c,eACrC/W,EAAI,GAGJoZ,EAAI3mB,KAAKqJ,QAAQ3B,WAAW2c,YAC5BhX,GAAKrN,KAAKqJ,QAAQ3B,WAAW2c,YAAcsC,GAAK,EACzCA,EAAI3mB,KAAKqJ,QAAQ3B,WAAW2c,aAAehX,EAAI,EACtDA,EAAI,EACGsZ,EAAI3mB,KAAKqJ,QAAQ3B,WAAW2c,aAAehX,EAAI,GAAIsZ,EAAI3mB,KAAKqJ,QAAQ3B,WAAW2c,aACtFhX,EAAI,GAAIsZ,EAAI3mB,KAAKqJ,QAAQ3B,WAAW2c,aAC7BsC,IAAM3mB,KAAKqJ,QAAQ3B,WAAW2c,cACrChX,EAAI,GAGRrN,KAAKqJ,QAAQxF,MAAMqjB,QAAU,OAC7BlnB,KAAKqJ,QAAQxF,MAAMsjB,IAAM7X,KAAK8X,MAAM7Z,GAAK,KACzCvN,KAAKqJ,QAAQxF,MAAMC,KAAOwL,KAAK8X,MAAM/Z,GAAK,KAC1CrN,KAAKqJ,QAAQxF,MAAMwjB,MAAQ/X,KAAK8X,MAAMT,GAAK,KAC3C3mB,KAAKqJ,QAAQxF,MAAMyjB,OAAShY,KAAK8X,MAAMR,GAAK,KAC5C5mB,KAAKqJ,QAAQxF,MAAMqjB,QAAU,Wd87G5BroB,IAAK,OACLX,MAAO,Sc57GNmP,EAAGE,GAEDvN,KAAKqJ,QAAQgb,YAAcrkB,KAAKqJ,QAAQ3B,WAAW2c,YAC/ChX,EAAI,EACJA,EAAI,EACGA,EAAIrN,KAAKqJ,QAAQ3B,WAAW2c,YAAcrkB,KAAKqJ,QAAQgb,cAC9DhX,EAAIrN,KAAKqJ,QAAQ3B,WAAW2c,YAAcrkB,KAAKqJ,QAAQgb,aAI3DhX,EAAIrN,KAAKqJ,QAAQkb,WAGjBvkB,KAAKqJ,QAAQib,aAAetkB,KAAKqJ,QAAQ3B,WAAW4c,aAChD/W,EAAI,EACJA,EAAI,EACGA,EAAIvN,KAAKqJ,QAAQ3B,WAAW4c,aAAetkB,KAAKqJ,QAAQib,eAC/D/W,EAAIvN,KAAKqJ,QAAQ3B,WAAW4c,aAAetkB,KAAKqJ,QAAQib,cAG5D/W,EAAIvN,KAAKqJ,QAAQmb,UAIrBxkB,KAAKqJ,QAAQxF,MAAMC,KAAOuJ,EAAI,KAC9BrN,KAAKqJ,QAAQxF,MAAMsjB,IAAM5Z,EAAI,Qd+7G5B1O,IAAK,QACLX,MAAO,Wc37GR8B,KAAKqJ,QAAQxF,MAAM0jB,eAAe,UAClCvnB,KAAKqJ,QAAQxF,MAAM0jB,eAAe,QAGlC,IAAIR,GAAY/mB,KAAKqJ,QAAQ3B,WAAW2c,YAAcrkB,KAAKqJ,QAAQ3B,WAAW4c,aAC1EkD,EAAUxnB,KAAKqJ,QAAQgb,YAAcrkB,KAAKqJ,QAAQib,YAElDyC,GAAYS,GACZxnB,KAAKqJ,QAAQxF,MAAMsjB,IAAM,MACzBnnB,KAAKqJ,QAAQxF,MAAMyjB,OAAStnB,KAAKqJ,QAAQ3B,WAAW4c,aAAe,KACnEtkB,KAAKqJ,QAAQxF,MAAMC,MAAS9D,KAAKqJ,QAAQ3B,WAAW2c,YAAcrkB,KAAKqJ,QAAQgb,aAAe,EAAK,MAC5F0C,EAAYS,GACnBxnB,KAAKqJ,QAAQxF,MAAMC,KAAO,MAC1B9D,KAAKqJ,QAAQxF,MAAMwjB,MAAQrnB,KAAKqJ,QAAQ3B,WAAW2c,YAAc,KACjErkB,KAAKqJ,QAAQxF,MAAMsjB,KAAQnnB,KAAKqJ,QAAQ3B,WAAW4c,aAAetkB,KAAKqJ,QAAQib,cAAe,EAAK,OAEnGtkB,KAAKqJ,QAAQxF,MAAMsjB,IAAM,MACzBnnB,KAAKqJ,QAAQxF,MAAMC,KAAO,MAC1B9D,KAAKqJ,QAAQxF,MAAMyjB,OAAStnB,KAAKqJ,QAAQ3B,WAAW4c,aAAe,KACnEtkB,KAAKqJ,QAAQxF,MAAMwjB,MAAQrnB,KAAKqJ,QAAQ3B,WAAW2c,YAAc,Sdi8GpExlB,IAAK,UACLX,MAAO,eAIPW,IAAK,WACLX,MAAO,eAIPW,IAAK,QACLoF,IAAK,Wc7kHN,MAAOjE,MAAK0mB,UdilHX7nB,IAAK,OACLoF,IAAK,Wc9kHN,MAAOjE,MAAKymB,SdklHX5nB,IAAK,UACLoF,IAAK,Wc/kHN,MAAOjE,MAAKsmB,adolHRE,IAGXxpB,GAAQW,QcvmHY6oB,Gd2mHf,SAASvpB,EAAQD,EAASH,GAE/B,YAYA,SAASW,GAAuBC,GAAO,MAAOA,IAAOA,EAAIC,WAAaD,GAAQE,QAASF,GAEvF,QAASG,GAAgBC,EAAUC,GAAe,KAAMD,YAAoBC,IAAgB,KAAM,IAAIC,WAAU,qCAEhH,QAAS0nB,GAA2B5b,EAAMzM,GAAQ,IAAKyM,EAAQ,KAAM,IAAI6b,gBAAe,4DAAgE,QAAOtoB,GAAyB,gBAATA,IAAqC,kBAATA,GAA8ByM,EAAPzM,EAElO,QAASuoB,GAAUC,EAAUC,GAAc,GAA0B,kBAAfA,IAA4C,OAAfA,EAAuB,KAAM,IAAI9nB,WAAU,iEAAoE8nB,GAAeD,GAAS5mB,UAAYhB,OAAOuI,OAAOsf,GAAcA,EAAW7mB,WAAasF,aAAepG,MAAO0nB,EAAUlnB,YAAY,EAAOE,UAAU,EAAMD,cAAc,KAAeknB,IAAY7nB,OAAO8nB,eAAiB9nB,OAAO8nB,eAAeF,EAAUC,GAAcD,EAASG,UAAYF,GAhBje7nB,OAAOC,eAAejB,EAAS,cAC3BkB,OAAO,GAGX,IAAIC,GAAe,WAAc,QAASC,GAAiBC,EAAQC,GAAS,IAAK,GAAIC,GAAI,EAAGA,EAAID,EAAME,OAAQD,IAAK,CAAE,GAAIE,GAAaH,EAAMC,EAAIE,GAAWC,WAAaD,EAAWC,aAAc,EAAOD,EAAWE,cAAe,EAAU,SAAWF,KAAYA,EAAWG,UAAW,GAAMZ,OAAOC,eAAeI,EAAQI,EAAWI,IAAKJ,IAAiB,MAAO,UAAUX,EAAagB,EAAYC,GAAiJ,MAA9HD,IAAYV,EAAiBN,EAAYkB,UAAWF,GAAiBC,GAAaX,EAAiBN,EAAaiB,GAAqBjB,MelnHjiBkoB,EAAAnpB,EAAA,IfsnHKopB,EAAgBzoB,EAAuBwoB,GernHvByB,EfioHF,SAAUtB,GehoHzB,QAAAsB,GAAa1jB,EAAOwhB,EAAUC,GAAa5nB,EAAAoC,KAAAynB,EAAA,IAAA1nB,GAAA0lB,EAAAzlB,MAAAynB,EAAA1B,WAAA/nB,OAAAooB,eAAAqB,IAAArqB,KAAA4C,KACjC,UAAW+D,GAEjBhE,GAAKumB,SAAWplB,SAASK,cAAc,UACvCxB,EAAKsJ,QAAQ+Y,aAAa,KAAM,UAChCriB,EAAKsJ,QAAQ+Y,aAAa,OAAQ,aAClCriB,EAAKsJ,QAAQ+Y,aAAa,cAAe,IACzC,IAAIkD,GAAM,gCAAkCC,EAAW,gBACvD,KAAK,GAAIhnB,KAAKinB,GACVF,GAAO,IAAM/mB,EAAI,IAAMinB,EAAYjnB,EATA,OAWvCwB,GAAKsJ,QAAQ+Y,aAAa,MAAOkD,GAXMvlB,Ef2qH1C,MA1CA4lB,GAAU8B,EAAatB,GAmBvBhoB,EAAaspB,IACT5oB,IAAK,QACLX,MAAO,WevoHR8B,KAAKqJ,QAAQge,MAAQ,OACrBrnB,KAAKqJ,QAAQie,OAAS,Uf2oHrBzoB,IAAK,OACLX,MAAO,WexoHR,OAAO,Kf4oHNW,IAAK,SACLX,MAAO,WezoHR,OAAO,Kf6oHNW,IAAK,WACLX,MAAO,We1oHR8B,KAAKqJ,QAAQqe,cAAcC,YAAY,mDAAoD,Sf+oHvFF,GACTxB,EAActoB,QAEhBX,GAAQW,Qe/qHY8pB","file":"easy-gallery.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _hammerjs = __webpack_require__(1);\n\t\n\tvar _hammerjs2 = _interopRequireDefault(_hammerjs);\n\t\n\t__webpack_require__(2);\n\t\n\tvar _fullscreen = __webpack_require__(6);\n\t\n\tvar _fullscreen2 = _interopRequireDefault(_fullscreen);\n\t\n\tvar _backNav = __webpack_require__(7);\n\t\n\tvar _backNav2 = _interopRequireDefault(_backNav);\n\t\n\tvar _forwardNav = __webpack_require__(8);\n\t\n\tvar _forwardNav2 = _interopRequireDefault(_forwardNav);\n\t\n\tvar _ItemBuilder = __webpack_require__(9);\n\t\n\tvar _ItemBuilder2 = _interopRequireDefault(_ItemBuilder);\n\t\n\tvar _ItemFactory = __webpack_require__(10);\n\t\n\tvar _ItemFactory2 = _interopRequireDefault(_ItemFactory);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar Gallery = function () {\n\t    function Gallery(itemStubs) {\n\t        var _this = this;\n\t\n\t        _classCallCheck(this, Gallery);\n\t\n\t        this._navigationStatus = null;\n\t        this._gallery = null;\n\t        this._galleryContentContainer = null;\n\t        this._itemTitle = null;\n\t        // this._content = content;\n\t        this._index = 0;\n\t        this._isFullscreen = false;\n\t        this._onKeyUp = this._onKeyUp.bind(this);\n\t        // this._images = [];\n\t        this._items = [];\n\t\n\t        window.addEventListener('resize', function (e) {\n\t            _this._resetItems();\n\t        });\n\t\n\t        this._build(itemStubs);\n\t    }\n\t\n\t    _createClass(Gallery, [{\n\t        key: \"next\",\n\t        value: function next() {\n\t            if (this._index < this._items.length - 1) {\n\t                this._index += 1;\n\t                this._onNavigation(this._items[this._index], this._items[this._index - 1]);\n\t            }\n\t        }\n\t    }, {\n\t        key: \"previous\",\n\t        value: function previous() {\n\t            if (this._index > 0) {\n\t                this._index -= 1;\n\t                this._onNavigation(this._items[this._index], this._items[this._index + 1]);\n\t            }\n\t        }\n\t    }, {\n\t        key: \"toggleFullscreen\",\n\t        value: function toggleFullscreen() {\n\t            this._gallery.classList.toggle(\"fullscreen\");\n\t            this._isFullscreen = !this._isFullscreen;\n\t            if (this._isFullscreen) {\n\t                document.body.addEventListener('keyup', this._onKeyUp);\n\t            } else {\n\t                document.body.removeEventListener('keyup', this._onKeyUp);\n\t            }\n\t\n\t            this._resetItems();\n\t        }\n\t    }, {\n\t        key: \"_build\",\n\t        value: function _build(itemStubs) {\n\t            var _this2 = this;\n\t\n\t            var gallery = document.createElement('div');\n\t            this._gallery = gallery;\n\t            gallery.className = \"gallery\";\n\t\n\t            //Container for the Content (Images/Videos)\n\t            var galleryContentContainer = document.createElement('div');\n\t            this._galleryContentContainer = galleryContentContainer;\n\t            galleryContentContainer.className = \"gallery-content\";\n\t            gallery.appendChild(galleryContentContainer);\n\t\n\t            var mc = new _hammerjs2.default.Manager(gallery);\n\t            var Swipe = new _hammerjs2.default.Swipe();\n\t            var Pan = new _hammerjs2.default.Pan();\n\t            mc.add(Swipe);\n\t            mc.add(Pan);\n\t            mc.on('panstart', function (e) {\n\t                console.log(e, \"start\");\n\t            });\n\t            mc.on('panleft', function (e) {\n\t                console.log(e, \"left\");\n\t                _this2.next();\n\t            });\n\t            mc.on('panright', function (e) {\n\t                console.log(e, \"right\");\n\t                _this2.previous();\n\t            });\n\t\n\t            //Add Content\n\t            for (var i in itemStubs) {\n\t                var item = _ItemFactory2.default.build(itemStubs[i]);\n\t                this._items.push(item);\n\t                galleryContentContainer.appendChild(_ItemBuilder2.default.build(item));\n\t            }\n\t\n\t            //Navigation Icons\n\t            var backNavIcon = document.createElement('img');\n\t            backNavIcon.className = \"back-nav-icon\";\n\t            backNavIcon.src = _backNav2.default;\n\t            gallery.appendChild(backNavIcon);\n\t\n\t            var mc1 = new _hammerjs2.default.Manager(backNavIcon);\n\t            var Tap1 = new _hammerjs2.default.Tap();\n\t            mc1.add(Tap1);\n\t            mc1.on('tap', function (e) {\n\t                _this2.previous();\n\t            });\n\t\n\t            var forwardNavIcon = document.createElement('img');\n\t            forwardNavIcon.className = \"forward-nav-icon\";\n\t            forwardNavIcon.src = _forwardNav2.default;\n\t            gallery.appendChild(forwardNavIcon);\n\t\n\t            var mc2 = new _hammerjs2.default.Manager(forwardNavIcon);\n\t            var Tap2 = new _hammerjs2.default.Tap();\n\t            mc2.add(Tap2);\n\t            mc2.on('tap', function (e) {\n\t                _this2.next();\n\t            });\n\t\n\t            //Status bar for status of _gallery navigation and icons for fullscreen, etc\n\t            var statusBar = document.createElement('div');\n\t            statusBar.className = \"status-bar\";\n\t            gallery.appendChild(statusBar);\n\t\n\t            //Navigation status\n\t            var navigationStatus = document.createElement('div');\n\t            navigationStatus.className = \"navigation-status\";\n\t            this._navigationStatus = navigationStatus;\n\t            statusBar.appendChild(navigationStatus);\n\t\n\t            //Full screen icon\n\t            var fullScreenIcon = document.createElement('img');\n\t            fullScreenIcon.className = \"fullscreen-icon\";\n\t            fullScreenIcon.src = _fullscreen2.default;\n\t            statusBar.appendChild(fullScreenIcon);\n\t\n\t            //Item Title\n\t            var itemTitle = document.createElement('span');\n\t            this._itemTitle = itemTitle;\n\t            statusBar.appendChild(itemTitle);\n\t\n\t            var mc3 = new _hammerjs2.default.Manager(fullScreenIcon);\n\t            var Tap3 = new _hammerjs2.default.Tap();\n\t            mc3.add(Tap3);\n\t            mc3.on(\"tap\", function (e) {\n\t                //Toggle FullScreen\n\t                _this2.toggleFullscreen();\n\t            });\n\t\n\t            this._onNavigation(this._items[this._index]);\n\t\n\t            return gallery;\n\t        }\n\t\n\t        //Sets all the _images to initial proportions, to be called when fullscreen toggled or size of container changes\n\t\n\t    }, {\n\t        key: \"_resetItems\",\n\t        value: function _resetItems() {\n\t            for (var i in this._items) {\n\t                this._items[i].reset();\n\t            }\n\t        }\n\t    }, {\n\t        key: \"_onNavigation\",\n\t        value: function _onNavigation(newItem, oldItem) {\n\t            if (oldItem) {\n\t                oldItem.onHidden();\n\t            }\n\t            newItem.onShown();\n\t\n\t            //Update Navigation Status Text to x/x\n\t            this._navigationStatus.innerHTML = this._index + 1 + \"/\" + this._items.length;\n\t            //Move Container to appropriate item\n\t            this._galleryContentContainer.style.left = this._index * 100 * -1 + \"%\";\n\t            //Show new items title in status bar\n\t            this._itemTitle.innerHTML = this._items[this._index].title || \"\";\n\t        }\n\t    }, {\n\t        key: \"_onKeyUp\",\n\t        value: function _onKeyUp(e) {\n\t            switch (e.which) {\n\t                case 37:\n\t                    //Left\n\t                    this.previous();\n\t                    break;\n\t                case 39:\n\t                    //Right\n\t                    this.next();\n\t                    break;\n\t                case 27:\n\t                    //Esp\n\t                    this.toggleFullscreen();\n\t                    break;\n\t            }\n\t        }\n\t    }, {\n\t        key: \"element\",\n\t        get: function get() {\n\t            return this._gallery;\n\t        }\n\t    }]);\n\t\n\t    return Gallery;\n\t}();\n\t\n\texports.default = Gallery;\n\t\n\t\n\twindow.Gallery = Gallery;\n\tmodule.exports = Gallery;\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_RESULT__;'use strict';\n\t\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\t\n\t/*! Hammer.JS - v2.0.7 - 2016-04-22\n\t * http://hammerjs.github.io/\n\t *\n\t * Copyright (c) 2016 Jorik Tangelder;\n\t * Licensed under the MIT license */\n\t(function (window, document, exportName, undefined) {\n\t    'use strict';\n\t\n\t    var VENDOR_PREFIXES = ['', 'webkit', 'Moz', 'MS', 'ms', 'o'];\n\t    var TEST_ELEMENT = document.createElement('div');\n\t\n\t    var TYPE_FUNCTION = 'function';\n\t\n\t    var round = Math.round;\n\t    var abs = Math.abs;\n\t    var now = Date.now;\n\t\n\t    /**\n\t     * set a timeout with a given scope\n\t     * @param {Function} fn\n\t     * @param {Number} timeout\n\t     * @param {Object} context\n\t     * @returns {number}\n\t     */\n\t    function setTimeoutContext(fn, timeout, context) {\n\t        return setTimeout(bindFn(fn, context), timeout);\n\t    }\n\t\n\t    /**\n\t     * if the argument is an array, we want to execute the fn on each entry\n\t     * if it aint an array we don't want to do a thing.\n\t     * this is used by all the methods that accept a single and array argument.\n\t     * @param {*|Array} arg\n\t     * @param {String} fn\n\t     * @param {Object} [context]\n\t     * @returns {Boolean}\n\t     */\n\t    function invokeArrayArg(arg, fn, context) {\n\t        if (Array.isArray(arg)) {\n\t            each(arg, context[fn], context);\n\t            return true;\n\t        }\n\t        return false;\n\t    }\n\t\n\t    /**\n\t     * walk objects and arrays\n\t     * @param {Object} obj\n\t     * @param {Function} iterator\n\t     * @param {Object} context\n\t     */\n\t    function each(obj, iterator, context) {\n\t        var i;\n\t\n\t        if (!obj) {\n\t            return;\n\t        }\n\t\n\t        if (obj.forEach) {\n\t            obj.forEach(iterator, context);\n\t        } else if (obj.length !== undefined) {\n\t            i = 0;\n\t            while (i < obj.length) {\n\t                iterator.call(context, obj[i], i, obj);\n\t                i++;\n\t            }\n\t        } else {\n\t            for (i in obj) {\n\t                obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj);\n\t            }\n\t        }\n\t    }\n\t\n\t    /**\n\t     * wrap a method with a deprecation warning and stack trace\n\t     * @param {Function} method\n\t     * @param {String} name\n\t     * @param {String} message\n\t     * @returns {Function} A new function wrapping the supplied method.\n\t     */\n\t    function deprecate(method, name, message) {\n\t        var deprecationMessage = 'DEPRECATED METHOD: ' + name + '\\n' + message + ' AT \\n';\n\t        return function () {\n\t            var e = new Error('get-stack-trace');\n\t            var stack = e && e.stack ? e.stack.replace(/^[^\\(]+?[\\n$]/gm, '').replace(/^\\s+at\\s+/gm, '').replace(/^Object.<anonymous>\\s*\\(/gm, '{anonymous}()@') : 'Unknown Stack Trace';\n\t\n\t            var log = window.console && (window.console.warn || window.console.log);\n\t            if (log) {\n\t                log.call(window.console, deprecationMessage, stack);\n\t            }\n\t            return method.apply(this, arguments);\n\t        };\n\t    }\n\t\n\t    /**\n\t     * extend object.\n\t     * means that properties in dest will be overwritten by the ones in src.\n\t     * @param {Object} target\n\t     * @param {...Object} objects_to_assign\n\t     * @returns {Object} target\n\t     */\n\t    var assign;\n\t    if (typeof Object.assign !== 'function') {\n\t        assign = function assign(target) {\n\t            if (target === undefined || target === null) {\n\t                throw new TypeError('Cannot convert undefined or null to object');\n\t            }\n\t\n\t            var output = Object(target);\n\t            for (var index = 1; index < arguments.length; index++) {\n\t                var source = arguments[index];\n\t                if (source !== undefined && source !== null) {\n\t                    for (var nextKey in source) {\n\t                        if (source.hasOwnProperty(nextKey)) {\n\t                            output[nextKey] = source[nextKey];\n\t                        }\n\t                    }\n\t                }\n\t            }\n\t            return output;\n\t        };\n\t    } else {\n\t        assign = Object.assign;\n\t    }\n\t\n\t    /**\n\t     * extend object.\n\t     * means that properties in dest will be overwritten by the ones in src.\n\t     * @param {Object} dest\n\t     * @param {Object} src\n\t     * @param {Boolean} [merge=false]\n\t     * @returns {Object} dest\n\t     */\n\t    var extend = deprecate(function extend(dest, src, merge) {\n\t        var keys = Object.keys(src);\n\t        var i = 0;\n\t        while (i < keys.length) {\n\t            if (!merge || merge && dest[keys[i]] === undefined) {\n\t                dest[keys[i]] = src[keys[i]];\n\t            }\n\t            i++;\n\t        }\n\t        return dest;\n\t    }, 'extend', 'Use `assign`.');\n\t\n\t    /**\n\t     * merge the values from src in the dest.\n\t     * means that properties that exist in dest will not be overwritten by src\n\t     * @param {Object} dest\n\t     * @param {Object} src\n\t     * @returns {Object} dest\n\t     */\n\t    var merge = deprecate(function merge(dest, src) {\n\t        return extend(dest, src, true);\n\t    }, 'merge', 'Use `assign`.');\n\t\n\t    /**\n\t     * simple class inheritance\n\t     * @param {Function} child\n\t     * @param {Function} base\n\t     * @param {Object} [properties]\n\t     */\n\t    function inherit(child, base, properties) {\n\t        var baseP = base.prototype,\n\t            childP;\n\t\n\t        childP = child.prototype = Object.create(baseP);\n\t        childP.constructor = child;\n\t        childP._super = baseP;\n\t\n\t        if (properties) {\n\t            assign(childP, properties);\n\t        }\n\t    }\n\t\n\t    /**\n\t     * simple function bind\n\t     * @param {Function} fn\n\t     * @param {Object} context\n\t     * @returns {Function}\n\t     */\n\t    function bindFn(fn, context) {\n\t        return function boundFn() {\n\t            return fn.apply(context, arguments);\n\t        };\n\t    }\n\t\n\t    /**\n\t     * let a boolean value also be a function that must return a boolean\n\t     * this first item in args will be used as the context\n\t     * @param {Boolean|Function} val\n\t     * @param {Array} [args]\n\t     * @returns {Boolean}\n\t     */\n\t    function boolOrFn(val, args) {\n\t        if ((typeof val === 'undefined' ? 'undefined' : _typeof(val)) == TYPE_FUNCTION) {\n\t            return val.apply(args ? args[0] || undefined : undefined, args);\n\t        }\n\t        return val;\n\t    }\n\t\n\t    /**\n\t     * use the val2 when val1 is undefined\n\t     * @param {*} val1\n\t     * @param {*} val2\n\t     * @returns {*}\n\t     */\n\t    function ifUndefined(val1, val2) {\n\t        return val1 === undefined ? val2 : val1;\n\t    }\n\t\n\t    /**\n\t     * addEventListener with multiple events at once\n\t     * @param {EventTarget} target\n\t     * @param {String} types\n\t     * @param {Function} handler\n\t     */\n\t    function addEventListeners(target, types, handler) {\n\t        each(splitStr(types), function (type) {\n\t            target.addEventListener(type, handler, false);\n\t        });\n\t    }\n\t\n\t    /**\n\t     * removeEventListener with multiple events at once\n\t     * @param {EventTarget} target\n\t     * @param {String} types\n\t     * @param {Function} handler\n\t     */\n\t    function removeEventListeners(target, types, handler) {\n\t        each(splitStr(types), function (type) {\n\t            target.removeEventListener(type, handler, false);\n\t        });\n\t    }\n\t\n\t    /**\n\t     * find if a node is in the given parent\n\t     * @method hasParent\n\t     * @param {HTMLElement} node\n\t     * @param {HTMLElement} parent\n\t     * @return {Boolean} found\n\t     */\n\t    function hasParent(node, parent) {\n\t        while (node) {\n\t            if (node == parent) {\n\t                return true;\n\t            }\n\t            node = node.parentNode;\n\t        }\n\t        return false;\n\t    }\n\t\n\t    /**\n\t     * small indexOf wrapper\n\t     * @param {String} str\n\t     * @param {String} find\n\t     * @returns {Boolean} found\n\t     */\n\t    function inStr(str, find) {\n\t        return str.indexOf(find) > -1;\n\t    }\n\t\n\t    /**\n\t     * split string on whitespace\n\t     * @param {String} str\n\t     * @returns {Array} words\n\t     */\n\t    function splitStr(str) {\n\t        return str.trim().split(/\\s+/g);\n\t    }\n\t\n\t    /**\n\t     * find if a array contains the object using indexOf or a simple polyFill\n\t     * @param {Array} src\n\t     * @param {String} find\n\t     * @param {String} [findByKey]\n\t     * @return {Boolean|Number} false when not found, or the index\n\t     */\n\t    function inArray(src, find, findByKey) {\n\t        if (src.indexOf && !findByKey) {\n\t            return src.indexOf(find);\n\t        } else {\n\t            var i = 0;\n\t            while (i < src.length) {\n\t                if (findByKey && src[i][findByKey] == find || !findByKey && src[i] === find) {\n\t                    return i;\n\t                }\n\t                i++;\n\t            }\n\t            return -1;\n\t        }\n\t    }\n\t\n\t    /**\n\t     * convert array-like objects to real arrays\n\t     * @param {Object} obj\n\t     * @returns {Array}\n\t     */\n\t    function toArray(obj) {\n\t        return Array.prototype.slice.call(obj, 0);\n\t    }\n\t\n\t    /**\n\t     * unique array with objects based on a key (like 'id') or just by the array's value\n\t     * @param {Array} src [{id:1},{id:2},{id:1}]\n\t     * @param {String} [key]\n\t     * @param {Boolean} [sort=False]\n\t     * @returns {Array} [{id:1},{id:2}]\n\t     */\n\t    function uniqueArray(src, key, sort) {\n\t        var results = [];\n\t        var values = [];\n\t        var i = 0;\n\t\n\t        while (i < src.length) {\n\t            var val = key ? src[i][key] : src[i];\n\t            if (inArray(values, val) < 0) {\n\t                results.push(src[i]);\n\t            }\n\t            values[i] = val;\n\t            i++;\n\t        }\n\t\n\t        if (sort) {\n\t            if (!key) {\n\t                results = results.sort();\n\t            } else {\n\t                results = results.sort(function sortUniqueArray(a, b) {\n\t                    return a[key] > b[key];\n\t                });\n\t            }\n\t        }\n\t\n\t        return results;\n\t    }\n\t\n\t    /**\n\t     * get the prefixed property\n\t     * @param {Object} obj\n\t     * @param {String} property\n\t     * @returns {String|Undefined} prefixed\n\t     */\n\t    function prefixed(obj, property) {\n\t        var prefix, prop;\n\t        var camelProp = property[0].toUpperCase() + property.slice(1);\n\t\n\t        var i = 0;\n\t        while (i < VENDOR_PREFIXES.length) {\n\t            prefix = VENDOR_PREFIXES[i];\n\t            prop = prefix ? prefix + camelProp : property;\n\t\n\t            if (prop in obj) {\n\t                return prop;\n\t            }\n\t            i++;\n\t        }\n\t        return undefined;\n\t    }\n\t\n\t    /**\n\t     * get a unique id\n\t     * @returns {number} uniqueId\n\t     */\n\t    var _uniqueId = 1;\n\t    function uniqueId() {\n\t        return _uniqueId++;\n\t    }\n\t\n\t    /**\n\t     * get the window object of an element\n\t     * @param {HTMLElement} element\n\t     * @returns {DocumentView|Window}\n\t     */\n\t    function getWindowForElement(element) {\n\t        var doc = element.ownerDocument || element;\n\t        return doc.defaultView || doc.parentWindow || window;\n\t    }\n\t\n\t    var MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;\n\t\n\t    var SUPPORT_TOUCH = 'ontouchstart' in window;\n\t    var SUPPORT_POINTER_EVENTS = prefixed(window, 'PointerEvent') !== undefined;\n\t    var SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH && MOBILE_REGEX.test(navigator.userAgent);\n\t\n\t    var INPUT_TYPE_TOUCH = 'touch';\n\t    var INPUT_TYPE_PEN = 'pen';\n\t    var INPUT_TYPE_MOUSE = 'mouse';\n\t    var INPUT_TYPE_KINECT = 'kinect';\n\t\n\t    var COMPUTE_INTERVAL = 25;\n\t\n\t    var INPUT_START = 1;\n\t    var INPUT_MOVE = 2;\n\t    var INPUT_END = 4;\n\t    var INPUT_CANCEL = 8;\n\t\n\t    var DIRECTION_NONE = 1;\n\t    var DIRECTION_LEFT = 2;\n\t    var DIRECTION_RIGHT = 4;\n\t    var DIRECTION_UP = 8;\n\t    var DIRECTION_DOWN = 16;\n\t\n\t    var DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT;\n\t    var DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN;\n\t    var DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;\n\t\n\t    var PROPS_XY = ['x', 'y'];\n\t    var PROPS_CLIENT_XY = ['clientX', 'clientY'];\n\t\n\t    /**\n\t     * create new input type manager\n\t     * @param {Manager} manager\n\t     * @param {Function} callback\n\t     * @returns {Input}\n\t     * @constructor\n\t     */\n\t    function Input(manager, callback) {\n\t        var self = this;\n\t        this.manager = manager;\n\t        this.callback = callback;\n\t        this.element = manager.element;\n\t        this.target = manager.options.inputTarget;\n\t\n\t        // smaller wrapper around the handler, for the scope and the enabled state of the manager,\n\t        // so when disabled the input events are completely bypassed.\n\t        this.domHandler = function (ev) {\n\t            if (boolOrFn(manager.options.enable, [manager])) {\n\t                self.handler(ev);\n\t            }\n\t        };\n\t\n\t        this.init();\n\t    }\n\t\n\t    Input.prototype = {\n\t        /**\n\t         * should handle the inputEvent data and trigger the callback\n\t         * @virtual\n\t         */\n\t        handler: function handler() {},\n\t\n\t        /**\n\t         * bind the events\n\t         */\n\t        init: function init() {\n\t            this.evEl && addEventListeners(this.element, this.evEl, this.domHandler);\n\t            this.evTarget && addEventListeners(this.target, this.evTarget, this.domHandler);\n\t            this.evWin && addEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);\n\t        },\n\t\n\t        /**\n\t         * unbind the events\n\t         */\n\t        destroy: function destroy() {\n\t            this.evEl && removeEventListeners(this.element, this.evEl, this.domHandler);\n\t            this.evTarget && removeEventListeners(this.target, this.evTarget, this.domHandler);\n\t            this.evWin && removeEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);\n\t        }\n\t    };\n\t\n\t    /**\n\t     * create new input type manager\n\t     * called by the Manager constructor\n\t     * @param {Hammer} manager\n\t     * @returns {Input}\n\t     */\n\t    function createInputInstance(manager) {\n\t        var Type;\n\t        var inputClass = manager.options.inputClass;\n\t\n\t        if (inputClass) {\n\t            Type = inputClass;\n\t        } else if (SUPPORT_POINTER_EVENTS) {\n\t            Type = PointerEventInput;\n\t        } else if (SUPPORT_ONLY_TOUCH) {\n\t            Type = TouchInput;\n\t        } else if (!SUPPORT_TOUCH) {\n\t            Type = MouseInput;\n\t        } else {\n\t            Type = TouchMouseInput;\n\t        }\n\t        return new Type(manager, inputHandler);\n\t    }\n\t\n\t    /**\n\t     * handle input events\n\t     * @param {Manager} manager\n\t     * @param {String} eventType\n\t     * @param {Object} input\n\t     */\n\t    function inputHandler(manager, eventType, input) {\n\t        var pointersLen = input.pointers.length;\n\t        var changedPointersLen = input.changedPointers.length;\n\t        var isFirst = eventType & INPUT_START && pointersLen - changedPointersLen === 0;\n\t        var isFinal = eventType & (INPUT_END | INPUT_CANCEL) && pointersLen - changedPointersLen === 0;\n\t\n\t        input.isFirst = !!isFirst;\n\t        input.isFinal = !!isFinal;\n\t\n\t        if (isFirst) {\n\t            manager.session = {};\n\t        }\n\t\n\t        // source event is the normalized value of the domEvents\n\t        // like 'touchstart, mouseup, pointerdown'\n\t        input.eventType = eventType;\n\t\n\t        // compute scale, rotation etc\n\t        computeInputData(manager, input);\n\t\n\t        // emit secret event\n\t        manager.emit('hammer.input', input);\n\t\n\t        manager.recognize(input);\n\t        manager.session.prevInput = input;\n\t    }\n\t\n\t    /**\n\t     * extend the data with some usable properties like scale, rotate, velocity etc\n\t     * @param {Object} manager\n\t     * @param {Object} input\n\t     */\n\t    function computeInputData(manager, input) {\n\t        var session = manager.session;\n\t        var pointers = input.pointers;\n\t        var pointersLength = pointers.length;\n\t\n\t        // store the first input to calculate the distance and direction\n\t        if (!session.firstInput) {\n\t            session.firstInput = simpleCloneInputData(input);\n\t        }\n\t\n\t        // to compute scale and rotation we need to store the multiple touches\n\t        if (pointersLength > 1 && !session.firstMultiple) {\n\t            session.firstMultiple = simpleCloneInputData(input);\n\t        } else if (pointersLength === 1) {\n\t            session.firstMultiple = false;\n\t        }\n\t\n\t        var firstInput = session.firstInput;\n\t        var firstMultiple = session.firstMultiple;\n\t        var offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;\n\t\n\t        var center = input.center = getCenter(pointers);\n\t        input.timeStamp = now();\n\t        input.deltaTime = input.timeStamp - firstInput.timeStamp;\n\t\n\t        input.angle = getAngle(offsetCenter, center);\n\t        input.distance = getDistance(offsetCenter, center);\n\t\n\t        computeDeltaXY(session, input);\n\t        input.offsetDirection = getDirection(input.deltaX, input.deltaY);\n\t\n\t        var overallVelocity = getVelocity(input.deltaTime, input.deltaX, input.deltaY);\n\t        input.overallVelocityX = overallVelocity.x;\n\t        input.overallVelocityY = overallVelocity.y;\n\t        input.overallVelocity = abs(overallVelocity.x) > abs(overallVelocity.y) ? overallVelocity.x : overallVelocity.y;\n\t\n\t        input.scale = firstMultiple ? getScale(firstMultiple.pointers, pointers) : 1;\n\t        input.rotation = firstMultiple ? getRotation(firstMultiple.pointers, pointers) : 0;\n\t\n\t        input.maxPointers = !session.prevInput ? input.pointers.length : input.pointers.length > session.prevInput.maxPointers ? input.pointers.length : session.prevInput.maxPointers;\n\t\n\t        computeIntervalInputData(session, input);\n\t\n\t        // find the correct target\n\t        var target = manager.element;\n\t        if (hasParent(input.srcEvent.target, target)) {\n\t            target = input.srcEvent.target;\n\t        }\n\t        input.target = target;\n\t    }\n\t\n\t    function computeDeltaXY(session, input) {\n\t        var center = input.center;\n\t        var offset = session.offsetDelta || {};\n\t        var prevDelta = session.prevDelta || {};\n\t        var prevInput = session.prevInput || {};\n\t\n\t        if (input.eventType === INPUT_START || prevInput.eventType === INPUT_END) {\n\t            prevDelta = session.prevDelta = {\n\t                x: prevInput.deltaX || 0,\n\t                y: prevInput.deltaY || 0\n\t            };\n\t\n\t            offset = session.offsetDelta = {\n\t                x: center.x,\n\t                y: center.y\n\t            };\n\t        }\n\t\n\t        input.deltaX = prevDelta.x + (center.x - offset.x);\n\t        input.deltaY = prevDelta.y + (center.y - offset.y);\n\t    }\n\t\n\t    /**\n\t     * velocity is calculated every x ms\n\t     * @param {Object} session\n\t     * @param {Object} input\n\t     */\n\t    function computeIntervalInputData(session, input) {\n\t        var last = session.lastInterval || input,\n\t            deltaTime = input.timeStamp - last.timeStamp,\n\t            velocity,\n\t            velocityX,\n\t            velocityY,\n\t            direction;\n\t\n\t        if (input.eventType != INPUT_CANCEL && (deltaTime > COMPUTE_INTERVAL || last.velocity === undefined)) {\n\t            var deltaX = input.deltaX - last.deltaX;\n\t            var deltaY = input.deltaY - last.deltaY;\n\t\n\t            var v = getVelocity(deltaTime, deltaX, deltaY);\n\t            velocityX = v.x;\n\t            velocityY = v.y;\n\t            velocity = abs(v.x) > abs(v.y) ? v.x : v.y;\n\t            direction = getDirection(deltaX, deltaY);\n\t\n\t            session.lastInterval = input;\n\t        } else {\n\t            // use latest velocity info if it doesn't overtake a minimum period\n\t            velocity = last.velocity;\n\t            velocityX = last.velocityX;\n\t            velocityY = last.velocityY;\n\t            direction = last.direction;\n\t        }\n\t\n\t        input.velocity = velocity;\n\t        input.velocityX = velocityX;\n\t        input.velocityY = velocityY;\n\t        input.direction = direction;\n\t    }\n\t\n\t    /**\n\t     * create a simple clone from the input used for storage of firstInput and firstMultiple\n\t     * @param {Object} input\n\t     * @returns {Object} clonedInputData\n\t     */\n\t    function simpleCloneInputData(input) {\n\t        // make a simple copy of the pointers because we will get a reference if we don't\n\t        // we only need clientXY for the calculations\n\t        var pointers = [];\n\t        var i = 0;\n\t        while (i < input.pointers.length) {\n\t            pointers[i] = {\n\t                clientX: round(input.pointers[i].clientX),\n\t                clientY: round(input.pointers[i].clientY)\n\t            };\n\t            i++;\n\t        }\n\t\n\t        return {\n\t            timeStamp: now(),\n\t            pointers: pointers,\n\t            center: getCenter(pointers),\n\t            deltaX: input.deltaX,\n\t            deltaY: input.deltaY\n\t        };\n\t    }\n\t\n\t    /**\n\t     * get the center of all the pointers\n\t     * @param {Array} pointers\n\t     * @return {Object} center contains `x` and `y` properties\n\t     */\n\t    function getCenter(pointers) {\n\t        var pointersLength = pointers.length;\n\t\n\t        // no need to loop when only one touch\n\t        if (pointersLength === 1) {\n\t            return {\n\t                x: round(pointers[0].clientX),\n\t                y: round(pointers[0].clientY)\n\t            };\n\t        }\n\t\n\t        var x = 0,\n\t            y = 0,\n\t            i = 0;\n\t        while (i < pointersLength) {\n\t            x += pointers[i].clientX;\n\t            y += pointers[i].clientY;\n\t            i++;\n\t        }\n\t\n\t        return {\n\t            x: round(x / pointersLength),\n\t            y: round(y / pointersLength)\n\t        };\n\t    }\n\t\n\t    /**\n\t     * calculate the velocity between two points. unit is in px per ms.\n\t     * @param {Number} deltaTime\n\t     * @param {Number} x\n\t     * @param {Number} y\n\t     * @return {Object} velocity `x` and `y`\n\t     */\n\t    function getVelocity(deltaTime, x, y) {\n\t        return {\n\t            x: x / deltaTime || 0,\n\t            y: y / deltaTime || 0\n\t        };\n\t    }\n\t\n\t    /**\n\t     * get the direction between two points\n\t     * @param {Number} x\n\t     * @param {Number} y\n\t     * @return {Number} direction\n\t     */\n\t    function getDirection(x, y) {\n\t        if (x === y) {\n\t            return DIRECTION_NONE;\n\t        }\n\t\n\t        if (abs(x) >= abs(y)) {\n\t            return x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;\n\t        }\n\t        return y < 0 ? DIRECTION_UP : DIRECTION_DOWN;\n\t    }\n\t\n\t    /**\n\t     * calculate the absolute distance between two points\n\t     * @param {Object} p1 {x, y}\n\t     * @param {Object} p2 {x, y}\n\t     * @param {Array} [props] containing x and y keys\n\t     * @return {Number} distance\n\t     */\n\t    function getDistance(p1, p2, props) {\n\t        if (!props) {\n\t            props = PROPS_XY;\n\t        }\n\t        var x = p2[props[0]] - p1[props[0]],\n\t            y = p2[props[1]] - p1[props[1]];\n\t\n\t        return Math.sqrt(x * x + y * y);\n\t    }\n\t\n\t    /**\n\t     * calculate the angle between two coordinates\n\t     * @param {Object} p1\n\t     * @param {Object} p2\n\t     * @param {Array} [props] containing x and y keys\n\t     * @return {Number} angle\n\t     */\n\t    function getAngle(p1, p2, props) {\n\t        if (!props) {\n\t            props = PROPS_XY;\n\t        }\n\t        var x = p2[props[0]] - p1[props[0]],\n\t            y = p2[props[1]] - p1[props[1]];\n\t        return Math.atan2(y, x) * 180 / Math.PI;\n\t    }\n\t\n\t    /**\n\t     * calculate the rotation degrees between two pointersets\n\t     * @param {Array} start array of pointers\n\t     * @param {Array} end array of pointers\n\t     * @return {Number} rotation\n\t     */\n\t    function getRotation(start, end) {\n\t        return getAngle(end[1], end[0], PROPS_CLIENT_XY) + getAngle(start[1], start[0], PROPS_CLIENT_XY);\n\t    }\n\t\n\t    /**\n\t     * calculate the scale factor between two pointersets\n\t     * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out\n\t     * @param {Array} start array of pointers\n\t     * @param {Array} end array of pointers\n\t     * @return {Number} scale\n\t     */\n\t    function getScale(start, end) {\n\t        return getDistance(end[0], end[1], PROPS_CLIENT_XY) / getDistance(start[0], start[1], PROPS_CLIENT_XY);\n\t    }\n\t\n\t    var MOUSE_INPUT_MAP = {\n\t        mousedown: INPUT_START,\n\t        mousemove: INPUT_MOVE,\n\t        mouseup: INPUT_END\n\t    };\n\t\n\t    var MOUSE_ELEMENT_EVENTS = 'mousedown';\n\t    var MOUSE_WINDOW_EVENTS = 'mousemove mouseup';\n\t\n\t    /**\n\t     * Mouse events input\n\t     * @constructor\n\t     * @extends Input\n\t     */\n\t    function MouseInput() {\n\t        this.evEl = MOUSE_ELEMENT_EVENTS;\n\t        this.evWin = MOUSE_WINDOW_EVENTS;\n\t\n\t        this.pressed = false; // mousedown state\n\t\n\t        Input.apply(this, arguments);\n\t    }\n\t\n\t    inherit(MouseInput, Input, {\n\t        /**\n\t         * handle mouse events\n\t         * @param {Object} ev\n\t         */\n\t        handler: function MEhandler(ev) {\n\t            var eventType = MOUSE_INPUT_MAP[ev.type];\n\t\n\t            // on start we want to have the left mouse button down\n\t            if (eventType & INPUT_START && ev.button === 0) {\n\t                this.pressed = true;\n\t            }\n\t\n\t            if (eventType & INPUT_MOVE && ev.which !== 1) {\n\t                eventType = INPUT_END;\n\t            }\n\t\n\t            // mouse must be down\n\t            if (!this.pressed) {\n\t                return;\n\t            }\n\t\n\t            if (eventType & INPUT_END) {\n\t                this.pressed = false;\n\t            }\n\t\n\t            this.callback(this.manager, eventType, {\n\t                pointers: [ev],\n\t                changedPointers: [ev],\n\t                pointerType: INPUT_TYPE_MOUSE,\n\t                srcEvent: ev\n\t            });\n\t        }\n\t    });\n\t\n\t    var POINTER_INPUT_MAP = {\n\t        pointerdown: INPUT_START,\n\t        pointermove: INPUT_MOVE,\n\t        pointerup: INPUT_END,\n\t        pointercancel: INPUT_CANCEL,\n\t        pointerout: INPUT_CANCEL\n\t    };\n\t\n\t    // in IE10 the pointer types is defined as an enum\n\t    var IE10_POINTER_TYPE_ENUM = {\n\t        2: INPUT_TYPE_TOUCH,\n\t        3: INPUT_TYPE_PEN,\n\t        4: INPUT_TYPE_MOUSE,\n\t        5: INPUT_TYPE_KINECT // see https://twitter.com/jacobrossi/status/480596438489890816\n\t    };\n\t\n\t    var POINTER_ELEMENT_EVENTS = 'pointerdown';\n\t    var POINTER_WINDOW_EVENTS = 'pointermove pointerup pointercancel';\n\t\n\t    // IE10 has prefixed support, and case-sensitive\n\t    if (window.MSPointerEvent && !window.PointerEvent) {\n\t        POINTER_ELEMENT_EVENTS = 'MSPointerDown';\n\t        POINTER_WINDOW_EVENTS = 'MSPointerMove MSPointerUp MSPointerCancel';\n\t    }\n\t\n\t    /**\n\t     * Pointer events input\n\t     * @constructor\n\t     * @extends Input\n\t     */\n\t    function PointerEventInput() {\n\t        this.evEl = POINTER_ELEMENT_EVENTS;\n\t        this.evWin = POINTER_WINDOW_EVENTS;\n\t\n\t        Input.apply(this, arguments);\n\t\n\t        this.store = this.manager.session.pointerEvents = [];\n\t    }\n\t\n\t    inherit(PointerEventInput, Input, {\n\t        /**\n\t         * handle mouse events\n\t         * @param {Object} ev\n\t         */\n\t        handler: function PEhandler(ev) {\n\t            var store = this.store;\n\t            var removePointer = false;\n\t\n\t            var eventTypeNormalized = ev.type.toLowerCase().replace('ms', '');\n\t            var eventType = POINTER_INPUT_MAP[eventTypeNormalized];\n\t            var pointerType = IE10_POINTER_TYPE_ENUM[ev.pointerType] || ev.pointerType;\n\t\n\t            var isTouch = pointerType == INPUT_TYPE_TOUCH;\n\t\n\t            // get index of the event in the store\n\t            var storeIndex = inArray(store, ev.pointerId, 'pointerId');\n\t\n\t            // start and mouse must be down\n\t            if (eventType & INPUT_START && (ev.button === 0 || isTouch)) {\n\t                if (storeIndex < 0) {\n\t                    store.push(ev);\n\t                    storeIndex = store.length - 1;\n\t                }\n\t            } else if (eventType & (INPUT_END | INPUT_CANCEL)) {\n\t                removePointer = true;\n\t            }\n\t\n\t            // it not found, so the pointer hasn't been down (so it's probably a hover)\n\t            if (storeIndex < 0) {\n\t                return;\n\t            }\n\t\n\t            // update the event in the store\n\t            store[storeIndex] = ev;\n\t\n\t            this.callback(this.manager, eventType, {\n\t                pointers: store,\n\t                changedPointers: [ev],\n\t                pointerType: pointerType,\n\t                srcEvent: ev\n\t            });\n\t\n\t            if (removePointer) {\n\t                // remove from the store\n\t                store.splice(storeIndex, 1);\n\t            }\n\t        }\n\t    });\n\t\n\t    var SINGLE_TOUCH_INPUT_MAP = {\n\t        touchstart: INPUT_START,\n\t        touchmove: INPUT_MOVE,\n\t        touchend: INPUT_END,\n\t        touchcancel: INPUT_CANCEL\n\t    };\n\t\n\t    var SINGLE_TOUCH_TARGET_EVENTS = 'touchstart';\n\t    var SINGLE_TOUCH_WINDOW_EVENTS = 'touchstart touchmove touchend touchcancel';\n\t\n\t    /**\n\t     * Touch events input\n\t     * @constructor\n\t     * @extends Input\n\t     */\n\t    function SingleTouchInput() {\n\t        this.evTarget = SINGLE_TOUCH_TARGET_EVENTS;\n\t        this.evWin = SINGLE_TOUCH_WINDOW_EVENTS;\n\t        this.started = false;\n\t\n\t        Input.apply(this, arguments);\n\t    }\n\t\n\t    inherit(SingleTouchInput, Input, {\n\t        handler: function TEhandler(ev) {\n\t            var type = SINGLE_TOUCH_INPUT_MAP[ev.type];\n\t\n\t            // should we handle the touch events?\n\t            if (type === INPUT_START) {\n\t                this.started = true;\n\t            }\n\t\n\t            if (!this.started) {\n\t                return;\n\t            }\n\t\n\t            var touches = normalizeSingleTouches.call(this, ev, type);\n\t\n\t            // when done, reset the started state\n\t            if (type & (INPUT_END | INPUT_CANCEL) && touches[0].length - touches[1].length === 0) {\n\t                this.started = false;\n\t            }\n\t\n\t            this.callback(this.manager, type, {\n\t                pointers: touches[0],\n\t                changedPointers: touches[1],\n\t                pointerType: INPUT_TYPE_TOUCH,\n\t                srcEvent: ev\n\t            });\n\t        }\n\t    });\n\t\n\t    /**\n\t     * @this {TouchInput}\n\t     * @param {Object} ev\n\t     * @param {Number} type flag\n\t     * @returns {undefined|Array} [all, changed]\n\t     */\n\t    function normalizeSingleTouches(ev, type) {\n\t        var all = toArray(ev.touches);\n\t        var changed = toArray(ev.changedTouches);\n\t\n\t        if (type & (INPUT_END | INPUT_CANCEL)) {\n\t            all = uniqueArray(all.concat(changed), 'identifier', true);\n\t        }\n\t\n\t        return [all, changed];\n\t    }\n\t\n\t    var TOUCH_INPUT_MAP = {\n\t        touchstart: INPUT_START,\n\t        touchmove: INPUT_MOVE,\n\t        touchend: INPUT_END,\n\t        touchcancel: INPUT_CANCEL\n\t    };\n\t\n\t    var TOUCH_TARGET_EVENTS = 'touchstart touchmove touchend touchcancel';\n\t\n\t    /**\n\t     * Multi-user touch events input\n\t     * @constructor\n\t     * @extends Input\n\t     */\n\t    function TouchInput() {\n\t        this.evTarget = TOUCH_TARGET_EVENTS;\n\t        this.targetIds = {};\n\t\n\t        Input.apply(this, arguments);\n\t    }\n\t\n\t    inherit(TouchInput, Input, {\n\t        handler: function MTEhandler(ev) {\n\t            var type = TOUCH_INPUT_MAP[ev.type];\n\t            var touches = getTouches.call(this, ev, type);\n\t            if (!touches) {\n\t                return;\n\t            }\n\t\n\t            this.callback(this.manager, type, {\n\t                pointers: touches[0],\n\t                changedPointers: touches[1],\n\t                pointerType: INPUT_TYPE_TOUCH,\n\t                srcEvent: ev\n\t            });\n\t        }\n\t    });\n\t\n\t    /**\n\t     * @this {TouchInput}\n\t     * @param {Object} ev\n\t     * @param {Number} type flag\n\t     * @returns {undefined|Array} [all, changed]\n\t     */\n\t    function getTouches(ev, type) {\n\t        var allTouches = toArray(ev.touches);\n\t        var targetIds = this.targetIds;\n\t\n\t        // when there is only one touch, the process can be simplified\n\t        if (type & (INPUT_START | INPUT_MOVE) && allTouches.length === 1) {\n\t            targetIds[allTouches[0].identifier] = true;\n\t            return [allTouches, allTouches];\n\t        }\n\t\n\t        var i,\n\t            targetTouches,\n\t            changedTouches = toArray(ev.changedTouches),\n\t            changedTargetTouches = [],\n\t            target = this.target;\n\t\n\t        // get target touches from touches\n\t        targetTouches = allTouches.filter(function (touch) {\n\t            return hasParent(touch.target, target);\n\t        });\n\t\n\t        // collect touches\n\t        if (type === INPUT_START) {\n\t            i = 0;\n\t            while (i < targetTouches.length) {\n\t                targetIds[targetTouches[i].identifier] = true;\n\t                i++;\n\t            }\n\t        }\n\t\n\t        // filter changed touches to only contain touches that exist in the collected target ids\n\t        i = 0;\n\t        while (i < changedTouches.length) {\n\t            if (targetIds[changedTouches[i].identifier]) {\n\t                changedTargetTouches.push(changedTouches[i]);\n\t            }\n\t\n\t            // cleanup removed touches\n\t            if (type & (INPUT_END | INPUT_CANCEL)) {\n\t                delete targetIds[changedTouches[i].identifier];\n\t            }\n\t            i++;\n\t        }\n\t\n\t        if (!changedTargetTouches.length) {\n\t            return;\n\t        }\n\t\n\t        return [\n\t        // merge targetTouches with changedTargetTouches so it contains ALL touches, including 'end' and 'cancel'\n\t        uniqueArray(targetTouches.concat(changedTargetTouches), 'identifier', true), changedTargetTouches];\n\t    }\n\t\n\t    /**\n\t     * Combined touch and mouse input\n\t     *\n\t     * Touch has a higher priority then mouse, and while touching no mouse events are allowed.\n\t     * This because touch devices also emit mouse events while doing a touch.\n\t     *\n\t     * @constructor\n\t     * @extends Input\n\t     */\n\t\n\t    var DEDUP_TIMEOUT = 2500;\n\t    var DEDUP_DISTANCE = 25;\n\t\n\t    function TouchMouseInput() {\n\t        Input.apply(this, arguments);\n\t\n\t        var handler = bindFn(this.handler, this);\n\t        this.touch = new TouchInput(this.manager, handler);\n\t        this.mouse = new MouseInput(this.manager, handler);\n\t\n\t        this.primaryTouch = null;\n\t        this.lastTouches = [];\n\t    }\n\t\n\t    inherit(TouchMouseInput, Input, {\n\t        /**\n\t         * handle mouse and touch events\n\t         * @param {Hammer} manager\n\t         * @param {String} inputEvent\n\t         * @param {Object} inputData\n\t         */\n\t        handler: function TMEhandler(manager, inputEvent, inputData) {\n\t            var isTouch = inputData.pointerType == INPUT_TYPE_TOUCH,\n\t                isMouse = inputData.pointerType == INPUT_TYPE_MOUSE;\n\t\n\t            if (isMouse && inputData.sourceCapabilities && inputData.sourceCapabilities.firesTouchEvents) {\n\t                return;\n\t            }\n\t\n\t            // when we're in a touch event, record touches to  de-dupe synthetic mouse event\n\t            if (isTouch) {\n\t                recordTouches.call(this, inputEvent, inputData);\n\t            } else if (isMouse && isSyntheticEvent.call(this, inputData)) {\n\t                return;\n\t            }\n\t\n\t            this.callback(manager, inputEvent, inputData);\n\t        },\n\t\n\t        /**\n\t         * remove the event listeners\n\t         */\n\t        destroy: function destroy() {\n\t            this.touch.destroy();\n\t            this.mouse.destroy();\n\t        }\n\t    });\n\t\n\t    function recordTouches(eventType, eventData) {\n\t        if (eventType & INPUT_START) {\n\t            this.primaryTouch = eventData.changedPointers[0].identifier;\n\t            setLastTouch.call(this, eventData);\n\t        } else if (eventType & (INPUT_END | INPUT_CANCEL)) {\n\t            setLastTouch.call(this, eventData);\n\t        }\n\t    }\n\t\n\t    function setLastTouch(eventData) {\n\t        var touch = eventData.changedPointers[0];\n\t\n\t        if (touch.identifier === this.primaryTouch) {\n\t            var lastTouch = { x: touch.clientX, y: touch.clientY };\n\t            this.lastTouches.push(lastTouch);\n\t            var lts = this.lastTouches;\n\t            var removeLastTouch = function removeLastTouch() {\n\t                var i = lts.indexOf(lastTouch);\n\t                if (i > -1) {\n\t                    lts.splice(i, 1);\n\t                }\n\t            };\n\t            setTimeout(removeLastTouch, DEDUP_TIMEOUT);\n\t        }\n\t    }\n\t\n\t    function isSyntheticEvent(eventData) {\n\t        var x = eventData.srcEvent.clientX,\n\t            y = eventData.srcEvent.clientY;\n\t        for (var i = 0; i < this.lastTouches.length; i++) {\n\t            var t = this.lastTouches[i];\n\t            var dx = Math.abs(x - t.x),\n\t                dy = Math.abs(y - t.y);\n\t            if (dx <= DEDUP_DISTANCE && dy <= DEDUP_DISTANCE) {\n\t                return true;\n\t            }\n\t        }\n\t        return false;\n\t    }\n\t\n\t    var PREFIXED_TOUCH_ACTION = prefixed(TEST_ELEMENT.style, 'touchAction');\n\t    var NATIVE_TOUCH_ACTION = PREFIXED_TOUCH_ACTION !== undefined;\n\t\n\t    // magical touchAction value\n\t    var TOUCH_ACTION_COMPUTE = 'compute';\n\t    var TOUCH_ACTION_AUTO = 'auto';\n\t    var TOUCH_ACTION_MANIPULATION = 'manipulation'; // not implemented\n\t    var TOUCH_ACTION_NONE = 'none';\n\t    var TOUCH_ACTION_PAN_X = 'pan-x';\n\t    var TOUCH_ACTION_PAN_Y = 'pan-y';\n\t    var TOUCH_ACTION_MAP = getTouchActionProps();\n\t\n\t    /**\n\t     * Touch Action\n\t     * sets the touchAction property or uses the js alternative\n\t     * @param {Manager} manager\n\t     * @param {String} value\n\t     * @constructor\n\t     */\n\t    function TouchAction(manager, value) {\n\t        this.manager = manager;\n\t        this.set(value);\n\t    }\n\t\n\t    TouchAction.prototype = {\n\t        /**\n\t         * set the touchAction value on the element or enable the polyfill\n\t         * @param {String} value\n\t         */\n\t        set: function set(value) {\n\t            // find out the touch-action by the event handlers\n\t            if (value == TOUCH_ACTION_COMPUTE) {\n\t                value = this.compute();\n\t            }\n\t\n\t            if (NATIVE_TOUCH_ACTION && this.manager.element.style && TOUCH_ACTION_MAP[value]) {\n\t                this.manager.element.style[PREFIXED_TOUCH_ACTION] = value;\n\t            }\n\t            this.actions = value.toLowerCase().trim();\n\t        },\n\t\n\t        /**\n\t         * just re-set the touchAction value\n\t         */\n\t        update: function update() {\n\t            this.set(this.manager.options.touchAction);\n\t        },\n\t\n\t        /**\n\t         * compute the value for the touchAction property based on the recognizer's settings\n\t         * @returns {String} value\n\t         */\n\t        compute: function compute() {\n\t            var actions = [];\n\t            each(this.manager.recognizers, function (recognizer) {\n\t                if (boolOrFn(recognizer.options.enable, [recognizer])) {\n\t                    actions = actions.concat(recognizer.getTouchAction());\n\t                }\n\t            });\n\t            return cleanTouchActions(actions.join(' '));\n\t        },\n\t\n\t        /**\n\t         * this method is called on each input cycle and provides the preventing of the browser behavior\n\t         * @param {Object} input\n\t         */\n\t        preventDefaults: function preventDefaults(input) {\n\t            var srcEvent = input.srcEvent;\n\t            var direction = input.offsetDirection;\n\t\n\t            // if the touch action did prevented once this session\n\t            if (this.manager.session.prevented) {\n\t                srcEvent.preventDefault();\n\t                return;\n\t            }\n\t\n\t            var actions = this.actions;\n\t            var hasNone = inStr(actions, TOUCH_ACTION_NONE) && !TOUCH_ACTION_MAP[TOUCH_ACTION_NONE];\n\t            var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_Y];\n\t            var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_X];\n\t\n\t            if (hasNone) {\n\t                //do not prevent defaults if this is a tap gesture\n\t\n\t                var isTapPointer = input.pointers.length === 1;\n\t                var isTapMovement = input.distance < 2;\n\t                var isTapTouchTime = input.deltaTime < 250;\n\t\n\t                if (isTapPointer && isTapMovement && isTapTouchTime) {\n\t                    return;\n\t                }\n\t            }\n\t\n\t            if (hasPanX && hasPanY) {\n\t                // `pan-x pan-y` means browser handles all scrolling/panning, do not prevent\n\t                return;\n\t            }\n\t\n\t            if (hasNone || hasPanY && direction & DIRECTION_HORIZONTAL || hasPanX && direction & DIRECTION_VERTICAL) {\n\t                return this.preventSrc(srcEvent);\n\t            }\n\t        },\n\t\n\t        /**\n\t         * call preventDefault to prevent the browser's default behavior (scrolling in most cases)\n\t         * @param {Object} srcEvent\n\t         */\n\t        preventSrc: function preventSrc(srcEvent) {\n\t            this.manager.session.prevented = true;\n\t            srcEvent.preventDefault();\n\t        }\n\t    };\n\t\n\t    /**\n\t     * when the touchActions are collected they are not a valid value, so we need to clean things up. *\n\t     * @param {String} actions\n\t     * @returns {*}\n\t     */\n\t    function cleanTouchActions(actions) {\n\t        // none\n\t        if (inStr(actions, TOUCH_ACTION_NONE)) {\n\t            return TOUCH_ACTION_NONE;\n\t        }\n\t\n\t        var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);\n\t        var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);\n\t\n\t        // if both pan-x and pan-y are set (different recognizers\n\t        // for different directions, e.g. horizontal pan but vertical swipe?)\n\t        // we need none (as otherwise with pan-x pan-y combined none of these\n\t        // recognizers will work, since the browser would handle all panning\n\t        if (hasPanX && hasPanY) {\n\t            return TOUCH_ACTION_NONE;\n\t        }\n\t\n\t        // pan-x OR pan-y\n\t        if (hasPanX || hasPanY) {\n\t            return hasPanX ? TOUCH_ACTION_PAN_X : TOUCH_ACTION_PAN_Y;\n\t        }\n\t\n\t        // manipulation\n\t        if (inStr(actions, TOUCH_ACTION_MANIPULATION)) {\n\t            return TOUCH_ACTION_MANIPULATION;\n\t        }\n\t\n\t        return TOUCH_ACTION_AUTO;\n\t    }\n\t\n\t    function getTouchActionProps() {\n\t        if (!NATIVE_TOUCH_ACTION) {\n\t            return false;\n\t        }\n\t        var touchMap = {};\n\t        var cssSupports = window.CSS && window.CSS.supports;\n\t        ['auto', 'manipulation', 'pan-y', 'pan-x', 'pan-x pan-y', 'none'].forEach(function (val) {\n\t\n\t            // If css.supports is not supported but there is native touch-action assume it supports\n\t            // all values. This is the case for IE 10 and 11.\n\t            touchMap[val] = cssSupports ? window.CSS.supports('touch-action', val) : true;\n\t        });\n\t        return touchMap;\n\t    }\n\t\n\t    /**\n\t     * Recognizer flow explained; *\n\t     * All recognizers have the initial state of POSSIBLE when a input session starts.\n\t     * The definition of a input session is from the first input until the last input, with all it's movement in it. *\n\t     * Example session for mouse-input: mousedown -> mousemove -> mouseup\n\t     *\n\t     * On each recognizing cycle (see Manager.recognize) the .recognize() method is executed\n\t     * which determines with state it should be.\n\t     *\n\t     * If the recognizer has the state FAILED, CANCELLED or RECOGNIZED (equals ENDED), it is reset to\n\t     * POSSIBLE to give it another change on the next cycle.\n\t     *\n\t     *               Possible\n\t     *                  |\n\t     *            +-----+---------------+\n\t     *            |                     |\n\t     *      +-----+-----+               |\n\t     *      |           |               |\n\t     *   Failed      Cancelled          |\n\t     *                          +-------+------+\n\t     *                          |              |\n\t     *                      Recognized       Began\n\t     *                                         |\n\t     *                                      Changed\n\t     *                                         |\n\t     *                                  Ended/Recognized\n\t     */\n\t    var STATE_POSSIBLE = 1;\n\t    var STATE_BEGAN = 2;\n\t    var STATE_CHANGED = 4;\n\t    var STATE_ENDED = 8;\n\t    var STATE_RECOGNIZED = STATE_ENDED;\n\t    var STATE_CANCELLED = 16;\n\t    var STATE_FAILED = 32;\n\t\n\t    /**\n\t     * Recognizer\n\t     * Every recognizer needs to extend from this class.\n\t     * @constructor\n\t     * @param {Object} options\n\t     */\n\t    function Recognizer(options) {\n\t        this.options = assign({}, this.defaults, options || {});\n\t\n\t        this.id = uniqueId();\n\t\n\t        this.manager = null;\n\t\n\t        // default is enable true\n\t        this.options.enable = ifUndefined(this.options.enable, true);\n\t\n\t        this.state = STATE_POSSIBLE;\n\t\n\t        this.simultaneous = {};\n\t        this.requireFail = [];\n\t    }\n\t\n\t    Recognizer.prototype = {\n\t        /**\n\t         * @virtual\n\t         * @type {Object}\n\t         */\n\t        defaults: {},\n\t\n\t        /**\n\t         * set options\n\t         * @param {Object} options\n\t         * @return {Recognizer}\n\t         */\n\t        set: function set(options) {\n\t            assign(this.options, options);\n\t\n\t            // also update the touchAction, in case something changed about the directions/enabled state\n\t            this.manager && this.manager.touchAction.update();\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * recognize simultaneous with an other recognizer.\n\t         * @param {Recognizer} otherRecognizer\n\t         * @returns {Recognizer} this\n\t         */\n\t        recognizeWith: function recognizeWith(otherRecognizer) {\n\t            if (invokeArrayArg(otherRecognizer, 'recognizeWith', this)) {\n\t                return this;\n\t            }\n\t\n\t            var simultaneous = this.simultaneous;\n\t            otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n\t            if (!simultaneous[otherRecognizer.id]) {\n\t                simultaneous[otherRecognizer.id] = otherRecognizer;\n\t                otherRecognizer.recognizeWith(this);\n\t            }\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * drop the simultaneous link. it doesnt remove the link on the other recognizer.\n\t         * @param {Recognizer} otherRecognizer\n\t         * @returns {Recognizer} this\n\t         */\n\t        dropRecognizeWith: function dropRecognizeWith(otherRecognizer) {\n\t            if (invokeArrayArg(otherRecognizer, 'dropRecognizeWith', this)) {\n\t                return this;\n\t            }\n\t\n\t            otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n\t            delete this.simultaneous[otherRecognizer.id];\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * recognizer can only run when an other is failing\n\t         * @param {Recognizer} otherRecognizer\n\t         * @returns {Recognizer} this\n\t         */\n\t        requireFailure: function requireFailure(otherRecognizer) {\n\t            if (invokeArrayArg(otherRecognizer, 'requireFailure', this)) {\n\t                return this;\n\t            }\n\t\n\t            var requireFail = this.requireFail;\n\t            otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n\t            if (inArray(requireFail, otherRecognizer) === -1) {\n\t                requireFail.push(otherRecognizer);\n\t                otherRecognizer.requireFailure(this);\n\t            }\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * drop the requireFailure link. it does not remove the link on the other recognizer.\n\t         * @param {Recognizer} otherRecognizer\n\t         * @returns {Recognizer} this\n\t         */\n\t        dropRequireFailure: function dropRequireFailure(otherRecognizer) {\n\t            if (invokeArrayArg(otherRecognizer, 'dropRequireFailure', this)) {\n\t                return this;\n\t            }\n\t\n\t            otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n\t            var index = inArray(this.requireFail, otherRecognizer);\n\t            if (index > -1) {\n\t                this.requireFail.splice(index, 1);\n\t            }\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * has require failures boolean\n\t         * @returns {boolean}\n\t         */\n\t        hasRequireFailures: function hasRequireFailures() {\n\t            return this.requireFail.length > 0;\n\t        },\n\t\n\t        /**\n\t         * if the recognizer can recognize simultaneous with an other recognizer\n\t         * @param {Recognizer} otherRecognizer\n\t         * @returns {Boolean}\n\t         */\n\t        canRecognizeWith: function canRecognizeWith(otherRecognizer) {\n\t            return !!this.simultaneous[otherRecognizer.id];\n\t        },\n\t\n\t        /**\n\t         * You should use `tryEmit` instead of `emit` directly to check\n\t         * that all the needed recognizers has failed before emitting.\n\t         * @param {Object} input\n\t         */\n\t        emit: function emit(input) {\n\t            var self = this;\n\t            var state = this.state;\n\t\n\t            function emit(event) {\n\t                self.manager.emit(event, input);\n\t            }\n\t\n\t            // 'panstart' and 'panmove'\n\t            if (state < STATE_ENDED) {\n\t                emit(self.options.event + stateStr(state));\n\t            }\n\t\n\t            emit(self.options.event); // simple 'eventName' events\n\t\n\t            if (input.additionalEvent) {\n\t                // additional event(panleft, panright, pinchin, pinchout...)\n\t                emit(input.additionalEvent);\n\t            }\n\t\n\t            // panend and pancancel\n\t            if (state >= STATE_ENDED) {\n\t                emit(self.options.event + stateStr(state));\n\t            }\n\t        },\n\t\n\t        /**\n\t         * Check that all the require failure recognizers has failed,\n\t         * if true, it emits a gesture event,\n\t         * otherwise, setup the state to FAILED.\n\t         * @param {Object} input\n\t         */\n\t        tryEmit: function tryEmit(input) {\n\t            if (this.canEmit()) {\n\t                return this.emit(input);\n\t            }\n\t            // it's failing anyway\n\t            this.state = STATE_FAILED;\n\t        },\n\t\n\t        /**\n\t         * can we emit?\n\t         * @returns {boolean}\n\t         */\n\t        canEmit: function canEmit() {\n\t            var i = 0;\n\t            while (i < this.requireFail.length) {\n\t                if (!(this.requireFail[i].state & (STATE_FAILED | STATE_POSSIBLE))) {\n\t                    return false;\n\t                }\n\t                i++;\n\t            }\n\t            return true;\n\t        },\n\t\n\t        /**\n\t         * update the recognizer\n\t         * @param {Object} inputData\n\t         */\n\t        recognize: function recognize(inputData) {\n\t            // make a new copy of the inputData\n\t            // so we can change the inputData without messing up the other recognizers\n\t            var inputDataClone = assign({}, inputData);\n\t\n\t            // is is enabled and allow recognizing?\n\t            if (!boolOrFn(this.options.enable, [this, inputDataClone])) {\n\t                this.reset();\n\t                this.state = STATE_FAILED;\n\t                return;\n\t            }\n\t\n\t            // reset when we've reached the end\n\t            if (this.state & (STATE_RECOGNIZED | STATE_CANCELLED | STATE_FAILED)) {\n\t                this.state = STATE_POSSIBLE;\n\t            }\n\t\n\t            this.state = this.process(inputDataClone);\n\t\n\t            // the recognizer has recognized a gesture\n\t            // so trigger an event\n\t            if (this.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED | STATE_CANCELLED)) {\n\t                this.tryEmit(inputDataClone);\n\t            }\n\t        },\n\t\n\t        /**\n\t         * return the state of the recognizer\n\t         * the actual recognizing happens in this method\n\t         * @virtual\n\t         * @param {Object} inputData\n\t         * @returns {Const} STATE\n\t         */\n\t        process: function process(inputData) {}, // jshint ignore:line\n\t\n\t        /**\n\t         * return the preferred touch-action\n\t         * @virtual\n\t         * @returns {Array}\n\t         */\n\t        getTouchAction: function getTouchAction() {},\n\t\n\t        /**\n\t         * called when the gesture isn't allowed to recognize\n\t         * like when another is being recognized or it is disabled\n\t         * @virtual\n\t         */\n\t        reset: function reset() {}\n\t    };\n\t\n\t    /**\n\t     * get a usable string, used as event postfix\n\t     * @param {Const} state\n\t     * @returns {String} state\n\t     */\n\t    function stateStr(state) {\n\t        if (state & STATE_CANCELLED) {\n\t            return 'cancel';\n\t        } else if (state & STATE_ENDED) {\n\t            return 'end';\n\t        } else if (state & STATE_CHANGED) {\n\t            return 'move';\n\t        } else if (state & STATE_BEGAN) {\n\t            return 'start';\n\t        }\n\t        return '';\n\t    }\n\t\n\t    /**\n\t     * direction cons to string\n\t     * @param {Const} direction\n\t     * @returns {String}\n\t     */\n\t    function directionStr(direction) {\n\t        if (direction == DIRECTION_DOWN) {\n\t            return 'down';\n\t        } else if (direction == DIRECTION_UP) {\n\t            return 'up';\n\t        } else if (direction == DIRECTION_LEFT) {\n\t            return 'left';\n\t        } else if (direction == DIRECTION_RIGHT) {\n\t            return 'right';\n\t        }\n\t        return '';\n\t    }\n\t\n\t    /**\n\t     * get a recognizer by name if it is bound to a manager\n\t     * @param {Recognizer|String} otherRecognizer\n\t     * @param {Recognizer} recognizer\n\t     * @returns {Recognizer}\n\t     */\n\t    function getRecognizerByNameIfManager(otherRecognizer, recognizer) {\n\t        var manager = recognizer.manager;\n\t        if (manager) {\n\t            return manager.get(otherRecognizer);\n\t        }\n\t        return otherRecognizer;\n\t    }\n\t\n\t    /**\n\t     * This recognizer is just used as a base for the simple attribute recognizers.\n\t     * @constructor\n\t     * @extends Recognizer\n\t     */\n\t    function AttrRecognizer() {\n\t        Recognizer.apply(this, arguments);\n\t    }\n\t\n\t    inherit(AttrRecognizer, Recognizer, {\n\t        /**\n\t         * @namespace\n\t         * @memberof AttrRecognizer\n\t         */\n\t        defaults: {\n\t            /**\n\t             * @type {Number}\n\t             * @default 1\n\t             */\n\t            pointers: 1\n\t        },\n\t\n\t        /**\n\t         * Used to check if it the recognizer receives valid input, like input.distance > 10.\n\t         * @memberof AttrRecognizer\n\t         * @param {Object} input\n\t         * @returns {Boolean} recognized\n\t         */\n\t        attrTest: function attrTest(input) {\n\t            var optionPointers = this.options.pointers;\n\t            return optionPointers === 0 || input.pointers.length === optionPointers;\n\t        },\n\t\n\t        /**\n\t         * Process the input and return the state for the recognizer\n\t         * @memberof AttrRecognizer\n\t         * @param {Object} input\n\t         * @returns {*} State\n\t         */\n\t        process: function process(input) {\n\t            var state = this.state;\n\t            var eventType = input.eventType;\n\t\n\t            var isRecognized = state & (STATE_BEGAN | STATE_CHANGED);\n\t            var isValid = this.attrTest(input);\n\t\n\t            // on cancel input and we've recognized before, return STATE_CANCELLED\n\t            if (isRecognized && (eventType & INPUT_CANCEL || !isValid)) {\n\t                return state | STATE_CANCELLED;\n\t            } else if (isRecognized || isValid) {\n\t                if (eventType & INPUT_END) {\n\t                    return state | STATE_ENDED;\n\t                } else if (!(state & STATE_BEGAN)) {\n\t                    return STATE_BEGAN;\n\t                }\n\t                return state | STATE_CHANGED;\n\t            }\n\t            return STATE_FAILED;\n\t        }\n\t    });\n\t\n\t    /**\n\t     * Pan\n\t     * Recognized when the pointer is down and moved in the allowed direction.\n\t     * @constructor\n\t     * @extends AttrRecognizer\n\t     */\n\t    function PanRecognizer() {\n\t        AttrRecognizer.apply(this, arguments);\n\t\n\t        this.pX = null;\n\t        this.pY = null;\n\t    }\n\t\n\t    inherit(PanRecognizer, AttrRecognizer, {\n\t        /**\n\t         * @namespace\n\t         * @memberof PanRecognizer\n\t         */\n\t        defaults: {\n\t            event: 'pan',\n\t            threshold: 10,\n\t            pointers: 1,\n\t            direction: DIRECTION_ALL\n\t        },\n\t\n\t        getTouchAction: function getTouchAction() {\n\t            var direction = this.options.direction;\n\t            var actions = [];\n\t            if (direction & DIRECTION_HORIZONTAL) {\n\t                actions.push(TOUCH_ACTION_PAN_Y);\n\t            }\n\t            if (direction & DIRECTION_VERTICAL) {\n\t                actions.push(TOUCH_ACTION_PAN_X);\n\t            }\n\t            return actions;\n\t        },\n\t\n\t        directionTest: function directionTest(input) {\n\t            var options = this.options;\n\t            var hasMoved = true;\n\t            var distance = input.distance;\n\t            var direction = input.direction;\n\t            var x = input.deltaX;\n\t            var y = input.deltaY;\n\t\n\t            // lock to axis?\n\t            if (!(direction & options.direction)) {\n\t                if (options.direction & DIRECTION_HORIZONTAL) {\n\t                    direction = x === 0 ? DIRECTION_NONE : x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;\n\t                    hasMoved = x != this.pX;\n\t                    distance = Math.abs(input.deltaX);\n\t                } else {\n\t                    direction = y === 0 ? DIRECTION_NONE : y < 0 ? DIRECTION_UP : DIRECTION_DOWN;\n\t                    hasMoved = y != this.pY;\n\t                    distance = Math.abs(input.deltaY);\n\t                }\n\t            }\n\t            input.direction = direction;\n\t            return hasMoved && distance > options.threshold && direction & options.direction;\n\t        },\n\t\n\t        attrTest: function attrTest(input) {\n\t            return AttrRecognizer.prototype.attrTest.call(this, input) && (this.state & STATE_BEGAN || !(this.state & STATE_BEGAN) && this.directionTest(input));\n\t        },\n\t\n\t        emit: function emit(input) {\n\t\n\t            this.pX = input.deltaX;\n\t            this.pY = input.deltaY;\n\t\n\t            var direction = directionStr(input.direction);\n\t\n\t            if (direction) {\n\t                input.additionalEvent = this.options.event + direction;\n\t            }\n\t            this._super.emit.call(this, input);\n\t        }\n\t    });\n\t\n\t    /**\n\t     * Pinch\n\t     * Recognized when two or more pointers are moving toward (zoom-in) or away from each other (zoom-out).\n\t     * @constructor\n\t     * @extends AttrRecognizer\n\t     */\n\t    function PinchRecognizer() {\n\t        AttrRecognizer.apply(this, arguments);\n\t    }\n\t\n\t    inherit(PinchRecognizer, AttrRecognizer, {\n\t        /**\n\t         * @namespace\n\t         * @memberof PinchRecognizer\n\t         */\n\t        defaults: {\n\t            event: 'pinch',\n\t            threshold: 0,\n\t            pointers: 2\n\t        },\n\t\n\t        getTouchAction: function getTouchAction() {\n\t            return [TOUCH_ACTION_NONE];\n\t        },\n\t\n\t        attrTest: function attrTest(input) {\n\t            return this._super.attrTest.call(this, input) && (Math.abs(input.scale - 1) > this.options.threshold || this.state & STATE_BEGAN);\n\t        },\n\t\n\t        emit: function emit(input) {\n\t            if (input.scale !== 1) {\n\t                var inOut = input.scale < 1 ? 'in' : 'out';\n\t                input.additionalEvent = this.options.event + inOut;\n\t            }\n\t            this._super.emit.call(this, input);\n\t        }\n\t    });\n\t\n\t    /**\n\t     * Press\n\t     * Recognized when the pointer is down for x ms without any movement.\n\t     * @constructor\n\t     * @extends Recognizer\n\t     */\n\t    function PressRecognizer() {\n\t        Recognizer.apply(this, arguments);\n\t\n\t        this._timer = null;\n\t        this._input = null;\n\t    }\n\t\n\t    inherit(PressRecognizer, Recognizer, {\n\t        /**\n\t         * @namespace\n\t         * @memberof PressRecognizer\n\t         */\n\t        defaults: {\n\t            event: 'press',\n\t            pointers: 1,\n\t            time: 251, // minimal time of the pointer to be pressed\n\t            threshold: 9 // a minimal movement is ok, but keep it low\n\t        },\n\t\n\t        getTouchAction: function getTouchAction() {\n\t            return [TOUCH_ACTION_AUTO];\n\t        },\n\t\n\t        process: function process(input) {\n\t            var options = this.options;\n\t            var validPointers = input.pointers.length === options.pointers;\n\t            var validMovement = input.distance < options.threshold;\n\t            var validTime = input.deltaTime > options.time;\n\t\n\t            this._input = input;\n\t\n\t            // we only allow little movement\n\t            // and we've reached an end event, so a tap is possible\n\t            if (!validMovement || !validPointers || input.eventType & (INPUT_END | INPUT_CANCEL) && !validTime) {\n\t                this.reset();\n\t            } else if (input.eventType & INPUT_START) {\n\t                this.reset();\n\t                this._timer = setTimeoutContext(function () {\n\t                    this.state = STATE_RECOGNIZED;\n\t                    this.tryEmit();\n\t                }, options.time, this);\n\t            } else if (input.eventType & INPUT_END) {\n\t                return STATE_RECOGNIZED;\n\t            }\n\t            return STATE_FAILED;\n\t        },\n\t\n\t        reset: function reset() {\n\t            clearTimeout(this._timer);\n\t        },\n\t\n\t        emit: function emit(input) {\n\t            if (this.state !== STATE_RECOGNIZED) {\n\t                return;\n\t            }\n\t\n\t            if (input && input.eventType & INPUT_END) {\n\t                this.manager.emit(this.options.event + 'up', input);\n\t            } else {\n\t                this._input.timeStamp = now();\n\t                this.manager.emit(this.options.event, this._input);\n\t            }\n\t        }\n\t    });\n\t\n\t    /**\n\t     * Rotate\n\t     * Recognized when two or more pointer are moving in a circular motion.\n\t     * @constructor\n\t     * @extends AttrRecognizer\n\t     */\n\t    function RotateRecognizer() {\n\t        AttrRecognizer.apply(this, arguments);\n\t    }\n\t\n\t    inherit(RotateRecognizer, AttrRecognizer, {\n\t        /**\n\t         * @namespace\n\t         * @memberof RotateRecognizer\n\t         */\n\t        defaults: {\n\t            event: 'rotate',\n\t            threshold: 0,\n\t            pointers: 2\n\t        },\n\t\n\t        getTouchAction: function getTouchAction() {\n\t            return [TOUCH_ACTION_NONE];\n\t        },\n\t\n\t        attrTest: function attrTest(input) {\n\t            return this._super.attrTest.call(this, input) && (Math.abs(input.rotation) > this.options.threshold || this.state & STATE_BEGAN);\n\t        }\n\t    });\n\t\n\t    /**\n\t     * Swipe\n\t     * Recognized when the pointer is moving fast (velocity), with enough distance in the allowed direction.\n\t     * @constructor\n\t     * @extends AttrRecognizer\n\t     */\n\t    function SwipeRecognizer() {\n\t        AttrRecognizer.apply(this, arguments);\n\t    }\n\t\n\t    inherit(SwipeRecognizer, AttrRecognizer, {\n\t        /**\n\t         * @namespace\n\t         * @memberof SwipeRecognizer\n\t         */\n\t        defaults: {\n\t            event: 'swipe',\n\t            threshold: 10,\n\t            velocity: 0.3,\n\t            direction: DIRECTION_HORIZONTAL | DIRECTION_VERTICAL,\n\t            pointers: 1\n\t        },\n\t\n\t        getTouchAction: function getTouchAction() {\n\t            return PanRecognizer.prototype.getTouchAction.call(this);\n\t        },\n\t\n\t        attrTest: function attrTest(input) {\n\t            var direction = this.options.direction;\n\t            var velocity;\n\t\n\t            if (direction & (DIRECTION_HORIZONTAL | DIRECTION_VERTICAL)) {\n\t                velocity = input.overallVelocity;\n\t            } else if (direction & DIRECTION_HORIZONTAL) {\n\t                velocity = input.overallVelocityX;\n\t            } else if (direction & DIRECTION_VERTICAL) {\n\t                velocity = input.overallVelocityY;\n\t            }\n\t\n\t            return this._super.attrTest.call(this, input) && direction & input.offsetDirection && input.distance > this.options.threshold && input.maxPointers == this.options.pointers && abs(velocity) > this.options.velocity && input.eventType & INPUT_END;\n\t        },\n\t\n\t        emit: function emit(input) {\n\t            var direction = directionStr(input.offsetDirection);\n\t            if (direction) {\n\t                this.manager.emit(this.options.event + direction, input);\n\t            }\n\t\n\t            this.manager.emit(this.options.event, input);\n\t        }\n\t    });\n\t\n\t    /**\n\t     * A tap is ecognized when the pointer is doing a small tap/click. Multiple taps are recognized if they occur\n\t     * between the given interval and position. The delay option can be used to recognize multi-taps without firing\n\t     * a single tap.\n\t     *\n\t     * The eventData from the emitted event contains the property `tapCount`, which contains the amount of\n\t     * multi-taps being recognized.\n\t     * @constructor\n\t     * @extends Recognizer\n\t     */\n\t    function TapRecognizer() {\n\t        Recognizer.apply(this, arguments);\n\t\n\t        // previous time and center,\n\t        // used for tap counting\n\t        this.pTime = false;\n\t        this.pCenter = false;\n\t\n\t        this._timer = null;\n\t        this._input = null;\n\t        this.count = 0;\n\t    }\n\t\n\t    inherit(TapRecognizer, Recognizer, {\n\t        /**\n\t         * @namespace\n\t         * @memberof PinchRecognizer\n\t         */\n\t        defaults: {\n\t            event: 'tap',\n\t            pointers: 1,\n\t            taps: 1,\n\t            interval: 300, // max time between the multi-tap taps\n\t            time: 250, // max time of the pointer to be down (like finger on the screen)\n\t            threshold: 9, // a minimal movement is ok, but keep it low\n\t            posThreshold: 10 // a multi-tap can be a bit off the initial position\n\t        },\n\t\n\t        getTouchAction: function getTouchAction() {\n\t            return [TOUCH_ACTION_MANIPULATION];\n\t        },\n\t\n\t        process: function process(input) {\n\t            var options = this.options;\n\t\n\t            var validPointers = input.pointers.length === options.pointers;\n\t            var validMovement = input.distance < options.threshold;\n\t            var validTouchTime = input.deltaTime < options.time;\n\t\n\t            this.reset();\n\t\n\t            if (input.eventType & INPUT_START && this.count === 0) {\n\t                return this.failTimeout();\n\t            }\n\t\n\t            // we only allow little movement\n\t            // and we've reached an end event, so a tap is possible\n\t            if (validMovement && validTouchTime && validPointers) {\n\t                if (input.eventType != INPUT_END) {\n\t                    return this.failTimeout();\n\t                }\n\t\n\t                var validInterval = this.pTime ? input.timeStamp - this.pTime < options.interval : true;\n\t                var validMultiTap = !this.pCenter || getDistance(this.pCenter, input.center) < options.posThreshold;\n\t\n\t                this.pTime = input.timeStamp;\n\t                this.pCenter = input.center;\n\t\n\t                if (!validMultiTap || !validInterval) {\n\t                    this.count = 1;\n\t                } else {\n\t                    this.count += 1;\n\t                }\n\t\n\t                this._input = input;\n\t\n\t                // if tap count matches we have recognized it,\n\t                // else it has began recognizing...\n\t                var tapCount = this.count % options.taps;\n\t                if (tapCount === 0) {\n\t                    // no failing requirements, immediately trigger the tap event\n\t                    // or wait as long as the multitap interval to trigger\n\t                    if (!this.hasRequireFailures()) {\n\t                        return STATE_RECOGNIZED;\n\t                    } else {\n\t                        this._timer = setTimeoutContext(function () {\n\t                            this.state = STATE_RECOGNIZED;\n\t                            this.tryEmit();\n\t                        }, options.interval, this);\n\t                        return STATE_BEGAN;\n\t                    }\n\t                }\n\t            }\n\t            return STATE_FAILED;\n\t        },\n\t\n\t        failTimeout: function failTimeout() {\n\t            this._timer = setTimeoutContext(function () {\n\t                this.state = STATE_FAILED;\n\t            }, this.options.interval, this);\n\t            return STATE_FAILED;\n\t        },\n\t\n\t        reset: function reset() {\n\t            clearTimeout(this._timer);\n\t        },\n\t\n\t        emit: function emit() {\n\t            if (this.state == STATE_RECOGNIZED) {\n\t                this._input.tapCount = this.count;\n\t                this.manager.emit(this.options.event, this._input);\n\t            }\n\t        }\n\t    });\n\t\n\t    /**\n\t     * Simple way to create a manager with a default set of recognizers.\n\t     * @param {HTMLElement} element\n\t     * @param {Object} [options]\n\t     * @constructor\n\t     */\n\t    function Hammer(element, options) {\n\t        options = options || {};\n\t        options.recognizers = ifUndefined(options.recognizers, Hammer.defaults.preset);\n\t        return new Manager(element, options);\n\t    }\n\t\n\t    /**\n\t     * @const {string}\n\t     */\n\t    Hammer.VERSION = '2.0.7';\n\t\n\t    /**\n\t     * default settings\n\t     * @namespace\n\t     */\n\t    Hammer.defaults = {\n\t        /**\n\t         * set if DOM events are being triggered.\n\t         * But this is slower and unused by simple implementations, so disabled by default.\n\t         * @type {Boolean}\n\t         * @default false\n\t         */\n\t        domEvents: false,\n\t\n\t        /**\n\t         * The value for the touchAction property/fallback.\n\t         * When set to `compute` it will magically set the correct value based on the added recognizers.\n\t         * @type {String}\n\t         * @default compute\n\t         */\n\t        touchAction: TOUCH_ACTION_COMPUTE,\n\t\n\t        /**\n\t         * @type {Boolean}\n\t         * @default true\n\t         */\n\t        enable: true,\n\t\n\t        /**\n\t         * EXPERIMENTAL FEATURE -- can be removed/changed\n\t         * Change the parent input target element.\n\t         * If Null, then it is being set the to main element.\n\t         * @type {Null|EventTarget}\n\t         * @default null\n\t         */\n\t        inputTarget: null,\n\t\n\t        /**\n\t         * force an input class\n\t         * @type {Null|Function}\n\t         * @default null\n\t         */\n\t        inputClass: null,\n\t\n\t        /**\n\t         * Default recognizer setup when calling `Hammer()`\n\t         * When creating a new Manager these will be skipped.\n\t         * @type {Array}\n\t         */\n\t        preset: [\n\t        // RecognizerClass, options, [recognizeWith, ...], [requireFailure, ...]\n\t        [RotateRecognizer, { enable: false }], [PinchRecognizer, { enable: false }, ['rotate']], [SwipeRecognizer, { direction: DIRECTION_HORIZONTAL }], [PanRecognizer, { direction: DIRECTION_HORIZONTAL }, ['swipe']], [TapRecognizer], [TapRecognizer, { event: 'doubletap', taps: 2 }, ['tap']], [PressRecognizer]],\n\t\n\t        /**\n\t         * Some CSS properties can be used to improve the working of Hammer.\n\t         * Add them to this method and they will be set when creating a new Manager.\n\t         * @namespace\n\t         */\n\t        cssProps: {\n\t            /**\n\t             * Disables text selection to improve the dragging gesture. Mainly for desktop browsers.\n\t             * @type {String}\n\t             * @default 'none'\n\t             */\n\t            userSelect: 'none',\n\t\n\t            /**\n\t             * Disable the Windows Phone grippers when pressing an element.\n\t             * @type {String}\n\t             * @default 'none'\n\t             */\n\t            touchSelect: 'none',\n\t\n\t            /**\n\t             * Disables the default callout shown when you touch and hold a touch target.\n\t             * On iOS, when you touch and hold a touch target such as a link, Safari displays\n\t             * a callout containing information about the link. This property allows you to disable that callout.\n\t             * @type {String}\n\t             * @default 'none'\n\t             */\n\t            touchCallout: 'none',\n\t\n\t            /**\n\t             * Specifies whether zooming is enabled. Used by IE10>\n\t             * @type {String}\n\t             * @default 'none'\n\t             */\n\t            contentZooming: 'none',\n\t\n\t            /**\n\t             * Specifies that an entire element should be draggable instead of its contents. Mainly for desktop browsers.\n\t             * @type {String}\n\t             * @default 'none'\n\t             */\n\t            userDrag: 'none',\n\t\n\t            /**\n\t             * Overrides the highlight color shown when the user taps a link or a JavaScript\n\t             * clickable element in iOS. This property obeys the alpha value, if specified.\n\t             * @type {String}\n\t             * @default 'rgba(0,0,0,0)'\n\t             */\n\t            tapHighlightColor: 'rgba(0,0,0,0)'\n\t        }\n\t    };\n\t\n\t    var STOP = 1;\n\t    var FORCED_STOP = 2;\n\t\n\t    /**\n\t     * Manager\n\t     * @param {HTMLElement} element\n\t     * @param {Object} [options]\n\t     * @constructor\n\t     */\n\t    function Manager(element, options) {\n\t        this.options = assign({}, Hammer.defaults, options || {});\n\t\n\t        this.options.inputTarget = this.options.inputTarget || element;\n\t\n\t        this.handlers = {};\n\t        this.session = {};\n\t        this.recognizers = [];\n\t        this.oldCssProps = {};\n\t\n\t        this.element = element;\n\t        this.input = createInputInstance(this);\n\t        this.touchAction = new TouchAction(this, this.options.touchAction);\n\t\n\t        toggleCssProps(this, true);\n\t\n\t        each(this.options.recognizers, function (item) {\n\t            var recognizer = this.add(new item[0](item[1]));\n\t            item[2] && recognizer.recognizeWith(item[2]);\n\t            item[3] && recognizer.requireFailure(item[3]);\n\t        }, this);\n\t    }\n\t\n\t    Manager.prototype = {\n\t        /**\n\t         * set options\n\t         * @param {Object} options\n\t         * @returns {Manager}\n\t         */\n\t        set: function set(options) {\n\t            assign(this.options, options);\n\t\n\t            // Options that need a little more setup\n\t            if (options.touchAction) {\n\t                this.touchAction.update();\n\t            }\n\t            if (options.inputTarget) {\n\t                // Clean up existing event listeners and reinitialize\n\t                this.input.destroy();\n\t                this.input.target = options.inputTarget;\n\t                this.input.init();\n\t            }\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * stop recognizing for this session.\n\t         * This session will be discarded, when a new [input]start event is fired.\n\t         * When forced, the recognizer cycle is stopped immediately.\n\t         * @param {Boolean} [force]\n\t         */\n\t        stop: function stop(force) {\n\t            this.session.stopped = force ? FORCED_STOP : STOP;\n\t        },\n\t\n\t        /**\n\t         * run the recognizers!\n\t         * called by the inputHandler function on every movement of the pointers (touches)\n\t         * it walks through all the recognizers and tries to detect the gesture that is being made\n\t         * @param {Object} inputData\n\t         */\n\t        recognize: function recognize(inputData) {\n\t            var session = this.session;\n\t            if (session.stopped) {\n\t                return;\n\t            }\n\t\n\t            // run the touch-action polyfill\n\t            this.touchAction.preventDefaults(inputData);\n\t\n\t            var recognizer;\n\t            var recognizers = this.recognizers;\n\t\n\t            // this holds the recognizer that is being recognized.\n\t            // so the recognizer's state needs to be BEGAN, CHANGED, ENDED or RECOGNIZED\n\t            // if no recognizer is detecting a thing, it is set to `null`\n\t            var curRecognizer = session.curRecognizer;\n\t\n\t            // reset when the last recognizer is recognized\n\t            // or when we're in a new session\n\t            if (!curRecognizer || curRecognizer && curRecognizer.state & STATE_RECOGNIZED) {\n\t                curRecognizer = session.curRecognizer = null;\n\t            }\n\t\n\t            var i = 0;\n\t            while (i < recognizers.length) {\n\t                recognizer = recognizers[i];\n\t\n\t                // find out if we are allowed try to recognize the input for this one.\n\t                // 1.   allow if the session is NOT forced stopped (see the .stop() method)\n\t                // 2.   allow if we still haven't recognized a gesture in this session, or the this recognizer is the one\n\t                //      that is being recognized.\n\t                // 3.   allow if the recognizer is allowed to run simultaneous with the current recognized recognizer.\n\t                //      this can be setup with the `recognizeWith()` method on the recognizer.\n\t                if (session.stopped !== FORCED_STOP && ( // 1\n\t                !curRecognizer || recognizer == curRecognizer || // 2\n\t                recognizer.canRecognizeWith(curRecognizer))) {\n\t                    // 3\n\t                    recognizer.recognize(inputData);\n\t                } else {\n\t                    recognizer.reset();\n\t                }\n\t\n\t                // if the recognizer has been recognizing the input as a valid gesture, we want to store this one as the\n\t                // current active recognizer. but only if we don't already have an active recognizer\n\t                if (!curRecognizer && recognizer.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED)) {\n\t                    curRecognizer = session.curRecognizer = recognizer;\n\t                }\n\t                i++;\n\t            }\n\t        },\n\t\n\t        /**\n\t         * get a recognizer by its event name.\n\t         * @param {Recognizer|String} recognizer\n\t         * @returns {Recognizer|Null}\n\t         */\n\t        get: function get(recognizer) {\n\t            if (recognizer instanceof Recognizer) {\n\t                return recognizer;\n\t            }\n\t\n\t            var recognizers = this.recognizers;\n\t            for (var i = 0; i < recognizers.length; i++) {\n\t                if (recognizers[i].options.event == recognizer) {\n\t                    return recognizers[i];\n\t                }\n\t            }\n\t            return null;\n\t        },\n\t\n\t        /**\n\t         * add a recognizer to the manager\n\t         * existing recognizers with the same event name will be removed\n\t         * @param {Recognizer} recognizer\n\t         * @returns {Recognizer|Manager}\n\t         */\n\t        add: function add(recognizer) {\n\t            if (invokeArrayArg(recognizer, 'add', this)) {\n\t                return this;\n\t            }\n\t\n\t            // remove existing\n\t            var existing = this.get(recognizer.options.event);\n\t            if (existing) {\n\t                this.remove(existing);\n\t            }\n\t\n\t            this.recognizers.push(recognizer);\n\t            recognizer.manager = this;\n\t\n\t            this.touchAction.update();\n\t            return recognizer;\n\t        },\n\t\n\t        /**\n\t         * remove a recognizer by name or instance\n\t         * @param {Recognizer|String} recognizer\n\t         * @returns {Manager}\n\t         */\n\t        remove: function remove(recognizer) {\n\t            if (invokeArrayArg(recognizer, 'remove', this)) {\n\t                return this;\n\t            }\n\t\n\t            recognizer = this.get(recognizer);\n\t\n\t            // let's make sure this recognizer exists\n\t            if (recognizer) {\n\t                var recognizers = this.recognizers;\n\t                var index = inArray(recognizers, recognizer);\n\t\n\t                if (index !== -1) {\n\t                    recognizers.splice(index, 1);\n\t                    this.touchAction.update();\n\t                }\n\t            }\n\t\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * bind event\n\t         * @param {String} events\n\t         * @param {Function} handler\n\t         * @returns {EventEmitter} this\n\t         */\n\t        on: function on(events, handler) {\n\t            if (events === undefined) {\n\t                return;\n\t            }\n\t            if (handler === undefined) {\n\t                return;\n\t            }\n\t\n\t            var handlers = this.handlers;\n\t            each(splitStr(events), function (event) {\n\t                handlers[event] = handlers[event] || [];\n\t                handlers[event].push(handler);\n\t            });\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * unbind event, leave emit blank to remove all handlers\n\t         * @param {String} events\n\t         * @param {Function} [handler]\n\t         * @returns {EventEmitter} this\n\t         */\n\t        off: function off(events, handler) {\n\t            if (events === undefined) {\n\t                return;\n\t            }\n\t\n\t            var handlers = this.handlers;\n\t            each(splitStr(events), function (event) {\n\t                if (!handler) {\n\t                    delete handlers[event];\n\t                } else {\n\t                    handlers[event] && handlers[event].splice(inArray(handlers[event], handler), 1);\n\t                }\n\t            });\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * emit event to the listeners\n\t         * @param {String} event\n\t         * @param {Object} data\n\t         */\n\t        emit: function emit(event, data) {\n\t            // we also want to trigger dom events\n\t            if (this.options.domEvents) {\n\t                triggerDomEvent(event, data);\n\t            }\n\t\n\t            // no handlers, so skip it all\n\t            var handlers = this.handlers[event] && this.handlers[event].slice();\n\t            if (!handlers || !handlers.length) {\n\t                return;\n\t            }\n\t\n\t            data.type = event;\n\t            data.preventDefault = function () {\n\t                data.srcEvent.preventDefault();\n\t            };\n\t\n\t            var i = 0;\n\t            while (i < handlers.length) {\n\t                handlers[i](data);\n\t                i++;\n\t            }\n\t        },\n\t\n\t        /**\n\t         * destroy the manager and unbinds all events\n\t         * it doesn't unbind dom events, that is the user own responsibility\n\t         */\n\t        destroy: function destroy() {\n\t            this.element && toggleCssProps(this, false);\n\t\n\t            this.handlers = {};\n\t            this.session = {};\n\t            this.input.destroy();\n\t            this.element = null;\n\t        }\n\t    };\n\t\n\t    /**\n\t     * add/remove the css properties as defined in manager.options.cssProps\n\t     * @param {Manager} manager\n\t     * @param {Boolean} add\n\t     */\n\t    function toggleCssProps(manager, add) {\n\t        var element = manager.element;\n\t        if (!element.style) {\n\t            return;\n\t        }\n\t        var prop;\n\t        each(manager.options.cssProps, function (value, name) {\n\t            prop = prefixed(element.style, name);\n\t            if (add) {\n\t                manager.oldCssProps[prop] = element.style[prop];\n\t                element.style[prop] = value;\n\t            } else {\n\t                element.style[prop] = manager.oldCssProps[prop] || '';\n\t            }\n\t        });\n\t        if (!add) {\n\t            manager.oldCssProps = {};\n\t        }\n\t    }\n\t\n\t    /**\n\t     * trigger dom event\n\t     * @param {String} event\n\t     * @param {Object} data\n\t     */\n\t    function triggerDomEvent(event, data) {\n\t        var gestureEvent = document.createEvent('Event');\n\t        gestureEvent.initEvent(event, true, true);\n\t        gestureEvent.gesture = data;\n\t        data.target.dispatchEvent(gestureEvent);\n\t    }\n\t\n\t    assign(Hammer, {\n\t        INPUT_START: INPUT_START,\n\t        INPUT_MOVE: INPUT_MOVE,\n\t        INPUT_END: INPUT_END,\n\t        INPUT_CANCEL: INPUT_CANCEL,\n\t\n\t        STATE_POSSIBLE: STATE_POSSIBLE,\n\t        STATE_BEGAN: STATE_BEGAN,\n\t        STATE_CHANGED: STATE_CHANGED,\n\t        STATE_ENDED: STATE_ENDED,\n\t        STATE_RECOGNIZED: STATE_RECOGNIZED,\n\t        STATE_CANCELLED: STATE_CANCELLED,\n\t        STATE_FAILED: STATE_FAILED,\n\t\n\t        DIRECTION_NONE: DIRECTION_NONE,\n\t        DIRECTION_LEFT: DIRECTION_LEFT,\n\t        DIRECTION_RIGHT: DIRECTION_RIGHT,\n\t        DIRECTION_UP: DIRECTION_UP,\n\t        DIRECTION_DOWN: DIRECTION_DOWN,\n\t        DIRECTION_HORIZONTAL: DIRECTION_HORIZONTAL,\n\t        DIRECTION_VERTICAL: DIRECTION_VERTICAL,\n\t        DIRECTION_ALL: DIRECTION_ALL,\n\t\n\t        Manager: Manager,\n\t        Input: Input,\n\t        TouchAction: TouchAction,\n\t\n\t        TouchInput: TouchInput,\n\t        MouseInput: MouseInput,\n\t        PointerEventInput: PointerEventInput,\n\t        TouchMouseInput: TouchMouseInput,\n\t        SingleTouchInput: SingleTouchInput,\n\t\n\t        Recognizer: Recognizer,\n\t        AttrRecognizer: AttrRecognizer,\n\t        Tap: TapRecognizer,\n\t        Pan: PanRecognizer,\n\t        Swipe: SwipeRecognizer,\n\t        Pinch: PinchRecognizer,\n\t        Rotate: RotateRecognizer,\n\t        Press: PressRecognizer,\n\t\n\t        on: addEventListeners,\n\t        off: removeEventListeners,\n\t        each: each,\n\t        merge: merge,\n\t        extend: extend,\n\t        assign: assign,\n\t        inherit: inherit,\n\t        bindFn: bindFn,\n\t        prefixed: prefixed\n\t    });\n\t\n\t    // this prevents errors when Hammer is loaded in the presence of an AMD\n\t    //  style loader but by script tag, not by the loader.\n\t    var freeGlobal = typeof window !== 'undefined' ? window : typeof self !== 'undefined' ? self : {}; // jshint ignore:line\n\t    freeGlobal.Hammer = Hammer;\n\t\n\t    if (true) {\n\t        !(__WEBPACK_AMD_DEFINE_RESULT__ = function () {\n\t            return Hammer;\n\t        }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t    } else if (typeof module != 'undefined' && module.exports) {\n\t        module.exports = Hammer;\n\t    } else {\n\t        window[exportName] = Hammer;\n\t    }\n\t})(window, document, 'Hammer');\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// style-loader: Adds some css to the DOM by adding a <style> tag\n\t\n\t// load the styles\n\tvar content = __webpack_require__(3);\n\tif(typeof content === 'string') content = [[module.id, content, '']];\n\t// add the styles to the DOM\n\tvar update = __webpack_require__(5)(content, {});\n\tif(content.locals) module.exports = content.locals;\n\t// Hot Module Replacement\n\tif(false) {\n\t\t// When the styles change, update the <style> tags\n\t\tif(!content.locals) {\n\t\t\tmodule.hot.accept(\"!!./../node_modules/css-loader/index.js!./../node_modules/less-loader/index.js!./Gallery.less\", function() {\n\t\t\t\tvar newContent = require(\"!!./../node_modules/css-loader/index.js!./../node_modules/less-loader/index.js!./Gallery.less\");\n\t\t\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\t\t\t\tupdate(newContent);\n\t\t\t});\n\t\t}\n\t\t// When the module is disposed, remove the <style> tags\n\t\tmodule.hot.dispose(function() { update(); });\n\t}\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\texports = module.exports = __webpack_require__(4)();\n\t// imports\n\t\n\t\n\t// module\n\texports.push([module.id, \".gallery{height:250px;background-color:#000;position:relative;overflow:hidden}.gallery.fullscreen{position:fixed;z-index:100;top:0;left:0;right:0;bottom:0;height:auto}.gallery .back-nav-icon,.gallery .forward-nav-icon{position:absolute;top:0;bottom:22px;margin:auto;width:30px;height:30px;opacity:0;z-index:3;transition:opacity .3s}.gallery .back-nav-icon:hover,.gallery .forward-nav-icon:hover{opacity:.75!important}.gallery:hover .back-nav-icon,.gallery:hover .forward-nav-icon{opacity:.5}.gallery .forward-nav-icon{right:15px}.gallery .back-nav-icon{left:15px}.gallery .status-bar{position:absolute;bottom:0;left:0;right:0;height:22px;text-align:center;background:#45484d;background:-moz-linear-gradient(top,#45484d 0,#000 100%);background:-webkit-linear-gradient(top,#45484d,#000);background:linear-gradient(180deg,#45484d 0,#000);filter:progid:DXImageTransform.Microsoft.gradient(startColorstr='#45484d',endColorstr='#000000',GradientType=0);-webkit-box-shadow:0 0 14px 0 rgba(0,0,0,.75);-moz-box-shadow:0 0 14px 0 rgba(0,0,0,.75);box-shadow:0 0 14px 0 rgba(0,0,0,.75);z-index:2;color:#fff;padding:5px;font-size:12px;box-sizing:border-box}.gallery .status-bar .fullscreen-icon{position:absolute;right:5px;top:5px;height:12px}.gallery .status-bar .navigation-status{position:absolute;left:5px;top:5px}.gallery .gallery-content{position:absolute;top:0;left:0;bottom:22px;width:100%;overflow:hidden;transition:left .5s;white-space:nowrap;z-index:1;overflow:visible}.gallery .gallery-content>*{width:100%;height:100%;display:inline-block;background-size:contain;background-repeat:no-repeat;background-position:50%;vertical-align:top;position:relative;overflow:hidden}.gallery .gallery-content>* iframe{width:100%;height:100%}.gallery .gallery-content>* img{position:absolute;top:0;left:0;transform:translateZ(0)}\", \"\"]);\n\t\n\t// exports\n\n\n/***/ },\n/* 4 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\t/*\n\t\tMIT License http://www.opensource.org/licenses/mit-license.php\n\t\tAuthor Tobias Koppers @sokra\n\t*/\n\t// css base code, injected by the css-loader\n\tmodule.exports = function () {\n\t\tvar list = [];\n\t\n\t\t// return the list of modules as css string\n\t\tlist.toString = function toString() {\n\t\t\tvar result = [];\n\t\t\tfor (var i = 0; i < this.length; i++) {\n\t\t\t\tvar item = this[i];\n\t\t\t\tif (item[2]) {\n\t\t\t\t\tresult.push(\"@media \" + item[2] + \"{\" + item[1] + \"}\");\n\t\t\t\t} else {\n\t\t\t\t\tresult.push(item[1]);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn result.join(\"\");\n\t\t};\n\t\n\t\t// import a list of modules into the list\n\t\tlist.i = function (modules, mediaQuery) {\n\t\t\tif (typeof modules === \"string\") modules = [[null, modules, \"\"]];\n\t\t\tvar alreadyImportedModules = {};\n\t\t\tfor (var i = 0; i < this.length; i++) {\n\t\t\t\tvar id = this[i][0];\n\t\t\t\tif (typeof id === \"number\") alreadyImportedModules[id] = true;\n\t\t\t}\n\t\t\tfor (i = 0; i < modules.length; i++) {\n\t\t\t\tvar item = modules[i];\n\t\t\t\t// skip already imported module\n\t\t\t\t// this implementation is not 100% perfect for weird media query combinations\n\t\t\t\t//  when a module is imported multiple times with different media queries.\n\t\t\t\t//  I hope this will never occur (Hey this way we have smaller bundles)\n\t\t\t\tif (typeof item[0] !== \"number\" || !alreadyImportedModules[item[0]]) {\n\t\t\t\t\tif (mediaQuery && !item[2]) {\n\t\t\t\t\t\titem[2] = mediaQuery;\n\t\t\t\t\t} else if (mediaQuery) {\n\t\t\t\t\t\titem[2] = \"(\" + item[2] + \") and (\" + mediaQuery + \")\";\n\t\t\t\t\t}\n\t\t\t\t\tlist.push(item);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\treturn list;\n\t};\n\n/***/ },\n/* 5 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/*\r\n\t\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\t\tAuthor Tobias Koppers @sokra\r\n\t*/\r\n\tvar stylesInDom = {},\r\n\t\tmemoize = function(fn) {\r\n\t\t\tvar memo;\r\n\t\t\treturn function () {\r\n\t\t\t\tif (typeof memo === \"undefined\") memo = fn.apply(this, arguments);\r\n\t\t\t\treturn memo;\r\n\t\t\t};\r\n\t\t},\r\n\t\tisOldIE = memoize(function() {\r\n\t\t\treturn /msie [6-9]\\b/.test(window.navigator.userAgent.toLowerCase());\r\n\t\t}),\r\n\t\tgetHeadElement = memoize(function () {\r\n\t\t\treturn document.head || document.getElementsByTagName(\"head\")[0];\r\n\t\t}),\r\n\t\tsingletonElement = null,\r\n\t\tsingletonCounter = 0,\r\n\t\tstyleElementsInsertedAtTop = [];\r\n\t\r\n\tmodule.exports = function(list, options) {\r\n\t\tif(false) {\r\n\t\t\tif(typeof document !== \"object\") throw new Error(\"The style-loader cannot be used in a non-browser environment\");\r\n\t\t}\r\n\t\r\n\t\toptions = options || {};\r\n\t\t// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\r\n\t\t// tags it will allow on a page\r\n\t\tif (typeof options.singleton === \"undefined\") options.singleton = isOldIE();\r\n\t\r\n\t\t// By default, add <style> tags to the bottom of <head>.\r\n\t\tif (typeof options.insertAt === \"undefined\") options.insertAt = \"bottom\";\r\n\t\r\n\t\tvar styles = listToStyles(list);\r\n\t\taddStylesToDom(styles, options);\r\n\t\r\n\t\treturn function update(newList) {\r\n\t\t\tvar mayRemove = [];\r\n\t\t\tfor(var i = 0; i < styles.length; i++) {\r\n\t\t\t\tvar item = styles[i];\r\n\t\t\t\tvar domStyle = stylesInDom[item.id];\r\n\t\t\t\tdomStyle.refs--;\r\n\t\t\t\tmayRemove.push(domStyle);\r\n\t\t\t}\r\n\t\t\tif(newList) {\r\n\t\t\t\tvar newStyles = listToStyles(newList);\r\n\t\t\t\taddStylesToDom(newStyles, options);\r\n\t\t\t}\r\n\t\t\tfor(var i = 0; i < mayRemove.length; i++) {\r\n\t\t\t\tvar domStyle = mayRemove[i];\r\n\t\t\t\tif(domStyle.refs === 0) {\r\n\t\t\t\t\tfor(var j = 0; j < domStyle.parts.length; j++)\r\n\t\t\t\t\t\tdomStyle.parts[j]();\r\n\t\t\t\t\tdelete stylesInDom[domStyle.id];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t};\r\n\t}\r\n\t\r\n\tfunction addStylesToDom(styles, options) {\r\n\t\tfor(var i = 0; i < styles.length; i++) {\r\n\t\t\tvar item = styles[i];\r\n\t\t\tvar domStyle = stylesInDom[item.id];\r\n\t\t\tif(domStyle) {\r\n\t\t\t\tdomStyle.refs++;\r\n\t\t\t\tfor(var j = 0; j < domStyle.parts.length; j++) {\r\n\t\t\t\t\tdomStyle.parts[j](item.parts[j]);\r\n\t\t\t\t}\r\n\t\t\t\tfor(; j < item.parts.length; j++) {\r\n\t\t\t\t\tdomStyle.parts.push(addStyle(item.parts[j], options));\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tvar parts = [];\r\n\t\t\t\tfor(var j = 0; j < item.parts.length; j++) {\r\n\t\t\t\t\tparts.push(addStyle(item.parts[j], options));\r\n\t\t\t\t}\r\n\t\t\t\tstylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\r\n\tfunction listToStyles(list) {\r\n\t\tvar styles = [];\r\n\t\tvar newStyles = {};\r\n\t\tfor(var i = 0; i < list.length; i++) {\r\n\t\t\tvar item = list[i];\r\n\t\t\tvar id = item[0];\r\n\t\t\tvar css = item[1];\r\n\t\t\tvar media = item[2];\r\n\t\t\tvar sourceMap = item[3];\r\n\t\t\tvar part = {css: css, media: media, sourceMap: sourceMap};\r\n\t\t\tif(!newStyles[id])\r\n\t\t\t\tstyles.push(newStyles[id] = {id: id, parts: [part]});\r\n\t\t\telse\r\n\t\t\t\tnewStyles[id].parts.push(part);\r\n\t\t}\r\n\t\treturn styles;\r\n\t}\r\n\t\r\n\tfunction insertStyleElement(options, styleElement) {\r\n\t\tvar head = getHeadElement();\r\n\t\tvar lastStyleElementInsertedAtTop = styleElementsInsertedAtTop[styleElementsInsertedAtTop.length - 1];\r\n\t\tif (options.insertAt === \"top\") {\r\n\t\t\tif(!lastStyleElementInsertedAtTop) {\r\n\t\t\t\thead.insertBefore(styleElement, head.firstChild);\r\n\t\t\t} else if(lastStyleElementInsertedAtTop.nextSibling) {\r\n\t\t\t\thead.insertBefore(styleElement, lastStyleElementInsertedAtTop.nextSibling);\r\n\t\t\t} else {\r\n\t\t\t\thead.appendChild(styleElement);\r\n\t\t\t}\r\n\t\t\tstyleElementsInsertedAtTop.push(styleElement);\r\n\t\t} else if (options.insertAt === \"bottom\") {\r\n\t\t\thead.appendChild(styleElement);\r\n\t\t} else {\r\n\t\t\tthrow new Error(\"Invalid value for parameter 'insertAt'. Must be 'top' or 'bottom'.\");\r\n\t\t}\r\n\t}\r\n\t\r\n\tfunction removeStyleElement(styleElement) {\r\n\t\tstyleElement.parentNode.removeChild(styleElement);\r\n\t\tvar idx = styleElementsInsertedAtTop.indexOf(styleElement);\r\n\t\tif(idx >= 0) {\r\n\t\t\tstyleElementsInsertedAtTop.splice(idx, 1);\r\n\t\t}\r\n\t}\r\n\t\r\n\tfunction createStyleElement(options) {\r\n\t\tvar styleElement = document.createElement(\"style\");\r\n\t\tstyleElement.type = \"text/css\";\r\n\t\tinsertStyleElement(options, styleElement);\r\n\t\treturn styleElement;\r\n\t}\r\n\t\r\n\tfunction createLinkElement(options) {\r\n\t\tvar linkElement = document.createElement(\"link\");\r\n\t\tlinkElement.rel = \"stylesheet\";\r\n\t\tinsertStyleElement(options, linkElement);\r\n\t\treturn linkElement;\r\n\t}\r\n\t\r\n\tfunction addStyle(obj, options) {\r\n\t\tvar styleElement, update, remove;\r\n\t\r\n\t\tif (options.singleton) {\r\n\t\t\tvar styleIndex = singletonCounter++;\r\n\t\t\tstyleElement = singletonElement || (singletonElement = createStyleElement(options));\r\n\t\t\tupdate = applyToSingletonTag.bind(null, styleElement, styleIndex, false);\r\n\t\t\tremove = applyToSingletonTag.bind(null, styleElement, styleIndex, true);\r\n\t\t} else if(obj.sourceMap &&\r\n\t\t\ttypeof URL === \"function\" &&\r\n\t\t\ttypeof URL.createObjectURL === \"function\" &&\r\n\t\t\ttypeof URL.revokeObjectURL === \"function\" &&\r\n\t\t\ttypeof Blob === \"function\" &&\r\n\t\t\ttypeof btoa === \"function\") {\r\n\t\t\tstyleElement = createLinkElement(options);\r\n\t\t\tupdate = updateLink.bind(null, styleElement);\r\n\t\t\tremove = function() {\r\n\t\t\t\tremoveStyleElement(styleElement);\r\n\t\t\t\tif(styleElement.href)\r\n\t\t\t\t\tURL.revokeObjectURL(styleElement.href);\r\n\t\t\t};\r\n\t\t} else {\r\n\t\t\tstyleElement = createStyleElement(options);\r\n\t\t\tupdate = applyToTag.bind(null, styleElement);\r\n\t\t\tremove = function() {\r\n\t\t\t\tremoveStyleElement(styleElement);\r\n\t\t\t};\r\n\t\t}\r\n\t\r\n\t\tupdate(obj);\r\n\t\r\n\t\treturn function updateStyle(newObj) {\r\n\t\t\tif(newObj) {\r\n\t\t\t\tif(newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap)\r\n\t\t\t\t\treturn;\r\n\t\t\t\tupdate(obj = newObj);\r\n\t\t\t} else {\r\n\t\t\t\tremove();\r\n\t\t\t}\r\n\t\t};\r\n\t}\r\n\t\r\n\tvar replaceText = (function () {\r\n\t\tvar textStore = [];\r\n\t\r\n\t\treturn function (index, replacement) {\r\n\t\t\ttextStore[index] = replacement;\r\n\t\t\treturn textStore.filter(Boolean).join('\\n');\r\n\t\t};\r\n\t})();\r\n\t\r\n\tfunction applyToSingletonTag(styleElement, index, remove, obj) {\r\n\t\tvar css = remove ? \"\" : obj.css;\r\n\t\r\n\t\tif (styleElement.styleSheet) {\r\n\t\t\tstyleElement.styleSheet.cssText = replaceText(index, css);\r\n\t\t} else {\r\n\t\t\tvar cssNode = document.createTextNode(css);\r\n\t\t\tvar childNodes = styleElement.childNodes;\r\n\t\t\tif (childNodes[index]) styleElement.removeChild(childNodes[index]);\r\n\t\t\tif (childNodes.length) {\r\n\t\t\t\tstyleElement.insertBefore(cssNode, childNodes[index]);\r\n\t\t\t} else {\r\n\t\t\t\tstyleElement.appendChild(cssNode);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\r\n\tfunction applyToTag(styleElement, obj) {\r\n\t\tvar css = obj.css;\r\n\t\tvar media = obj.media;\r\n\t\r\n\t\tif(media) {\r\n\t\t\tstyleElement.setAttribute(\"media\", media)\r\n\t\t}\r\n\t\r\n\t\tif(styleElement.styleSheet) {\r\n\t\t\tstyleElement.styleSheet.cssText = css;\r\n\t\t} else {\r\n\t\t\twhile(styleElement.firstChild) {\r\n\t\t\t\tstyleElement.removeChild(styleElement.firstChild);\r\n\t\t\t}\r\n\t\t\tstyleElement.appendChild(document.createTextNode(css));\r\n\t\t}\r\n\t}\r\n\t\r\n\tfunction updateLink(linkElement, obj) {\r\n\t\tvar css = obj.css;\r\n\t\tvar sourceMap = obj.sourceMap;\r\n\t\r\n\t\tif(sourceMap) {\r\n\t\t\t// http://stackoverflow.com/a/26603875\r\n\t\t\tcss += \"\\n/*# sourceMappingURL=data:application/json;base64,\" + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + \" */\";\r\n\t\t}\r\n\t\r\n\t\tvar blob = new Blob([css], { type: \"text/css\" });\r\n\t\r\n\t\tvar oldSrc = linkElement.href;\r\n\t\r\n\t\tlinkElement.href = URL.createObjectURL(blob);\r\n\t\r\n\t\tif(oldSrc)\r\n\t\t\tURL.revokeObjectURL(oldSrc);\r\n\t}\r\n\n\n/***/ },\n/* 6 */\n/***/ function(module, exports) {\n\n\tmodule.exports = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAwAAAAMCAYAAABWdVznAAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH4AscDSwos9M4EwAAAKpJREFUKM+Vkb1tw2AMBe8JgtbIPhkg6pRJ3DhFtEbc2VtlDDnFuRHtT44DxK/izxHgI/GmTwCVUsXqXFDPTT8ASa5gkuqdK+iBeYV36kuS9wZE/QIm4AMYNg31rI5NbVSXdWi7ZwN0Td6pb7/YdqjyRzWAjmf1j5XGR2yZXu52HtdDXE336rzeeQIOSU7VTHJUX4FJ/QYGmk/v/zKt7gtqTQ8FJ9l8vH3YBcyruitYNxLiAAAAAElFTkSuQmCC\"\n\n/***/ },\n/* 7 */\n/***/ function(module, exports) {\n\n\tmodule.exports = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH4AscDSsfRC8L2wAAAoFJREFUSMetl79rU1EUxz/vtbVoKyV50KFaEREXKYlC01Ic3MRCl5gh6pApCCLi3+DQUKdS3cTBQREcHBSLFuOkEamJUIRIIES0oYg/ItW+NIm5Dt5bniU2977kwNnu935yzsm55zwLfQsCp4FTQAg4CAwAVWANWAGeAY+BImABAp9mAUeA64ArL9LxR8AU0OsHuhe4DHw3AG73eWDUBLofuNUB0OvPgeM60H3A3S5Blb8BjrVL70KXoU1P5C3T3gOc93l5zaDmva1SXDCFhsPhr4lEYgP4ramZkt0C8ldcNIWOj49/zufzPyqVSiOZTP40aLUt2wO8M4FGIpG1QqGwLoQQ9XrdjcViawb6Qwp81BBaLhaLv8Rfq8bj8bJBnQVwCcAGLuiKJiYmVkulkqug0Wh0FagblumBAt/wAd2cmZn5ZPCn8npBtdH9docnJyfLXuj09PRHy7KaPttvXYEftjm4sbS0VJVQsbi4mLdtu9nBo9JQ4HvtDjuO4y4vL9cUfHZ29qXnVTL1iqrxNR1BIBBwc7lcrdlsCiGESKVSGcuyGj7Ab9XMPasrUnAVeSqVem3bds0QfFv18aiJMBAI/JP2ubm5bH9/f9XgjnMKvBt4agJ3HMfNZDIK3kgkEq80ta5co7Ym0xnTWg0PD1fT6fRmNpv9EgqFPmjqFrZPpyE5M43gwWDQHRsbK2ue/wYcbrXYnexwx9J5o61Wy0AfcKWD/tzJbwKDO60/g8DVLsPvyEWjrQ3IyLuR9nlgxGTF7ZM1T/sEvpf9Ouj3S2IIiAJPNIErcr6PyDb978U61gPsAhzgBBAGDshovN9OL4CS3EYa7SLykwVrm9YbsZb9AUUpBP2ozu6MAAAAAElFTkSuQmCC\"\n\n/***/ },\n/* 8 */\n/***/ function(module, exports) {\n\n\tmodule.exports = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH4AscDSwGbwU13AAAAo5JREFUSMe1l89rE1EQxz+bWEFrKCq9pKmCSFqw1FhooMWDN5FCD5JLFXpKSRBF/wWPnizVm14EBcGDlIKgoJ48hoo/oFLSBFpbK81uNyVNGtqOl92yhNS894wDc/y+z87MmzezFup2CrgGXAUuAmeBE0ANWAO+Ae+BN8ASYAGCoVlAHHgEVL2DVHwOGAWOmEAjwB3A1gA2+jTQqwONAU//ARj0j8AlFWgP8KJNUN9zreARYKbN0P1A5E3THgZuahy4a/ARD5tduB5gUeWAeDy+nEqlVoC6QfSjXreA9xW3VMT9/f2r8/Pzq+Vy2Z6cnCwCdcuyRLPVDuw48F1FGIvFfm9sbNRFRFzXddPp9JIB/JwPvqCTrpGRkUqpVKqJiDiOU85kMrrw2wAhIKNbq6GhoYrjODUREdu2t7LZbF4D/toHPzZpk8HBwYrrugdwjcgX/TZ6ZdKjlmXtDwwMVGzb3vHTPjU1taRw27d88JzpAxEOh/ey2WxBPMvlcuVoNLqu8AYQBl6aQEOh0P7Y2NiyiOyIiOTz+e3h4eF1Be2mX+MHJmkOQguFQjWZTP5S1H/2Z+6EJnhvfHx8xYcWi8VaMplc09A/8/u4V6Omu6lU6qeI1AKRrml++IQPPga8UxH19fUti8i2X1ON9PpeBU4GJ9N1FWF3d7c7Ozu7ubCwUFG8SI0+ExwSAF3ezGwpjkQibiKRKBlAbeB8s8XuCuC0eRFofKOtZstAB3AP2PsP0CfeOnyodQL32wx/7i0aLa0TuNumtE8DUZ0Vt8Or+QdD4A/gRqv0/u1PostrtbeKwC/efI96bXrowSoWBo4Cp4HLQAI440VTBdaBr8AnoOiNxd1WEZlkwWrQBiNWsj9N1gQwvR+6JQAAAABJRU5ErkJggg==\"\n\n/***/ },\n/* 9 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar ItemBuilder = function () {\n\t    function ItemBuilder() {\n\t        _classCallCheck(this, ItemBuilder);\n\t    }\n\t\n\t    _createClass(ItemBuilder, [{\n\t        key: \"build\",\n\t        value: function build(item) {\n\t            var itemContainer = document.createElement('div');\n\t            itemContainer.appendChild(item.element);\n\t            this._attachEvents(itemContainer, item);\n\t            return itemContainer;\n\t        }\n\t    }, {\n\t        key: \"_attachEvents\",\n\t        value: function _attachEvents(itemContainer, item) {\n\t            var mc = new Hammer.Manager(itemContainer);\n\t            var pinch = new Hammer.Pinch();\n\t            var pan = new Hammer.Pan();\n\t            mc.add(pinch);\n\t            mc.add(pan);\n\t\n\t            var pinchStartW = 0;\n\t            var pinchStartH = 0;\n\t            var pinchStartX = 0;\n\t            var pinchStartY = 0;\n\t            var pinchStartPointerX = 0;\n\t            var pinchStartPointerY = 0;\n\t            var focusPoint = {};\n\t            var pinchOffset = 0;\n\t            var imageStartX = 0;\n\t            var imageStartY = 0;\n\t            var panStartX = 0;\n\t            var panStartY = 0;\n\t\n\t            mc.on(\"pinchstart\", function (e) {\n\t                pinchStartW = item.element.offsetWidth;\n\t                pinchStartH = item.element.offsetHeight;\n\t                pinchStartX = item.element.offsetLeft;\n\t                pinchStartY = item.element.offsetTop;\n\t                pinchStartPointerX = e.pointers[0].clientX;\n\t                pinchStartPointerY = e.pointers[0].clientY;\n\t                imageStartX = item.element.offsetLeft;\n\t                imageStartY = item.element.offsetTop;\n\t\n\t                var x1 = e.pointers[0].clientX;\n\t                var x2 = e.pointers[1].clientX;\n\t                var y1 = e.pointers[0].clientY;\n\t                var y2 = e.pointers[1].clientY;\n\t                focusPoint.x = x1 + (x2 - x1) / 2;\n\t                focusPoint.y = y1 + (y2 - y1) / 2;\n\t            });\n\t\n\t            var pinchFn = function pinchFn(e) {\n\t                item.resize(pinchStartW * e.scale, pinchStartH * e.scale, focusPoint, pinchStartX, pinchStartY, pinchOffset);\n\t            };\n\t\n\t            mc.on(\"pinchin\", pinchFn);\n\t            mc.on(\"pinchout\", pinchFn);\n\t            mc.on(\"panstart\", function (e) {\n\t                panStartX = e.pointers[0].clientX;\n\t                panStartY = e.pointers[0].clientY;\n\t                imageStartX = item.element.offsetLeft;\n\t                imageStartY = item.element.offsetTop;\n\t            });\n\t            mc.on(\"pinchmove\", function (e) {\n\t                pinchOffset = { x: e.pointers[0].clientX - pinchStartPointerX, y: e.pointers[0].clientY - pinchStartPointerY };\n\t                // this._moveImage(galleryImage, imageStartX - (startX - e.pointers[0].clientX) , imageStartY - (startY - e.pointers[0].clientY));\n\t            });\n\t            mc.on(\"panmove\", function (e) {\n\t                item.move(imageStartX - (panStartX - e.pointers[0].clientX), imageStartY - (panStartY - e.pointers[0].clientY));\n\t            });\n\t        }\n\t    }]);\n\t\n\t    return ItemBuilder;\n\t}();\n\t\n\t//Singleton export\n\t\n\t\n\texports.default = new ItemBuilder();\n\n/***/ },\n/* 10 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**\r\n\t                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Created by Kyle on 2016-11-28.\r\n\t                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */\n\t\n\tvar _ImageItem = __webpack_require__(11);\n\t\n\tvar _ImageItem2 = _interopRequireDefault(_ImageItem);\n\t\n\tvar _YouTubeItem = __webpack_require__(13);\n\t\n\tvar _YouTubeItem2 = _interopRequireDefault(_YouTubeItem);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar ItemFactory = function () {\n\t    function ItemFactory() {\n\t        _classCallCheck(this, ItemFactory);\n\t    }\n\t\n\t    _createClass(ItemFactory, [{\n\t        key: \"build\",\n\t        value: function build(itemStub) {\n\t            switch (itemStub.type) {\n\t                case \"image\":\n\t                    return new _ImageItem2.default(itemStub.title, itemStub.url);\n\t                    break;\n\t                case \"youtube\":\n\t                    return new _YouTubeItem2.default(itemStub.title, itemStub.video_id, itemStub.player_vars);\n\t                    break;\n\t                default:\n\t                    throw new TypeError(\"Item Stub Type is an invalid type!\");\n\t                    break;\n\t            }\n\t        }\n\t    }]);\n\t\n\t    return ItemFactory;\n\t}();\n\t\n\texports.default = new ItemFactory();\n\n/***/ },\n/* 11 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _GalleryItem2 = __webpack_require__(12);\n\t\n\tvar _GalleryItem3 = _interopRequireDefault(_GalleryItem2);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\t\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**\r\n\t                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Created by Kyle on 2016-11-28.\r\n\t                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */\n\t\n\t\n\tvar ImageItem = function (_GalleryItem) {\n\t    _inherits(ImageItem, _GalleryItem);\n\t\n\t    function ImageItem(title, url) {\n\t        _classCallCheck(this, ImageItem);\n\t\n\t        var _this = _possibleConstructorReturn(this, (ImageItem.__proto__ || Object.getPrototypeOf(ImageItem)).call(this, \"image\", title));\n\t\n\t        _this._url = url;\n\t\n\t        //Build Image\n\t        _this._element = document.createElement('img');\n\t        _this._element.onload = function (e) {\n\t            _this.reset();\n\t        };\n\t        _this._element.src = _this._url;\n\t        return _this;\n\t    }\n\t\n\t    _createClass(ImageItem, [{\n\t        key: \"onHidden\",\n\t        value: function onHidden() {\n\t            this.reset();\n\t        }\n\t    }, {\n\t        key: \"url\",\n\t        get: function get() {\n\t            return this._url;\n\t        }\n\t    }]);\n\t\n\t    return ImageItem;\n\t}(_GalleryItem3.default);\n\t\n\texports.default = ImageItem;\n\n/***/ },\n/* 12 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\t/**\r\n\t * Created by Kyle on 2016-11-28.\r\n\t */\n\tvar GalleryItem = function () {\n\t    function GalleryItem(type, title) {\n\t        _classCallCheck(this, GalleryItem);\n\t\n\t        this._type = type;\n\t        this._title = title;\n\t        this._element = null;\n\t    }\n\t\n\t    _createClass(GalleryItem, [{\n\t        key: \"resize\",\n\t        value: function resize(w, h, focusPoint, startX, startY, offset) {\n\t            var x = void 0;\n\t            var y = void 0;\n\t\n\t            //Constrain size\n\t            var displayAR = this.element.parentNode.offsetWidth / this.element.parentNode.offsetHeight;\n\t            var elementAR = this.element.offsetWidth / this.element.offsetHeight;\n\t\n\t            if (displayAR > elementAR && h < this.element.parentNode.offsetHeight) {\n\t                h = this.element.parentNode.offsetHeight;\n\t                w = this.element.offsetWidth;\n\t            } else if (displayAR < elementAR && w < this.element.parentNode.offsetWidth) {\n\t                h = this.element.offsetHeight;\n\t                w = this.element.parentNode.offsetWidth;\n\t            }\n\t\n\t            //Make sure it doesn't exceed original dimensions x2\n\t            if (h > this.element.parentNode.offsetHeight * 2 || w > this.element.parentNode.offsetWidth * 2) {\n\t                h = this.element.offsetHeight;\n\t                w = this.element.offsetWidth;\n\t            }\n\t            // console.log(focusPoint);\n\t            var scale = void 0;\n\t            if (displayAR > elementAR) {\n\t                scale = this.element.offsetHeight / this.element.parentNode.offsetHeight - 1;\n\t            } else {\n\t                scale = this.element.offsetWidth / this.element.parentNode.offsetWidth - 1;\n\t            }\n\t\n\t            //TODO: Redo focus point calculations to be more accurate\n\t            //Recenter image with new dimensions against focus point based on zoom level\n\t            var destination = { x: startX - focusPoint.x * 2, y: startY - focusPoint.y * 2 };\n\t\n\t            x = (startX + destination.x) * scale;\n\t            y = (startY + destination.y) * scale;\n\t\n\t            x += offset.x;\n\t            y += offset.y;\n\t\n\t            //Boundry Enforcement\n\t            if (h < this.element.parentNode.offsetHeight) {\n\t                y = (this.element.parentNode.offsetHeight - h) / 2;\n\t            } else if (h > this.element.parentNode.offsetHeight && y > 0) {\n\t                y = 0;\n\t            } else if (h > this.element.parentNode.offsetHeight && y < 0 - (h - this.element.parentNode.offsetHeight)) {\n\t                y = 0 - (h - this.element.parentNode.offsetHeight);\n\t            } else if (h === this.element.parentNode.offsetHeight) {\n\t                y = 0;\n\t            }\n\t\n\t            if (w < this.element.parentNode.offsetWidth) {\n\t                x = (this.element.parentNode.offsetWidth - w) / 2;\n\t            } else if (w > this.element.parentNode.offsetWidth && x > 0) {\n\t                x = 0;\n\t            } else if (w > this.element.parentNode.offsetWidth && x < 0 - (w - this.element.parentNode.offsetWidth)) {\n\t                x = 0 - (w - this.element.parentNode.offsetWidth);\n\t            } else if (w === this.element.parentNode.offsetWidth) {\n\t                x = 0;\n\t            }\n\t\n\t            this.element.style.display = \"none\";\n\t            this.element.style.top = Math.floor(y) + \"px\";\n\t            this.element.style.left = Math.floor(x) + \"px\";\n\t            this.element.style.width = Math.floor(w) + \"px\";\n\t            this.element.style.height = Math.floor(h) + \"px\";\n\t            this.element.style.display = \"block\";\n\t        }\n\t    }, {\n\t        key: \"move\",\n\t        value: function move(x, y) {\n\t            //Constrain movement...\n\t            if (this.element.offsetWidth > this.element.parentNode.offsetWidth) {\n\t                if (x > 0) {\n\t                    x = 0;\n\t                } else if (x < this.element.parentNode.offsetWidth - this.element.offsetWidth) {\n\t                    x = this.element.parentNode.offsetWidth - this.element.offsetWidth;\n\t                }\n\t            } else {\n\t                //Don't allow it to move\n\t                x = this.element.offsetLeft;\n\t            }\n\t\n\t            if (this.element.offsetHeight > this.element.parentNode.offsetHeight) {\n\t                if (y > 0) {\n\t                    y = 0;\n\t                } else if (y < this.element.parentNode.offsetHeight - this.element.offsetHeight) {\n\t                    y = this.element.parentNode.offsetHeight - this.element.offsetHeight;\n\t                }\n\t            } else {\n\t                y = this.element.offsetTop;\n\t            }\n\t\n\t            //Set finalized coordinates\n\t            this.element.style.left = x + \"px\";\n\t            this.element.style.top = y + \"px\";\n\t        }\n\t    }, {\n\t        key: \"reset\",\n\t        value: function reset() {\n\t            //Remove all dimensions styling to insure a fresh slate\n\t            this.element.style.removeProperty(\"height\");\n\t            this.element.style.removeProperty(\"width\");\n\t\n\t            //Compare Aspect Ratios and set the size of the element\n\t            var displayAR = this.element.parentNode.offsetWidth / this.element.parentNode.offsetHeight;\n\t            var imageAR = this.element.offsetWidth / this.element.offsetHeight;\n\t\n\t            if (displayAR > imageAR) {\n\t                this.element.style.top = \"0px\";\n\t                this.element.style.height = this.element.parentNode.offsetHeight + \"px\";\n\t                this.element.style.left = (this.element.parentNode.offsetWidth - this.element.offsetWidth) / 2 + \"px\";\n\t            } else if (displayAR < imageAR) {\n\t                this.element.style.left = \"0px\";\n\t                this.element.style.width = this.element.parentNode.offsetWidth + \"px\";\n\t                this.element.style.top = (this.element.parentNode.offsetHeight - this.element.offsetHeight) / 2 + \"px\";\n\t            } else {\n\t                this.element.style.top = \"0px\";\n\t                this.element.style.left = \"0px\";\n\t                this.element.style.height = this.element.parentNode.offsetHeight + \"px\";\n\t                this.element.style.width = this.element.parentNode.offsetWidth + \"px\";\n\t            }\n\t        }\n\t    }, {\n\t        key: \"onShown\",\n\t        value: function onShown() {\n\t            //Abstract Method for when Item is shown in gallery\n\t        }\n\t    }, {\n\t        key: \"onHidden\",\n\t        value: function onHidden() {\n\t            //Abstract Method for when Item is Hidden in Gallery\n\t        }\n\t    }, {\n\t        key: \"title\",\n\t        get: function get() {\n\t            return this._title;\n\t        }\n\t    }, {\n\t        key: \"type\",\n\t        get: function get() {\n\t            return this._type;\n\t        }\n\t    }, {\n\t        key: \"element\",\n\t        get: function get() {\n\t            return this._element;\n\t        }\n\t    }]);\n\t\n\t    return GalleryItem;\n\t}();\n\t\n\texports.default = GalleryItem;\n\n/***/ },\n/* 13 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _GalleryItem2 = __webpack_require__(12);\n\t\n\tvar _GalleryItem3 = _interopRequireDefault(_GalleryItem2);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\t\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**\r\n\t                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Created by Kyle on 2016-11-28.\r\n\t                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */\n\t\n\tvar YouTubeItem = function (_GalleryItem) {\n\t    _inherits(YouTubeItem, _GalleryItem);\n\t\n\t    function YouTubeItem(title, video_id, player_vars) {\n\t        _classCallCheck(this, YouTubeItem);\n\t\n\t        var _this = _possibleConstructorReturn(this, (YouTubeItem.__proto__ || Object.getPrototypeOf(YouTubeItem)).call(this, \"youtube\", title));\n\t\n\t        _this._element = document.createElement('iframe');\n\t        _this.element.setAttribute('id', \"player\");\n\t        _this.element.setAttribute('type', 'text/html');\n\t        _this.element.setAttribute('frameborder', '0');\n\t        var url = \"http://www.youtube.com/embed/\" + video_id + \"?enablejsapi=1\";\n\t        for (var i in player_vars) {\n\t            url += \"&\" + i + \"=\" + player_vars[i];\n\t        }\n\t        _this.element.setAttribute('src', url);\n\t        return _this;\n\t    }\n\t\n\t    _createClass(YouTubeItem, [{\n\t        key: \"reset\",\n\t        value: function reset() {\n\t            this.element.width = \"100%\";\n\t            this.element.height = \"100%\";\n\t        }\n\t    }, {\n\t        key: \"move\",\n\t        value: function move() {\n\t            return false;\n\t        }\n\t    }, {\n\t        key: \"resize\",\n\t        value: function resize() {\n\t            return false;\n\t        }\n\t    }, {\n\t        key: \"onHidden\",\n\t        value: function onHidden() {\n\t            this.element.contentWindow.postMessage('{\"event\":\"command\",\"func\":\"stopVideo\",\"args\":\"\"}', \"*\");\n\t        }\n\t    }]);\n\t\n\t    return YouTubeItem;\n\t}(_GalleryItem3.default);\n\t\n\texports.default = YouTubeItem;\n\n/***/ }\n/******/ ]);\n\n\n// WEBPACK FOOTER //\n// easy-gallery.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 3fb1c3b41d436bac17f7","import Hammer from \"hammerjs\";\r\nimport \"./Gallery.less\";\r\n\r\nimport FullScreenIcon from \"./assets/fullscreen.png\";\r\nimport BackNavIcon from \"./assets/back-nav.png\";\r\nimport ForwardNavIcon from \"./assets/forward-nav.png\";\r\nimport ItemBuilder from \"./items/ItemBuilder.js\";\r\nimport ItemFactory from \"./items/ItemFactory.js\";\r\n\r\nexport default class Gallery {\r\n    constructor (itemStubs) {\r\n        this._navigationStatus = null;\r\n        this._gallery = null;\r\n        this._galleryContentContainer = null;\r\n        this._itemTitle = null;\r\n        // this._content = content;\r\n        this._index = 0;\r\n        this._isFullscreen = false;\r\n        this._onKeyUp = this._onKeyUp.bind(this);\r\n        // this._images = [];\r\n        this._items = [];\r\n\r\n        window.addEventListener('resize', (e) => {\r\n            this._resetItems();\r\n        });\r\n\r\n        this._build(itemStubs);\r\n    }\r\n\r\n    get element () {\r\n        return this._gallery;\r\n    }\r\n\r\n    next () {\r\n        if (this._index < this._items.length - 1) {\r\n            this._index += 1;\r\n            this._onNavigation(this._items[this._index], this._items[this._index - 1]);\r\n        }\r\n    }\r\n\r\n    previous () {\r\n        if (this._index > 0) {\r\n            this._index -= 1;\r\n            this._onNavigation(this._items[this._index], this._items[this._index + 1]);\r\n        }\r\n    }\r\n\r\n    toggleFullscreen () {\r\n        this._gallery.classList.toggle(\"fullscreen\");\r\n        this._isFullscreen = !this._isFullscreen;\r\n        if (this._isFullscreen) {\r\n            document.body.addEventListener('keyup', this._onKeyUp);\r\n        } else {\r\n            document.body.removeEventListener('keyup', this._onKeyUp);\r\n        }\r\n\r\n        this._resetItems();\r\n    }\r\n\r\n    _build (itemStubs) {\r\n        let gallery = document.createElement('div');\r\n        this._gallery = gallery;\r\n        gallery.className = \"gallery\";\r\n\r\n        //Container for the Content (Images/Videos)\r\n        let galleryContentContainer = document.createElement('div');\r\n        this._galleryContentContainer = galleryContentContainer;\r\n        galleryContentContainer.className = \"gallery-content\";\r\n        gallery.appendChild(galleryContentContainer);\r\n\r\n        var mc = new Hammer.Manager(gallery);\r\n        var Swipe = new Hammer.Swipe();\r\n        var Pan = new Hammer.Pan();\r\n        mc.add(Swipe);\r\n        mc.add(Pan);\r\n        mc.on('panstart', (e) => {\r\n            console.log(e, \"start\");\r\n        })\r\n        mc.on('panleft', (e) =>\r\n        {\r\n            console.log(e, \"left\");\r\n            this.next();\r\n        });\r\n        mc.on('panright', (e) => {\r\n            console.log(e, \"right\")\r\n            this.previous();\r\n        });\r\n\r\n\r\n        //Add Content\r\n        for (var i in itemStubs) {\r\n            var item = ItemFactory.build(itemStubs[i]);\r\n            this._items.push(item);\r\n            galleryContentContainer.appendChild(ItemBuilder.build(item));\r\n        }\r\n\r\n        //Navigation Icons\r\n        let backNavIcon = document.createElement('img');\r\n        backNavIcon.className = \"back-nav-icon\";\r\n        backNavIcon.src = BackNavIcon;\r\n        gallery.appendChild(backNavIcon);\r\n\r\n        let mc1 = new Hammer.Manager(backNavIcon);\r\n        let Tap1 = new Hammer.Tap();\r\n        mc1.add(Tap1);\r\n        mc1.on('tap', (e) => {\r\n            this.previous();\r\n        });\r\n\r\n        let forwardNavIcon = document.createElement('img');\r\n        forwardNavIcon.className = \"forward-nav-icon\";\r\n        forwardNavIcon.src = ForwardNavIcon;\r\n        gallery.appendChild(forwardNavIcon);\r\n\r\n        let mc2 = new Hammer.Manager(forwardNavIcon);\r\n        let Tap2 = new Hammer.Tap();\r\n        mc2.add(Tap2);\r\n        mc2.on('tap', (e) => {\r\n            this.next();\r\n        });\r\n\r\n        //Status bar for status of _gallery navigation and icons for fullscreen, etc\r\n        let statusBar = document.createElement('div');\r\n        statusBar.className = \"status-bar\";\r\n        gallery.appendChild(statusBar);\r\n\r\n        //Navigation status\r\n        let navigationStatus = document.createElement('div');\r\n        navigationStatus.className = \"navigation-status\";\r\n        this._navigationStatus = navigationStatus;\r\n        statusBar.appendChild(navigationStatus);\r\n\r\n        //Full screen icon\r\n        let fullScreenIcon = document.createElement('img');\r\n        fullScreenIcon.className = \"fullscreen-icon\";\r\n        fullScreenIcon.src = FullScreenIcon;\r\n        statusBar.appendChild(fullScreenIcon);\r\n\r\n        //Item Title\r\n        let itemTitle = document.createElement('span');\r\n        this._itemTitle = itemTitle;\r\n        statusBar.appendChild(itemTitle);\r\n\r\n        let mc3 = new Hammer.Manager(fullScreenIcon);\r\n        let Tap3 = new Hammer.Tap();\r\n        mc3.add(Tap3);\r\n        mc3.on(\"tap\", (e) => {\r\n            //Toggle FullScreen\r\n            this.toggleFullscreen();\r\n        });\r\n\r\n        this._onNavigation(this._items[this._index]);\r\n\r\n        return gallery;\r\n    }\r\n\r\n    //Sets all the _images to initial proportions, to be called when fullscreen toggled or size of container changes\r\n    _resetItems() {\r\n        for (var i in this._items) {\r\n            this._items[i].reset();\r\n        }\r\n    }\r\n\r\n    _onNavigation (newItem, oldItem) {\r\n        if (oldItem) {\r\n            oldItem.onHidden();\r\n        }\r\n        newItem.onShown();\r\n\r\n        //Update Navigation Status Text to x/x\r\n        this._navigationStatus.innerHTML = (this._index + 1) + \"/\" + this._items.length;\r\n        //Move Container to appropriate item\r\n        this._galleryContentContainer.style.left = (((this._index) * 100) * -1) + \"%\";\r\n        //Show new items title in status bar\r\n        this._itemTitle.innerHTML = this._items[this._index].title || \"\";\r\n    }\r\n\r\n    _onKeyUp (e) {\r\n        switch (e.which) {\r\n            case 37:\r\n                //Left\r\n                this.previous();\r\n                break;\r\n            case 39:\r\n                //Right\r\n                this.next();\r\n                break;\r\n            case 27:\r\n                //Esp\r\n                this.toggleFullscreen();\r\n                break;\r\n        }\r\n    }\r\n}\r\n\r\nwindow.Gallery = Gallery;\r\nmodule.exports = Gallery;\n\n\n// WEBPACK FOOTER //\n// ./src/Gallery.js","/*! Hammer.JS - v2.0.7 - 2016-04-22\n * http://hammerjs.github.io/\n *\n * Copyright (c) 2016 Jorik Tangelder;\n * Licensed under the MIT license */\n(function(window, document, exportName, undefined) {\n  'use strict';\n\nvar VENDOR_PREFIXES = ['', 'webkit', 'Moz', 'MS', 'ms', 'o'];\nvar TEST_ELEMENT = document.createElement('div');\n\nvar TYPE_FUNCTION = 'function';\n\nvar round = Math.round;\nvar abs = Math.abs;\nvar now = Date.now;\n\n/**\n * set a timeout with a given scope\n * @param {Function} fn\n * @param {Number} timeout\n * @param {Object} context\n * @returns {number}\n */\nfunction setTimeoutContext(fn, timeout, context) {\n    return setTimeout(bindFn(fn, context), timeout);\n}\n\n/**\n * if the argument is an array, we want to execute the fn on each entry\n * if it aint an array we don't want to do a thing.\n * this is used by all the methods that accept a single and array argument.\n * @param {*|Array} arg\n * @param {String} fn\n * @param {Object} [context]\n * @returns {Boolean}\n */\nfunction invokeArrayArg(arg, fn, context) {\n    if (Array.isArray(arg)) {\n        each(arg, context[fn], context);\n        return true;\n    }\n    return false;\n}\n\n/**\n * walk objects and arrays\n * @param {Object} obj\n * @param {Function} iterator\n * @param {Object} context\n */\nfunction each(obj, iterator, context) {\n    var i;\n\n    if (!obj) {\n        return;\n    }\n\n    if (obj.forEach) {\n        obj.forEach(iterator, context);\n    } else if (obj.length !== undefined) {\n        i = 0;\n        while (i < obj.length) {\n            iterator.call(context, obj[i], i, obj);\n            i++;\n        }\n    } else {\n        for (i in obj) {\n            obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj);\n        }\n    }\n}\n\n/**\n * wrap a method with a deprecation warning and stack trace\n * @param {Function} method\n * @param {String} name\n * @param {String} message\n * @returns {Function} A new function wrapping the supplied method.\n */\nfunction deprecate(method, name, message) {\n    var deprecationMessage = 'DEPRECATED METHOD: ' + name + '\\n' + message + ' AT \\n';\n    return function() {\n        var e = new Error('get-stack-trace');\n        var stack = e && e.stack ? e.stack.replace(/^[^\\(]+?[\\n$]/gm, '')\n            .replace(/^\\s+at\\s+/gm, '')\n            .replace(/^Object.<anonymous>\\s*\\(/gm, '{anonymous}()@') : 'Unknown Stack Trace';\n\n        var log = window.console && (window.console.warn || window.console.log);\n        if (log) {\n            log.call(window.console, deprecationMessage, stack);\n        }\n        return method.apply(this, arguments);\n    };\n}\n\n/**\n * extend object.\n * means that properties in dest will be overwritten by the ones in src.\n * @param {Object} target\n * @param {...Object} objects_to_assign\n * @returns {Object} target\n */\nvar assign;\nif (typeof Object.assign !== 'function') {\n    assign = function assign(target) {\n        if (target === undefined || target === null) {\n            throw new TypeError('Cannot convert undefined or null to object');\n        }\n\n        var output = Object(target);\n        for (var index = 1; index < arguments.length; index++) {\n            var source = arguments[index];\n            if (source !== undefined && source !== null) {\n                for (var nextKey in source) {\n                    if (source.hasOwnProperty(nextKey)) {\n                        output[nextKey] = source[nextKey];\n                    }\n                }\n            }\n        }\n        return output;\n    };\n} else {\n    assign = Object.assign;\n}\n\n/**\n * extend object.\n * means that properties in dest will be overwritten by the ones in src.\n * @param {Object} dest\n * @param {Object} src\n * @param {Boolean} [merge=false]\n * @returns {Object} dest\n */\nvar extend = deprecate(function extend(dest, src, merge) {\n    var keys = Object.keys(src);\n    var i = 0;\n    while (i < keys.length) {\n        if (!merge || (merge && dest[keys[i]] === undefined)) {\n            dest[keys[i]] = src[keys[i]];\n        }\n        i++;\n    }\n    return dest;\n}, 'extend', 'Use `assign`.');\n\n/**\n * merge the values from src in the dest.\n * means that properties that exist in dest will not be overwritten by src\n * @param {Object} dest\n * @param {Object} src\n * @returns {Object} dest\n */\nvar merge = deprecate(function merge(dest, src) {\n    return extend(dest, src, true);\n}, 'merge', 'Use `assign`.');\n\n/**\n * simple class inheritance\n * @param {Function} child\n * @param {Function} base\n * @param {Object} [properties]\n */\nfunction inherit(child, base, properties) {\n    var baseP = base.prototype,\n        childP;\n\n    childP = child.prototype = Object.create(baseP);\n    childP.constructor = child;\n    childP._super = baseP;\n\n    if (properties) {\n        assign(childP, properties);\n    }\n}\n\n/**\n * simple function bind\n * @param {Function} fn\n * @param {Object} context\n * @returns {Function}\n */\nfunction bindFn(fn, context) {\n    return function boundFn() {\n        return fn.apply(context, arguments);\n    };\n}\n\n/**\n * let a boolean value also be a function that must return a boolean\n * this first item in args will be used as the context\n * @param {Boolean|Function} val\n * @param {Array} [args]\n * @returns {Boolean}\n */\nfunction boolOrFn(val, args) {\n    if (typeof val == TYPE_FUNCTION) {\n        return val.apply(args ? args[0] || undefined : undefined, args);\n    }\n    return val;\n}\n\n/**\n * use the val2 when val1 is undefined\n * @param {*} val1\n * @param {*} val2\n * @returns {*}\n */\nfunction ifUndefined(val1, val2) {\n    return (val1 === undefined) ? val2 : val1;\n}\n\n/**\n * addEventListener with multiple events at once\n * @param {EventTarget} target\n * @param {String} types\n * @param {Function} handler\n */\nfunction addEventListeners(target, types, handler) {\n    each(splitStr(types), function(type) {\n        target.addEventListener(type, handler, false);\n    });\n}\n\n/**\n * removeEventListener with multiple events at once\n * @param {EventTarget} target\n * @param {String} types\n * @param {Function} handler\n */\nfunction removeEventListeners(target, types, handler) {\n    each(splitStr(types), function(type) {\n        target.removeEventListener(type, handler, false);\n    });\n}\n\n/**\n * find if a node is in the given parent\n * @method hasParent\n * @param {HTMLElement} node\n * @param {HTMLElement} parent\n * @return {Boolean} found\n */\nfunction hasParent(node, parent) {\n    while (node) {\n        if (node == parent) {\n            return true;\n        }\n        node = node.parentNode;\n    }\n    return false;\n}\n\n/**\n * small indexOf wrapper\n * @param {String} str\n * @param {String} find\n * @returns {Boolean} found\n */\nfunction inStr(str, find) {\n    return str.indexOf(find) > -1;\n}\n\n/**\n * split string on whitespace\n * @param {String} str\n * @returns {Array} words\n */\nfunction splitStr(str) {\n    return str.trim().split(/\\s+/g);\n}\n\n/**\n * find if a array contains the object using indexOf or a simple polyFill\n * @param {Array} src\n * @param {String} find\n * @param {String} [findByKey]\n * @return {Boolean|Number} false when not found, or the index\n */\nfunction inArray(src, find, findByKey) {\n    if (src.indexOf && !findByKey) {\n        return src.indexOf(find);\n    } else {\n        var i = 0;\n        while (i < src.length) {\n            if ((findByKey && src[i][findByKey] == find) || (!findByKey && src[i] === find)) {\n                return i;\n            }\n            i++;\n        }\n        return -1;\n    }\n}\n\n/**\n * convert array-like objects to real arrays\n * @param {Object} obj\n * @returns {Array}\n */\nfunction toArray(obj) {\n    return Array.prototype.slice.call(obj, 0);\n}\n\n/**\n * unique array with objects based on a key (like 'id') or just by the array's value\n * @param {Array} src [{id:1},{id:2},{id:1}]\n * @param {String} [key]\n * @param {Boolean} [sort=False]\n * @returns {Array} [{id:1},{id:2}]\n */\nfunction uniqueArray(src, key, sort) {\n    var results = [];\n    var values = [];\n    var i = 0;\n\n    while (i < src.length) {\n        var val = key ? src[i][key] : src[i];\n        if (inArray(values, val) < 0) {\n            results.push(src[i]);\n        }\n        values[i] = val;\n        i++;\n    }\n\n    if (sort) {\n        if (!key) {\n            results = results.sort();\n        } else {\n            results = results.sort(function sortUniqueArray(a, b) {\n                return a[key] > b[key];\n            });\n        }\n    }\n\n    return results;\n}\n\n/**\n * get the prefixed property\n * @param {Object} obj\n * @param {String} property\n * @returns {String|Undefined} prefixed\n */\nfunction prefixed(obj, property) {\n    var prefix, prop;\n    var camelProp = property[0].toUpperCase() + property.slice(1);\n\n    var i = 0;\n    while (i < VENDOR_PREFIXES.length) {\n        prefix = VENDOR_PREFIXES[i];\n        prop = (prefix) ? prefix + camelProp : property;\n\n        if (prop in obj) {\n            return prop;\n        }\n        i++;\n    }\n    return undefined;\n}\n\n/**\n * get a unique id\n * @returns {number} uniqueId\n */\nvar _uniqueId = 1;\nfunction uniqueId() {\n    return _uniqueId++;\n}\n\n/**\n * get the window object of an element\n * @param {HTMLElement} element\n * @returns {DocumentView|Window}\n */\nfunction getWindowForElement(element) {\n    var doc = element.ownerDocument || element;\n    return (doc.defaultView || doc.parentWindow || window);\n}\n\nvar MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;\n\nvar SUPPORT_TOUCH = ('ontouchstart' in window);\nvar SUPPORT_POINTER_EVENTS = prefixed(window, 'PointerEvent') !== undefined;\nvar SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH && MOBILE_REGEX.test(navigator.userAgent);\n\nvar INPUT_TYPE_TOUCH = 'touch';\nvar INPUT_TYPE_PEN = 'pen';\nvar INPUT_TYPE_MOUSE = 'mouse';\nvar INPUT_TYPE_KINECT = 'kinect';\n\nvar COMPUTE_INTERVAL = 25;\n\nvar INPUT_START = 1;\nvar INPUT_MOVE = 2;\nvar INPUT_END = 4;\nvar INPUT_CANCEL = 8;\n\nvar DIRECTION_NONE = 1;\nvar DIRECTION_LEFT = 2;\nvar DIRECTION_RIGHT = 4;\nvar DIRECTION_UP = 8;\nvar DIRECTION_DOWN = 16;\n\nvar DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT;\nvar DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN;\nvar DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;\n\nvar PROPS_XY = ['x', 'y'];\nvar PROPS_CLIENT_XY = ['clientX', 'clientY'];\n\n/**\n * create new input type manager\n * @param {Manager} manager\n * @param {Function} callback\n * @returns {Input}\n * @constructor\n */\nfunction Input(manager, callback) {\n    var self = this;\n    this.manager = manager;\n    this.callback = callback;\n    this.element = manager.element;\n    this.target = manager.options.inputTarget;\n\n    // smaller wrapper around the handler, for the scope and the enabled state of the manager,\n    // so when disabled the input events are completely bypassed.\n    this.domHandler = function(ev) {\n        if (boolOrFn(manager.options.enable, [manager])) {\n            self.handler(ev);\n        }\n    };\n\n    this.init();\n\n}\n\nInput.prototype = {\n    /**\n     * should handle the inputEvent data and trigger the callback\n     * @virtual\n     */\n    handler: function() { },\n\n    /**\n     * bind the events\n     */\n    init: function() {\n        this.evEl && addEventListeners(this.element, this.evEl, this.domHandler);\n        this.evTarget && addEventListeners(this.target, this.evTarget, this.domHandler);\n        this.evWin && addEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);\n    },\n\n    /**\n     * unbind the events\n     */\n    destroy: function() {\n        this.evEl && removeEventListeners(this.element, this.evEl, this.domHandler);\n        this.evTarget && removeEventListeners(this.target, this.evTarget, this.domHandler);\n        this.evWin && removeEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);\n    }\n};\n\n/**\n * create new input type manager\n * called by the Manager constructor\n * @param {Hammer} manager\n * @returns {Input}\n */\nfunction createInputInstance(manager) {\n    var Type;\n    var inputClass = manager.options.inputClass;\n\n    if (inputClass) {\n        Type = inputClass;\n    } else if (SUPPORT_POINTER_EVENTS) {\n        Type = PointerEventInput;\n    } else if (SUPPORT_ONLY_TOUCH) {\n        Type = TouchInput;\n    } else if (!SUPPORT_TOUCH) {\n        Type = MouseInput;\n    } else {\n        Type = TouchMouseInput;\n    }\n    return new (Type)(manager, inputHandler);\n}\n\n/**\n * handle input events\n * @param {Manager} manager\n * @param {String} eventType\n * @param {Object} input\n */\nfunction inputHandler(manager, eventType, input) {\n    var pointersLen = input.pointers.length;\n    var changedPointersLen = input.changedPointers.length;\n    var isFirst = (eventType & INPUT_START && (pointersLen - changedPointersLen === 0));\n    var isFinal = (eventType & (INPUT_END | INPUT_CANCEL) && (pointersLen - changedPointersLen === 0));\n\n    input.isFirst = !!isFirst;\n    input.isFinal = !!isFinal;\n\n    if (isFirst) {\n        manager.session = {};\n    }\n\n    // source event is the normalized value of the domEvents\n    // like 'touchstart, mouseup, pointerdown'\n    input.eventType = eventType;\n\n    // compute scale, rotation etc\n    computeInputData(manager, input);\n\n    // emit secret event\n    manager.emit('hammer.input', input);\n\n    manager.recognize(input);\n    manager.session.prevInput = input;\n}\n\n/**\n * extend the data with some usable properties like scale, rotate, velocity etc\n * @param {Object} manager\n * @param {Object} input\n */\nfunction computeInputData(manager, input) {\n    var session = manager.session;\n    var pointers = input.pointers;\n    var pointersLength = pointers.length;\n\n    // store the first input to calculate the distance and direction\n    if (!session.firstInput) {\n        session.firstInput = simpleCloneInputData(input);\n    }\n\n    // to compute scale and rotation we need to store the multiple touches\n    if (pointersLength > 1 && !session.firstMultiple) {\n        session.firstMultiple = simpleCloneInputData(input);\n    } else if (pointersLength === 1) {\n        session.firstMultiple = false;\n    }\n\n    var firstInput = session.firstInput;\n    var firstMultiple = session.firstMultiple;\n    var offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;\n\n    var center = input.center = getCenter(pointers);\n    input.timeStamp = now();\n    input.deltaTime = input.timeStamp - firstInput.timeStamp;\n\n    input.angle = getAngle(offsetCenter, center);\n    input.distance = getDistance(offsetCenter, center);\n\n    computeDeltaXY(session, input);\n    input.offsetDirection = getDirection(input.deltaX, input.deltaY);\n\n    var overallVelocity = getVelocity(input.deltaTime, input.deltaX, input.deltaY);\n    input.overallVelocityX = overallVelocity.x;\n    input.overallVelocityY = overallVelocity.y;\n    input.overallVelocity = (abs(overallVelocity.x) > abs(overallVelocity.y)) ? overallVelocity.x : overallVelocity.y;\n\n    input.scale = firstMultiple ? getScale(firstMultiple.pointers, pointers) : 1;\n    input.rotation = firstMultiple ? getRotation(firstMultiple.pointers, pointers) : 0;\n\n    input.maxPointers = !session.prevInput ? input.pointers.length : ((input.pointers.length >\n        session.prevInput.maxPointers) ? input.pointers.length : session.prevInput.maxPointers);\n\n    computeIntervalInputData(session, input);\n\n    // find the correct target\n    var target = manager.element;\n    if (hasParent(input.srcEvent.target, target)) {\n        target = input.srcEvent.target;\n    }\n    input.target = target;\n}\n\nfunction computeDeltaXY(session, input) {\n    var center = input.center;\n    var offset = session.offsetDelta || {};\n    var prevDelta = session.prevDelta || {};\n    var prevInput = session.prevInput || {};\n\n    if (input.eventType === INPUT_START || prevInput.eventType === INPUT_END) {\n        prevDelta = session.prevDelta = {\n            x: prevInput.deltaX || 0,\n            y: prevInput.deltaY || 0\n        };\n\n        offset = session.offsetDelta = {\n            x: center.x,\n            y: center.y\n        };\n    }\n\n    input.deltaX = prevDelta.x + (center.x - offset.x);\n    input.deltaY = prevDelta.y + (center.y - offset.y);\n}\n\n/**\n * velocity is calculated every x ms\n * @param {Object} session\n * @param {Object} input\n */\nfunction computeIntervalInputData(session, input) {\n    var last = session.lastInterval || input,\n        deltaTime = input.timeStamp - last.timeStamp,\n        velocity, velocityX, velocityY, direction;\n\n    if (input.eventType != INPUT_CANCEL && (deltaTime > COMPUTE_INTERVAL || last.velocity === undefined)) {\n        var deltaX = input.deltaX - last.deltaX;\n        var deltaY = input.deltaY - last.deltaY;\n\n        var v = getVelocity(deltaTime, deltaX, deltaY);\n        velocityX = v.x;\n        velocityY = v.y;\n        velocity = (abs(v.x) > abs(v.y)) ? v.x : v.y;\n        direction = getDirection(deltaX, deltaY);\n\n        session.lastInterval = input;\n    } else {\n        // use latest velocity info if it doesn't overtake a minimum period\n        velocity = last.velocity;\n        velocityX = last.velocityX;\n        velocityY = last.velocityY;\n        direction = last.direction;\n    }\n\n    input.velocity = velocity;\n    input.velocityX = velocityX;\n    input.velocityY = velocityY;\n    input.direction = direction;\n}\n\n/**\n * create a simple clone from the input used for storage of firstInput and firstMultiple\n * @param {Object} input\n * @returns {Object} clonedInputData\n */\nfunction simpleCloneInputData(input) {\n    // make a simple copy of the pointers because we will get a reference if we don't\n    // we only need clientXY for the calculations\n    var pointers = [];\n    var i = 0;\n    while (i < input.pointers.length) {\n        pointers[i] = {\n            clientX: round(input.pointers[i].clientX),\n            clientY: round(input.pointers[i].clientY)\n        };\n        i++;\n    }\n\n    return {\n        timeStamp: now(),\n        pointers: pointers,\n        center: getCenter(pointers),\n        deltaX: input.deltaX,\n        deltaY: input.deltaY\n    };\n}\n\n/**\n * get the center of all the pointers\n * @param {Array} pointers\n * @return {Object} center contains `x` and `y` properties\n */\nfunction getCenter(pointers) {\n    var pointersLength = pointers.length;\n\n    // no need to loop when only one touch\n    if (pointersLength === 1) {\n        return {\n            x: round(pointers[0].clientX),\n            y: round(pointers[0].clientY)\n        };\n    }\n\n    var x = 0, y = 0, i = 0;\n    while (i < pointersLength) {\n        x += pointers[i].clientX;\n        y += pointers[i].clientY;\n        i++;\n    }\n\n    return {\n        x: round(x / pointersLength),\n        y: round(y / pointersLength)\n    };\n}\n\n/**\n * calculate the velocity between two points. unit is in px per ms.\n * @param {Number} deltaTime\n * @param {Number} x\n * @param {Number} y\n * @return {Object} velocity `x` and `y`\n */\nfunction getVelocity(deltaTime, x, y) {\n    return {\n        x: x / deltaTime || 0,\n        y: y / deltaTime || 0\n    };\n}\n\n/**\n * get the direction between two points\n * @param {Number} x\n * @param {Number} y\n * @return {Number} direction\n */\nfunction getDirection(x, y) {\n    if (x === y) {\n        return DIRECTION_NONE;\n    }\n\n    if (abs(x) >= abs(y)) {\n        return x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;\n    }\n    return y < 0 ? DIRECTION_UP : DIRECTION_DOWN;\n}\n\n/**\n * calculate the absolute distance between two points\n * @param {Object} p1 {x, y}\n * @param {Object} p2 {x, y}\n * @param {Array} [props] containing x and y keys\n * @return {Number} distance\n */\nfunction getDistance(p1, p2, props) {\n    if (!props) {\n        props = PROPS_XY;\n    }\n    var x = p2[props[0]] - p1[props[0]],\n        y = p2[props[1]] - p1[props[1]];\n\n    return Math.sqrt((x * x) + (y * y));\n}\n\n/**\n * calculate the angle between two coordinates\n * @param {Object} p1\n * @param {Object} p2\n * @param {Array} [props] containing x and y keys\n * @return {Number} angle\n */\nfunction getAngle(p1, p2, props) {\n    if (!props) {\n        props = PROPS_XY;\n    }\n    var x = p2[props[0]] - p1[props[0]],\n        y = p2[props[1]] - p1[props[1]];\n    return Math.atan2(y, x) * 180 / Math.PI;\n}\n\n/**\n * calculate the rotation degrees between two pointersets\n * @param {Array} start array of pointers\n * @param {Array} end array of pointers\n * @return {Number} rotation\n */\nfunction getRotation(start, end) {\n    return getAngle(end[1], end[0], PROPS_CLIENT_XY) + getAngle(start[1], start[0], PROPS_CLIENT_XY);\n}\n\n/**\n * calculate the scale factor between two pointersets\n * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out\n * @param {Array} start array of pointers\n * @param {Array} end array of pointers\n * @return {Number} scale\n */\nfunction getScale(start, end) {\n    return getDistance(end[0], end[1], PROPS_CLIENT_XY) / getDistance(start[0], start[1], PROPS_CLIENT_XY);\n}\n\nvar MOUSE_INPUT_MAP = {\n    mousedown: INPUT_START,\n    mousemove: INPUT_MOVE,\n    mouseup: INPUT_END\n};\n\nvar MOUSE_ELEMENT_EVENTS = 'mousedown';\nvar MOUSE_WINDOW_EVENTS = 'mousemove mouseup';\n\n/**\n * Mouse events input\n * @constructor\n * @extends Input\n */\nfunction MouseInput() {\n    this.evEl = MOUSE_ELEMENT_EVENTS;\n    this.evWin = MOUSE_WINDOW_EVENTS;\n\n    this.pressed = false; // mousedown state\n\n    Input.apply(this, arguments);\n}\n\ninherit(MouseInput, Input, {\n    /**\n     * handle mouse events\n     * @param {Object} ev\n     */\n    handler: function MEhandler(ev) {\n        var eventType = MOUSE_INPUT_MAP[ev.type];\n\n        // on start we want to have the left mouse button down\n        if (eventType & INPUT_START && ev.button === 0) {\n            this.pressed = true;\n        }\n\n        if (eventType & INPUT_MOVE && ev.which !== 1) {\n            eventType = INPUT_END;\n        }\n\n        // mouse must be down\n        if (!this.pressed) {\n            return;\n        }\n\n        if (eventType & INPUT_END) {\n            this.pressed = false;\n        }\n\n        this.callback(this.manager, eventType, {\n            pointers: [ev],\n            changedPointers: [ev],\n            pointerType: INPUT_TYPE_MOUSE,\n            srcEvent: ev\n        });\n    }\n});\n\nvar POINTER_INPUT_MAP = {\n    pointerdown: INPUT_START,\n    pointermove: INPUT_MOVE,\n    pointerup: INPUT_END,\n    pointercancel: INPUT_CANCEL,\n    pointerout: INPUT_CANCEL\n};\n\n// in IE10 the pointer types is defined as an enum\nvar IE10_POINTER_TYPE_ENUM = {\n    2: INPUT_TYPE_TOUCH,\n    3: INPUT_TYPE_PEN,\n    4: INPUT_TYPE_MOUSE,\n    5: INPUT_TYPE_KINECT // see https://twitter.com/jacobrossi/status/480596438489890816\n};\n\nvar POINTER_ELEMENT_EVENTS = 'pointerdown';\nvar POINTER_WINDOW_EVENTS = 'pointermove pointerup pointercancel';\n\n// IE10 has prefixed support, and case-sensitive\nif (window.MSPointerEvent && !window.PointerEvent) {\n    POINTER_ELEMENT_EVENTS = 'MSPointerDown';\n    POINTER_WINDOW_EVENTS = 'MSPointerMove MSPointerUp MSPointerCancel';\n}\n\n/**\n * Pointer events input\n * @constructor\n * @extends Input\n */\nfunction PointerEventInput() {\n    this.evEl = POINTER_ELEMENT_EVENTS;\n    this.evWin = POINTER_WINDOW_EVENTS;\n\n    Input.apply(this, arguments);\n\n    this.store = (this.manager.session.pointerEvents = []);\n}\n\ninherit(PointerEventInput, Input, {\n    /**\n     * handle mouse events\n     * @param {Object} ev\n     */\n    handler: function PEhandler(ev) {\n        var store = this.store;\n        var removePointer = false;\n\n        var eventTypeNormalized = ev.type.toLowerCase().replace('ms', '');\n        var eventType = POINTER_INPUT_MAP[eventTypeNormalized];\n        var pointerType = IE10_POINTER_TYPE_ENUM[ev.pointerType] || ev.pointerType;\n\n        var isTouch = (pointerType == INPUT_TYPE_TOUCH);\n\n        // get index of the event in the store\n        var storeIndex = inArray(store, ev.pointerId, 'pointerId');\n\n        // start and mouse must be down\n        if (eventType & INPUT_START && (ev.button === 0 || isTouch)) {\n            if (storeIndex < 0) {\n                store.push(ev);\n                storeIndex = store.length - 1;\n            }\n        } else if (eventType & (INPUT_END | INPUT_CANCEL)) {\n            removePointer = true;\n        }\n\n        // it not found, so the pointer hasn't been down (so it's probably a hover)\n        if (storeIndex < 0) {\n            return;\n        }\n\n        // update the event in the store\n        store[storeIndex] = ev;\n\n        this.callback(this.manager, eventType, {\n            pointers: store,\n            changedPointers: [ev],\n            pointerType: pointerType,\n            srcEvent: ev\n        });\n\n        if (removePointer) {\n            // remove from the store\n            store.splice(storeIndex, 1);\n        }\n    }\n});\n\nvar SINGLE_TOUCH_INPUT_MAP = {\n    touchstart: INPUT_START,\n    touchmove: INPUT_MOVE,\n    touchend: INPUT_END,\n    touchcancel: INPUT_CANCEL\n};\n\nvar SINGLE_TOUCH_TARGET_EVENTS = 'touchstart';\nvar SINGLE_TOUCH_WINDOW_EVENTS = 'touchstart touchmove touchend touchcancel';\n\n/**\n * Touch events input\n * @constructor\n * @extends Input\n */\nfunction SingleTouchInput() {\n    this.evTarget = SINGLE_TOUCH_TARGET_EVENTS;\n    this.evWin = SINGLE_TOUCH_WINDOW_EVENTS;\n    this.started = false;\n\n    Input.apply(this, arguments);\n}\n\ninherit(SingleTouchInput, Input, {\n    handler: function TEhandler(ev) {\n        var type = SINGLE_TOUCH_INPUT_MAP[ev.type];\n\n        // should we handle the touch events?\n        if (type === INPUT_START) {\n            this.started = true;\n        }\n\n        if (!this.started) {\n            return;\n        }\n\n        var touches = normalizeSingleTouches.call(this, ev, type);\n\n        // when done, reset the started state\n        if (type & (INPUT_END | INPUT_CANCEL) && touches[0].length - touches[1].length === 0) {\n            this.started = false;\n        }\n\n        this.callback(this.manager, type, {\n            pointers: touches[0],\n            changedPointers: touches[1],\n            pointerType: INPUT_TYPE_TOUCH,\n            srcEvent: ev\n        });\n    }\n});\n\n/**\n * @this {TouchInput}\n * @param {Object} ev\n * @param {Number} type flag\n * @returns {undefined|Array} [all, changed]\n */\nfunction normalizeSingleTouches(ev, type) {\n    var all = toArray(ev.touches);\n    var changed = toArray(ev.changedTouches);\n\n    if (type & (INPUT_END | INPUT_CANCEL)) {\n        all = uniqueArray(all.concat(changed), 'identifier', true);\n    }\n\n    return [all, changed];\n}\n\nvar TOUCH_INPUT_MAP = {\n    touchstart: INPUT_START,\n    touchmove: INPUT_MOVE,\n    touchend: INPUT_END,\n    touchcancel: INPUT_CANCEL\n};\n\nvar TOUCH_TARGET_EVENTS = 'touchstart touchmove touchend touchcancel';\n\n/**\n * Multi-user touch events input\n * @constructor\n * @extends Input\n */\nfunction TouchInput() {\n    this.evTarget = TOUCH_TARGET_EVENTS;\n    this.targetIds = {};\n\n    Input.apply(this, arguments);\n}\n\ninherit(TouchInput, Input, {\n    handler: function MTEhandler(ev) {\n        var type = TOUCH_INPUT_MAP[ev.type];\n        var touches = getTouches.call(this, ev, type);\n        if (!touches) {\n            return;\n        }\n\n        this.callback(this.manager, type, {\n            pointers: touches[0],\n            changedPointers: touches[1],\n            pointerType: INPUT_TYPE_TOUCH,\n            srcEvent: ev\n        });\n    }\n});\n\n/**\n * @this {TouchInput}\n * @param {Object} ev\n * @param {Number} type flag\n * @returns {undefined|Array} [all, changed]\n */\nfunction getTouches(ev, type) {\n    var allTouches = toArray(ev.touches);\n    var targetIds = this.targetIds;\n\n    // when there is only one touch, the process can be simplified\n    if (type & (INPUT_START | INPUT_MOVE) && allTouches.length === 1) {\n        targetIds[allTouches[0].identifier] = true;\n        return [allTouches, allTouches];\n    }\n\n    var i,\n        targetTouches,\n        changedTouches = toArray(ev.changedTouches),\n        changedTargetTouches = [],\n        target = this.target;\n\n    // get target touches from touches\n    targetTouches = allTouches.filter(function(touch) {\n        return hasParent(touch.target, target);\n    });\n\n    // collect touches\n    if (type === INPUT_START) {\n        i = 0;\n        while (i < targetTouches.length) {\n            targetIds[targetTouches[i].identifier] = true;\n            i++;\n        }\n    }\n\n    // filter changed touches to only contain touches that exist in the collected target ids\n    i = 0;\n    while (i < changedTouches.length) {\n        if (targetIds[changedTouches[i].identifier]) {\n            changedTargetTouches.push(changedTouches[i]);\n        }\n\n        // cleanup removed touches\n        if (type & (INPUT_END | INPUT_CANCEL)) {\n            delete targetIds[changedTouches[i].identifier];\n        }\n        i++;\n    }\n\n    if (!changedTargetTouches.length) {\n        return;\n    }\n\n    return [\n        // merge targetTouches with changedTargetTouches so it contains ALL touches, including 'end' and 'cancel'\n        uniqueArray(targetTouches.concat(changedTargetTouches), 'identifier', true),\n        changedTargetTouches\n    ];\n}\n\n/**\n * Combined touch and mouse input\n *\n * Touch has a higher priority then mouse, and while touching no mouse events are allowed.\n * This because touch devices also emit mouse events while doing a touch.\n *\n * @constructor\n * @extends Input\n */\n\nvar DEDUP_TIMEOUT = 2500;\nvar DEDUP_DISTANCE = 25;\n\nfunction TouchMouseInput() {\n    Input.apply(this, arguments);\n\n    var handler = bindFn(this.handler, this);\n    this.touch = new TouchInput(this.manager, handler);\n    this.mouse = new MouseInput(this.manager, handler);\n\n    this.primaryTouch = null;\n    this.lastTouches = [];\n}\n\ninherit(TouchMouseInput, Input, {\n    /**\n     * handle mouse and touch events\n     * @param {Hammer} manager\n     * @param {String} inputEvent\n     * @param {Object} inputData\n     */\n    handler: function TMEhandler(manager, inputEvent, inputData) {\n        var isTouch = (inputData.pointerType == INPUT_TYPE_TOUCH),\n            isMouse = (inputData.pointerType == INPUT_TYPE_MOUSE);\n\n        if (isMouse && inputData.sourceCapabilities && inputData.sourceCapabilities.firesTouchEvents) {\n            return;\n        }\n\n        // when we're in a touch event, record touches to  de-dupe synthetic mouse event\n        if (isTouch) {\n            recordTouches.call(this, inputEvent, inputData);\n        } else if (isMouse && isSyntheticEvent.call(this, inputData)) {\n            return;\n        }\n\n        this.callback(manager, inputEvent, inputData);\n    },\n\n    /**\n     * remove the event listeners\n     */\n    destroy: function destroy() {\n        this.touch.destroy();\n        this.mouse.destroy();\n    }\n});\n\nfunction recordTouches(eventType, eventData) {\n    if (eventType & INPUT_START) {\n        this.primaryTouch = eventData.changedPointers[0].identifier;\n        setLastTouch.call(this, eventData);\n    } else if (eventType & (INPUT_END | INPUT_CANCEL)) {\n        setLastTouch.call(this, eventData);\n    }\n}\n\nfunction setLastTouch(eventData) {\n    var touch = eventData.changedPointers[0];\n\n    if (touch.identifier === this.primaryTouch) {\n        var lastTouch = {x: touch.clientX, y: touch.clientY};\n        this.lastTouches.push(lastTouch);\n        var lts = this.lastTouches;\n        var removeLastTouch = function() {\n            var i = lts.indexOf(lastTouch);\n            if (i > -1) {\n                lts.splice(i, 1);\n            }\n        };\n        setTimeout(removeLastTouch, DEDUP_TIMEOUT);\n    }\n}\n\nfunction isSyntheticEvent(eventData) {\n    var x = eventData.srcEvent.clientX, y = eventData.srcEvent.clientY;\n    for (var i = 0; i < this.lastTouches.length; i++) {\n        var t = this.lastTouches[i];\n        var dx = Math.abs(x - t.x), dy = Math.abs(y - t.y);\n        if (dx <= DEDUP_DISTANCE && dy <= DEDUP_DISTANCE) {\n            return true;\n        }\n    }\n    return false;\n}\n\nvar PREFIXED_TOUCH_ACTION = prefixed(TEST_ELEMENT.style, 'touchAction');\nvar NATIVE_TOUCH_ACTION = PREFIXED_TOUCH_ACTION !== undefined;\n\n// magical touchAction value\nvar TOUCH_ACTION_COMPUTE = 'compute';\nvar TOUCH_ACTION_AUTO = 'auto';\nvar TOUCH_ACTION_MANIPULATION = 'manipulation'; // not implemented\nvar TOUCH_ACTION_NONE = 'none';\nvar TOUCH_ACTION_PAN_X = 'pan-x';\nvar TOUCH_ACTION_PAN_Y = 'pan-y';\nvar TOUCH_ACTION_MAP = getTouchActionProps();\n\n/**\n * Touch Action\n * sets the touchAction property or uses the js alternative\n * @param {Manager} manager\n * @param {String} value\n * @constructor\n */\nfunction TouchAction(manager, value) {\n    this.manager = manager;\n    this.set(value);\n}\n\nTouchAction.prototype = {\n    /**\n     * set the touchAction value on the element or enable the polyfill\n     * @param {String} value\n     */\n    set: function(value) {\n        // find out the touch-action by the event handlers\n        if (value == TOUCH_ACTION_COMPUTE) {\n            value = this.compute();\n        }\n\n        if (NATIVE_TOUCH_ACTION && this.manager.element.style && TOUCH_ACTION_MAP[value]) {\n            this.manager.element.style[PREFIXED_TOUCH_ACTION] = value;\n        }\n        this.actions = value.toLowerCase().trim();\n    },\n\n    /**\n     * just re-set the touchAction value\n     */\n    update: function() {\n        this.set(this.manager.options.touchAction);\n    },\n\n    /**\n     * compute the value for the touchAction property based on the recognizer's settings\n     * @returns {String} value\n     */\n    compute: function() {\n        var actions = [];\n        each(this.manager.recognizers, function(recognizer) {\n            if (boolOrFn(recognizer.options.enable, [recognizer])) {\n                actions = actions.concat(recognizer.getTouchAction());\n            }\n        });\n        return cleanTouchActions(actions.join(' '));\n    },\n\n    /**\n     * this method is called on each input cycle and provides the preventing of the browser behavior\n     * @param {Object} input\n     */\n    preventDefaults: function(input) {\n        var srcEvent = input.srcEvent;\n        var direction = input.offsetDirection;\n\n        // if the touch action did prevented once this session\n        if (this.manager.session.prevented) {\n            srcEvent.preventDefault();\n            return;\n        }\n\n        var actions = this.actions;\n        var hasNone = inStr(actions, TOUCH_ACTION_NONE) && !TOUCH_ACTION_MAP[TOUCH_ACTION_NONE];\n        var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_Y];\n        var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_X];\n\n        if (hasNone) {\n            //do not prevent defaults if this is a tap gesture\n\n            var isTapPointer = input.pointers.length === 1;\n            var isTapMovement = input.distance < 2;\n            var isTapTouchTime = input.deltaTime < 250;\n\n            if (isTapPointer && isTapMovement && isTapTouchTime) {\n                return;\n            }\n        }\n\n        if (hasPanX && hasPanY) {\n            // `pan-x pan-y` means browser handles all scrolling/panning, do not prevent\n            return;\n        }\n\n        if (hasNone ||\n            (hasPanY && direction & DIRECTION_HORIZONTAL) ||\n            (hasPanX && direction & DIRECTION_VERTICAL)) {\n            return this.preventSrc(srcEvent);\n        }\n    },\n\n    /**\n     * call preventDefault to prevent the browser's default behavior (scrolling in most cases)\n     * @param {Object} srcEvent\n     */\n    preventSrc: function(srcEvent) {\n        this.manager.session.prevented = true;\n        srcEvent.preventDefault();\n    }\n};\n\n/**\n * when the touchActions are collected they are not a valid value, so we need to clean things up. *\n * @param {String} actions\n * @returns {*}\n */\nfunction cleanTouchActions(actions) {\n    // none\n    if (inStr(actions, TOUCH_ACTION_NONE)) {\n        return TOUCH_ACTION_NONE;\n    }\n\n    var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);\n    var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);\n\n    // if both pan-x and pan-y are set (different recognizers\n    // for different directions, e.g. horizontal pan but vertical swipe?)\n    // we need none (as otherwise with pan-x pan-y combined none of these\n    // recognizers will work, since the browser would handle all panning\n    if (hasPanX && hasPanY) {\n        return TOUCH_ACTION_NONE;\n    }\n\n    // pan-x OR pan-y\n    if (hasPanX || hasPanY) {\n        return hasPanX ? TOUCH_ACTION_PAN_X : TOUCH_ACTION_PAN_Y;\n    }\n\n    // manipulation\n    if (inStr(actions, TOUCH_ACTION_MANIPULATION)) {\n        return TOUCH_ACTION_MANIPULATION;\n    }\n\n    return TOUCH_ACTION_AUTO;\n}\n\nfunction getTouchActionProps() {\n    if (!NATIVE_TOUCH_ACTION) {\n        return false;\n    }\n    var touchMap = {};\n    var cssSupports = window.CSS && window.CSS.supports;\n    ['auto', 'manipulation', 'pan-y', 'pan-x', 'pan-x pan-y', 'none'].forEach(function(val) {\n\n        // If css.supports is not supported but there is native touch-action assume it supports\n        // all values. This is the case for IE 10 and 11.\n        touchMap[val] = cssSupports ? window.CSS.supports('touch-action', val) : true;\n    });\n    return touchMap;\n}\n\n/**\n * Recognizer flow explained; *\n * All recognizers have the initial state of POSSIBLE when a input session starts.\n * The definition of a input session is from the first input until the last input, with all it's movement in it. *\n * Example session for mouse-input: mousedown -> mousemove -> mouseup\n *\n * On each recognizing cycle (see Manager.recognize) the .recognize() method is executed\n * which determines with state it should be.\n *\n * If the recognizer has the state FAILED, CANCELLED or RECOGNIZED (equals ENDED), it is reset to\n * POSSIBLE to give it another change on the next cycle.\n *\n *               Possible\n *                  |\n *            +-----+---------------+\n *            |                     |\n *      +-----+-----+               |\n *      |           |               |\n *   Failed      Cancelled          |\n *                          +-------+------+\n *                          |              |\n *                      Recognized       Began\n *                                         |\n *                                      Changed\n *                                         |\n *                                  Ended/Recognized\n */\nvar STATE_POSSIBLE = 1;\nvar STATE_BEGAN = 2;\nvar STATE_CHANGED = 4;\nvar STATE_ENDED = 8;\nvar STATE_RECOGNIZED = STATE_ENDED;\nvar STATE_CANCELLED = 16;\nvar STATE_FAILED = 32;\n\n/**\n * Recognizer\n * Every recognizer needs to extend from this class.\n * @constructor\n * @param {Object} options\n */\nfunction Recognizer(options) {\n    this.options = assign({}, this.defaults, options || {});\n\n    this.id = uniqueId();\n\n    this.manager = null;\n\n    // default is enable true\n    this.options.enable = ifUndefined(this.options.enable, true);\n\n    this.state = STATE_POSSIBLE;\n\n    this.simultaneous = {};\n    this.requireFail = [];\n}\n\nRecognizer.prototype = {\n    /**\n     * @virtual\n     * @type {Object}\n     */\n    defaults: {},\n\n    /**\n     * set options\n     * @param {Object} options\n     * @return {Recognizer}\n     */\n    set: function(options) {\n        assign(this.options, options);\n\n        // also update the touchAction, in case something changed about the directions/enabled state\n        this.manager && this.manager.touchAction.update();\n        return this;\n    },\n\n    /**\n     * recognize simultaneous with an other recognizer.\n     * @param {Recognizer} otherRecognizer\n     * @returns {Recognizer} this\n     */\n    recognizeWith: function(otherRecognizer) {\n        if (invokeArrayArg(otherRecognizer, 'recognizeWith', this)) {\n            return this;\n        }\n\n        var simultaneous = this.simultaneous;\n        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n        if (!simultaneous[otherRecognizer.id]) {\n            simultaneous[otherRecognizer.id] = otherRecognizer;\n            otherRecognizer.recognizeWith(this);\n        }\n        return this;\n    },\n\n    /**\n     * drop the simultaneous link. it doesnt remove the link on the other recognizer.\n     * @param {Recognizer} otherRecognizer\n     * @returns {Recognizer} this\n     */\n    dropRecognizeWith: function(otherRecognizer) {\n        if (invokeArrayArg(otherRecognizer, 'dropRecognizeWith', this)) {\n            return this;\n        }\n\n        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n        delete this.simultaneous[otherRecognizer.id];\n        return this;\n    },\n\n    /**\n     * recognizer can only run when an other is failing\n     * @param {Recognizer} otherRecognizer\n     * @returns {Recognizer} this\n     */\n    requireFailure: function(otherRecognizer) {\n        if (invokeArrayArg(otherRecognizer, 'requireFailure', this)) {\n            return this;\n        }\n\n        var requireFail = this.requireFail;\n        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n        if (inArray(requireFail, otherRecognizer) === -1) {\n            requireFail.push(otherRecognizer);\n            otherRecognizer.requireFailure(this);\n        }\n        return this;\n    },\n\n    /**\n     * drop the requireFailure link. it does not remove the link on the other recognizer.\n     * @param {Recognizer} otherRecognizer\n     * @returns {Recognizer} this\n     */\n    dropRequireFailure: function(otherRecognizer) {\n        if (invokeArrayArg(otherRecognizer, 'dropRequireFailure', this)) {\n            return this;\n        }\n\n        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n        var index = inArray(this.requireFail, otherRecognizer);\n        if (index > -1) {\n            this.requireFail.splice(index, 1);\n        }\n        return this;\n    },\n\n    /**\n     * has require failures boolean\n     * @returns {boolean}\n     */\n    hasRequireFailures: function() {\n        return this.requireFail.length > 0;\n    },\n\n    /**\n     * if the recognizer can recognize simultaneous with an other recognizer\n     * @param {Recognizer} otherRecognizer\n     * @returns {Boolean}\n     */\n    canRecognizeWith: function(otherRecognizer) {\n        return !!this.simultaneous[otherRecognizer.id];\n    },\n\n    /**\n     * You should use `tryEmit` instead of `emit` directly to check\n     * that all the needed recognizers has failed before emitting.\n     * @param {Object} input\n     */\n    emit: function(input) {\n        var self = this;\n        var state = this.state;\n\n        function emit(event) {\n            self.manager.emit(event, input);\n        }\n\n        // 'panstart' and 'panmove'\n        if (state < STATE_ENDED) {\n            emit(self.options.event + stateStr(state));\n        }\n\n        emit(self.options.event); // simple 'eventName' events\n\n        if (input.additionalEvent) { // additional event(panleft, panright, pinchin, pinchout...)\n            emit(input.additionalEvent);\n        }\n\n        // panend and pancancel\n        if (state >= STATE_ENDED) {\n            emit(self.options.event + stateStr(state));\n        }\n    },\n\n    /**\n     * Check that all the require failure recognizers has failed,\n     * if true, it emits a gesture event,\n     * otherwise, setup the state to FAILED.\n     * @param {Object} input\n     */\n    tryEmit: function(input) {\n        if (this.canEmit()) {\n            return this.emit(input);\n        }\n        // it's failing anyway\n        this.state = STATE_FAILED;\n    },\n\n    /**\n     * can we emit?\n     * @returns {boolean}\n     */\n    canEmit: function() {\n        var i = 0;\n        while (i < this.requireFail.length) {\n            if (!(this.requireFail[i].state & (STATE_FAILED | STATE_POSSIBLE))) {\n                return false;\n            }\n            i++;\n        }\n        return true;\n    },\n\n    /**\n     * update the recognizer\n     * @param {Object} inputData\n     */\n    recognize: function(inputData) {\n        // make a new copy of the inputData\n        // so we can change the inputData without messing up the other recognizers\n        var inputDataClone = assign({}, inputData);\n\n        // is is enabled and allow recognizing?\n        if (!boolOrFn(this.options.enable, [this, inputDataClone])) {\n            this.reset();\n            this.state = STATE_FAILED;\n            return;\n        }\n\n        // reset when we've reached the end\n        if (this.state & (STATE_RECOGNIZED | STATE_CANCELLED | STATE_FAILED)) {\n            this.state = STATE_POSSIBLE;\n        }\n\n        this.state = this.process(inputDataClone);\n\n        // the recognizer has recognized a gesture\n        // so trigger an event\n        if (this.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED | STATE_CANCELLED)) {\n            this.tryEmit(inputDataClone);\n        }\n    },\n\n    /**\n     * return the state of the recognizer\n     * the actual recognizing happens in this method\n     * @virtual\n     * @param {Object} inputData\n     * @returns {Const} STATE\n     */\n    process: function(inputData) { }, // jshint ignore:line\n\n    /**\n     * return the preferred touch-action\n     * @virtual\n     * @returns {Array}\n     */\n    getTouchAction: function() { },\n\n    /**\n     * called when the gesture isn't allowed to recognize\n     * like when another is being recognized or it is disabled\n     * @virtual\n     */\n    reset: function() { }\n};\n\n/**\n * get a usable string, used as event postfix\n * @param {Const} state\n * @returns {String} state\n */\nfunction stateStr(state) {\n    if (state & STATE_CANCELLED) {\n        return 'cancel';\n    } else if (state & STATE_ENDED) {\n        return 'end';\n    } else if (state & STATE_CHANGED) {\n        return 'move';\n    } else if (state & STATE_BEGAN) {\n        return 'start';\n    }\n    return '';\n}\n\n/**\n * direction cons to string\n * @param {Const} direction\n * @returns {String}\n */\nfunction directionStr(direction) {\n    if (direction == DIRECTION_DOWN) {\n        return 'down';\n    } else if (direction == DIRECTION_UP) {\n        return 'up';\n    } else if (direction == DIRECTION_LEFT) {\n        return 'left';\n    } else if (direction == DIRECTION_RIGHT) {\n        return 'right';\n    }\n    return '';\n}\n\n/**\n * get a recognizer by name if it is bound to a manager\n * @param {Recognizer|String} otherRecognizer\n * @param {Recognizer} recognizer\n * @returns {Recognizer}\n */\nfunction getRecognizerByNameIfManager(otherRecognizer, recognizer) {\n    var manager = recognizer.manager;\n    if (manager) {\n        return manager.get(otherRecognizer);\n    }\n    return otherRecognizer;\n}\n\n/**\n * This recognizer is just used as a base for the simple attribute recognizers.\n * @constructor\n * @extends Recognizer\n */\nfunction AttrRecognizer() {\n    Recognizer.apply(this, arguments);\n}\n\ninherit(AttrRecognizer, Recognizer, {\n    /**\n     * @namespace\n     * @memberof AttrRecognizer\n     */\n    defaults: {\n        /**\n         * @type {Number}\n         * @default 1\n         */\n        pointers: 1\n    },\n\n    /**\n     * Used to check if it the recognizer receives valid input, like input.distance > 10.\n     * @memberof AttrRecognizer\n     * @param {Object} input\n     * @returns {Boolean} recognized\n     */\n    attrTest: function(input) {\n        var optionPointers = this.options.pointers;\n        return optionPointers === 0 || input.pointers.length === optionPointers;\n    },\n\n    /**\n     * Process the input and return the state for the recognizer\n     * @memberof AttrRecognizer\n     * @param {Object} input\n     * @returns {*} State\n     */\n    process: function(input) {\n        var state = this.state;\n        var eventType = input.eventType;\n\n        var isRecognized = state & (STATE_BEGAN | STATE_CHANGED);\n        var isValid = this.attrTest(input);\n\n        // on cancel input and we've recognized before, return STATE_CANCELLED\n        if (isRecognized && (eventType & INPUT_CANCEL || !isValid)) {\n            return state | STATE_CANCELLED;\n        } else if (isRecognized || isValid) {\n            if (eventType & INPUT_END) {\n                return state | STATE_ENDED;\n            } else if (!(state & STATE_BEGAN)) {\n                return STATE_BEGAN;\n            }\n            return state | STATE_CHANGED;\n        }\n        return STATE_FAILED;\n    }\n});\n\n/**\n * Pan\n * Recognized when the pointer is down and moved in the allowed direction.\n * @constructor\n * @extends AttrRecognizer\n */\nfunction PanRecognizer() {\n    AttrRecognizer.apply(this, arguments);\n\n    this.pX = null;\n    this.pY = null;\n}\n\ninherit(PanRecognizer, AttrRecognizer, {\n    /**\n     * @namespace\n     * @memberof PanRecognizer\n     */\n    defaults: {\n        event: 'pan',\n        threshold: 10,\n        pointers: 1,\n        direction: DIRECTION_ALL\n    },\n\n    getTouchAction: function() {\n        var direction = this.options.direction;\n        var actions = [];\n        if (direction & DIRECTION_HORIZONTAL) {\n            actions.push(TOUCH_ACTION_PAN_Y);\n        }\n        if (direction & DIRECTION_VERTICAL) {\n            actions.push(TOUCH_ACTION_PAN_X);\n        }\n        return actions;\n    },\n\n    directionTest: function(input) {\n        var options = this.options;\n        var hasMoved = true;\n        var distance = input.distance;\n        var direction = input.direction;\n        var x = input.deltaX;\n        var y = input.deltaY;\n\n        // lock to axis?\n        if (!(direction & options.direction)) {\n            if (options.direction & DIRECTION_HORIZONTAL) {\n                direction = (x === 0) ? DIRECTION_NONE : (x < 0) ? DIRECTION_LEFT : DIRECTION_RIGHT;\n                hasMoved = x != this.pX;\n                distance = Math.abs(input.deltaX);\n            } else {\n                direction = (y === 0) ? DIRECTION_NONE : (y < 0) ? DIRECTION_UP : DIRECTION_DOWN;\n                hasMoved = y != this.pY;\n                distance = Math.abs(input.deltaY);\n            }\n        }\n        input.direction = direction;\n        return hasMoved && distance > options.threshold && direction & options.direction;\n    },\n\n    attrTest: function(input) {\n        return AttrRecognizer.prototype.attrTest.call(this, input) &&\n            (this.state & STATE_BEGAN || (!(this.state & STATE_BEGAN) && this.directionTest(input)));\n    },\n\n    emit: function(input) {\n\n        this.pX = input.deltaX;\n        this.pY = input.deltaY;\n\n        var direction = directionStr(input.direction);\n\n        if (direction) {\n            input.additionalEvent = this.options.event + direction;\n        }\n        this._super.emit.call(this, input);\n    }\n});\n\n/**\n * Pinch\n * Recognized when two or more pointers are moving toward (zoom-in) or away from each other (zoom-out).\n * @constructor\n * @extends AttrRecognizer\n */\nfunction PinchRecognizer() {\n    AttrRecognizer.apply(this, arguments);\n}\n\ninherit(PinchRecognizer, AttrRecognizer, {\n    /**\n     * @namespace\n     * @memberof PinchRecognizer\n     */\n    defaults: {\n        event: 'pinch',\n        threshold: 0,\n        pointers: 2\n    },\n\n    getTouchAction: function() {\n        return [TOUCH_ACTION_NONE];\n    },\n\n    attrTest: function(input) {\n        return this._super.attrTest.call(this, input) &&\n            (Math.abs(input.scale - 1) > this.options.threshold || this.state & STATE_BEGAN);\n    },\n\n    emit: function(input) {\n        if (input.scale !== 1) {\n            var inOut = input.scale < 1 ? 'in' : 'out';\n            input.additionalEvent = this.options.event + inOut;\n        }\n        this._super.emit.call(this, input);\n    }\n});\n\n/**\n * Press\n * Recognized when the pointer is down for x ms without any movement.\n * @constructor\n * @extends Recognizer\n */\nfunction PressRecognizer() {\n    Recognizer.apply(this, arguments);\n\n    this._timer = null;\n    this._input = null;\n}\n\ninherit(PressRecognizer, Recognizer, {\n    /**\n     * @namespace\n     * @memberof PressRecognizer\n     */\n    defaults: {\n        event: 'press',\n        pointers: 1,\n        time: 251, // minimal time of the pointer to be pressed\n        threshold: 9 // a minimal movement is ok, but keep it low\n    },\n\n    getTouchAction: function() {\n        return [TOUCH_ACTION_AUTO];\n    },\n\n    process: function(input) {\n        var options = this.options;\n        var validPointers = input.pointers.length === options.pointers;\n        var validMovement = input.distance < options.threshold;\n        var validTime = input.deltaTime > options.time;\n\n        this._input = input;\n\n        // we only allow little movement\n        // and we've reached an end event, so a tap is possible\n        if (!validMovement || !validPointers || (input.eventType & (INPUT_END | INPUT_CANCEL) && !validTime)) {\n            this.reset();\n        } else if (input.eventType & INPUT_START) {\n            this.reset();\n            this._timer = setTimeoutContext(function() {\n                this.state = STATE_RECOGNIZED;\n                this.tryEmit();\n            }, options.time, this);\n        } else if (input.eventType & INPUT_END) {\n            return STATE_RECOGNIZED;\n        }\n        return STATE_FAILED;\n    },\n\n    reset: function() {\n        clearTimeout(this._timer);\n    },\n\n    emit: function(input) {\n        if (this.state !== STATE_RECOGNIZED) {\n            return;\n        }\n\n        if (input && (input.eventType & INPUT_END)) {\n            this.manager.emit(this.options.event + 'up', input);\n        } else {\n            this._input.timeStamp = now();\n            this.manager.emit(this.options.event, this._input);\n        }\n    }\n});\n\n/**\n * Rotate\n * Recognized when two or more pointer are moving in a circular motion.\n * @constructor\n * @extends AttrRecognizer\n */\nfunction RotateRecognizer() {\n    AttrRecognizer.apply(this, arguments);\n}\n\ninherit(RotateRecognizer, AttrRecognizer, {\n    /**\n     * @namespace\n     * @memberof RotateRecognizer\n     */\n    defaults: {\n        event: 'rotate',\n        threshold: 0,\n        pointers: 2\n    },\n\n    getTouchAction: function() {\n        return [TOUCH_ACTION_NONE];\n    },\n\n    attrTest: function(input) {\n        return this._super.attrTest.call(this, input) &&\n            (Math.abs(input.rotation) > this.options.threshold || this.state & STATE_BEGAN);\n    }\n});\n\n/**\n * Swipe\n * Recognized when the pointer is moving fast (velocity), with enough distance in the allowed direction.\n * @constructor\n * @extends AttrRecognizer\n */\nfunction SwipeRecognizer() {\n    AttrRecognizer.apply(this, arguments);\n}\n\ninherit(SwipeRecognizer, AttrRecognizer, {\n    /**\n     * @namespace\n     * @memberof SwipeRecognizer\n     */\n    defaults: {\n        event: 'swipe',\n        threshold: 10,\n        velocity: 0.3,\n        direction: DIRECTION_HORIZONTAL | DIRECTION_VERTICAL,\n        pointers: 1\n    },\n\n    getTouchAction: function() {\n        return PanRecognizer.prototype.getTouchAction.call(this);\n    },\n\n    attrTest: function(input) {\n        var direction = this.options.direction;\n        var velocity;\n\n        if (direction & (DIRECTION_HORIZONTAL | DIRECTION_VERTICAL)) {\n            velocity = input.overallVelocity;\n        } else if (direction & DIRECTION_HORIZONTAL) {\n            velocity = input.overallVelocityX;\n        } else if (direction & DIRECTION_VERTICAL) {\n            velocity = input.overallVelocityY;\n        }\n\n        return this._super.attrTest.call(this, input) &&\n            direction & input.offsetDirection &&\n            input.distance > this.options.threshold &&\n            input.maxPointers == this.options.pointers &&\n            abs(velocity) > this.options.velocity && input.eventType & INPUT_END;\n    },\n\n    emit: function(input) {\n        var direction = directionStr(input.offsetDirection);\n        if (direction) {\n            this.manager.emit(this.options.event + direction, input);\n        }\n\n        this.manager.emit(this.options.event, input);\n    }\n});\n\n/**\n * A tap is ecognized when the pointer is doing a small tap/click. Multiple taps are recognized if they occur\n * between the given interval and position. The delay option can be used to recognize multi-taps without firing\n * a single tap.\n *\n * The eventData from the emitted event contains the property `tapCount`, which contains the amount of\n * multi-taps being recognized.\n * @constructor\n * @extends Recognizer\n */\nfunction TapRecognizer() {\n    Recognizer.apply(this, arguments);\n\n    // previous time and center,\n    // used for tap counting\n    this.pTime = false;\n    this.pCenter = false;\n\n    this._timer = null;\n    this._input = null;\n    this.count = 0;\n}\n\ninherit(TapRecognizer, Recognizer, {\n    /**\n     * @namespace\n     * @memberof PinchRecognizer\n     */\n    defaults: {\n        event: 'tap',\n        pointers: 1,\n        taps: 1,\n        interval: 300, // max time between the multi-tap taps\n        time: 250, // max time of the pointer to be down (like finger on the screen)\n        threshold: 9, // a minimal movement is ok, but keep it low\n        posThreshold: 10 // a multi-tap can be a bit off the initial position\n    },\n\n    getTouchAction: function() {\n        return [TOUCH_ACTION_MANIPULATION];\n    },\n\n    process: function(input) {\n        var options = this.options;\n\n        var validPointers = input.pointers.length === options.pointers;\n        var validMovement = input.distance < options.threshold;\n        var validTouchTime = input.deltaTime < options.time;\n\n        this.reset();\n\n        if ((input.eventType & INPUT_START) && (this.count === 0)) {\n            return this.failTimeout();\n        }\n\n        // we only allow little movement\n        // and we've reached an end event, so a tap is possible\n        if (validMovement && validTouchTime && validPointers) {\n            if (input.eventType != INPUT_END) {\n                return this.failTimeout();\n            }\n\n            var validInterval = this.pTime ? (input.timeStamp - this.pTime < options.interval) : true;\n            var validMultiTap = !this.pCenter || getDistance(this.pCenter, input.center) < options.posThreshold;\n\n            this.pTime = input.timeStamp;\n            this.pCenter = input.center;\n\n            if (!validMultiTap || !validInterval) {\n                this.count = 1;\n            } else {\n                this.count += 1;\n            }\n\n            this._input = input;\n\n            // if tap count matches we have recognized it,\n            // else it has began recognizing...\n            var tapCount = this.count % options.taps;\n            if (tapCount === 0) {\n                // no failing requirements, immediately trigger the tap event\n                // or wait as long as the multitap interval to trigger\n                if (!this.hasRequireFailures()) {\n                    return STATE_RECOGNIZED;\n                } else {\n                    this._timer = setTimeoutContext(function() {\n                        this.state = STATE_RECOGNIZED;\n                        this.tryEmit();\n                    }, options.interval, this);\n                    return STATE_BEGAN;\n                }\n            }\n        }\n        return STATE_FAILED;\n    },\n\n    failTimeout: function() {\n        this._timer = setTimeoutContext(function() {\n            this.state = STATE_FAILED;\n        }, this.options.interval, this);\n        return STATE_FAILED;\n    },\n\n    reset: function() {\n        clearTimeout(this._timer);\n    },\n\n    emit: function() {\n        if (this.state == STATE_RECOGNIZED) {\n            this._input.tapCount = this.count;\n            this.manager.emit(this.options.event, this._input);\n        }\n    }\n});\n\n/**\n * Simple way to create a manager with a default set of recognizers.\n * @param {HTMLElement} element\n * @param {Object} [options]\n * @constructor\n */\nfunction Hammer(element, options) {\n    options = options || {};\n    options.recognizers = ifUndefined(options.recognizers, Hammer.defaults.preset);\n    return new Manager(element, options);\n}\n\n/**\n * @const {string}\n */\nHammer.VERSION = '2.0.7';\n\n/**\n * default settings\n * @namespace\n */\nHammer.defaults = {\n    /**\n     * set if DOM events are being triggered.\n     * But this is slower and unused by simple implementations, so disabled by default.\n     * @type {Boolean}\n     * @default false\n     */\n    domEvents: false,\n\n    /**\n     * The value for the touchAction property/fallback.\n     * When set to `compute` it will magically set the correct value based on the added recognizers.\n     * @type {String}\n     * @default compute\n     */\n    touchAction: TOUCH_ACTION_COMPUTE,\n\n    /**\n     * @type {Boolean}\n     * @default true\n     */\n    enable: true,\n\n    /**\n     * EXPERIMENTAL FEATURE -- can be removed/changed\n     * Change the parent input target element.\n     * If Null, then it is being set the to main element.\n     * @type {Null|EventTarget}\n     * @default null\n     */\n    inputTarget: null,\n\n    /**\n     * force an input class\n     * @type {Null|Function}\n     * @default null\n     */\n    inputClass: null,\n\n    /**\n     * Default recognizer setup when calling `Hammer()`\n     * When creating a new Manager these will be skipped.\n     * @type {Array}\n     */\n    preset: [\n        // RecognizerClass, options, [recognizeWith, ...], [requireFailure, ...]\n        [RotateRecognizer, {enable: false}],\n        [PinchRecognizer, {enable: false}, ['rotate']],\n        [SwipeRecognizer, {direction: DIRECTION_HORIZONTAL}],\n        [PanRecognizer, {direction: DIRECTION_HORIZONTAL}, ['swipe']],\n        [TapRecognizer],\n        [TapRecognizer, {event: 'doubletap', taps: 2}, ['tap']],\n        [PressRecognizer]\n    ],\n\n    /**\n     * Some CSS properties can be used to improve the working of Hammer.\n     * Add them to this method and they will be set when creating a new Manager.\n     * @namespace\n     */\n    cssProps: {\n        /**\n         * Disables text selection to improve the dragging gesture. Mainly for desktop browsers.\n         * @type {String}\n         * @default 'none'\n         */\n        userSelect: 'none',\n\n        /**\n         * Disable the Windows Phone grippers when pressing an element.\n         * @type {String}\n         * @default 'none'\n         */\n        touchSelect: 'none',\n\n        /**\n         * Disables the default callout shown when you touch and hold a touch target.\n         * On iOS, when you touch and hold a touch target such as a link, Safari displays\n         * a callout containing information about the link. This property allows you to disable that callout.\n         * @type {String}\n         * @default 'none'\n         */\n        touchCallout: 'none',\n\n        /**\n         * Specifies whether zooming is enabled. Used by IE10>\n         * @type {String}\n         * @default 'none'\n         */\n        contentZooming: 'none',\n\n        /**\n         * Specifies that an entire element should be draggable instead of its contents. Mainly for desktop browsers.\n         * @type {String}\n         * @default 'none'\n         */\n        userDrag: 'none',\n\n        /**\n         * Overrides the highlight color shown when the user taps a link or a JavaScript\n         * clickable element in iOS. This property obeys the alpha value, if specified.\n         * @type {String}\n         * @default 'rgba(0,0,0,0)'\n         */\n        tapHighlightColor: 'rgba(0,0,0,0)'\n    }\n};\n\nvar STOP = 1;\nvar FORCED_STOP = 2;\n\n/**\n * Manager\n * @param {HTMLElement} element\n * @param {Object} [options]\n * @constructor\n */\nfunction Manager(element, options) {\n    this.options = assign({}, Hammer.defaults, options || {});\n\n    this.options.inputTarget = this.options.inputTarget || element;\n\n    this.handlers = {};\n    this.session = {};\n    this.recognizers = [];\n    this.oldCssProps = {};\n\n    this.element = element;\n    this.input = createInputInstance(this);\n    this.touchAction = new TouchAction(this, this.options.touchAction);\n\n    toggleCssProps(this, true);\n\n    each(this.options.recognizers, function(item) {\n        var recognizer = this.add(new (item[0])(item[1]));\n        item[2] && recognizer.recognizeWith(item[2]);\n        item[3] && recognizer.requireFailure(item[3]);\n    }, this);\n}\n\nManager.prototype = {\n    /**\n     * set options\n     * @param {Object} options\n     * @returns {Manager}\n     */\n    set: function(options) {\n        assign(this.options, options);\n\n        // Options that need a little more setup\n        if (options.touchAction) {\n            this.touchAction.update();\n        }\n        if (options.inputTarget) {\n            // Clean up existing event listeners and reinitialize\n            this.input.destroy();\n            this.input.target = options.inputTarget;\n            this.input.init();\n        }\n        return this;\n    },\n\n    /**\n     * stop recognizing for this session.\n     * This session will be discarded, when a new [input]start event is fired.\n     * When forced, the recognizer cycle is stopped immediately.\n     * @param {Boolean} [force]\n     */\n    stop: function(force) {\n        this.session.stopped = force ? FORCED_STOP : STOP;\n    },\n\n    /**\n     * run the recognizers!\n     * called by the inputHandler function on every movement of the pointers (touches)\n     * it walks through all the recognizers and tries to detect the gesture that is being made\n     * @param {Object} inputData\n     */\n    recognize: function(inputData) {\n        var session = this.session;\n        if (session.stopped) {\n            return;\n        }\n\n        // run the touch-action polyfill\n        this.touchAction.preventDefaults(inputData);\n\n        var recognizer;\n        var recognizers = this.recognizers;\n\n        // this holds the recognizer that is being recognized.\n        // so the recognizer's state needs to be BEGAN, CHANGED, ENDED or RECOGNIZED\n        // if no recognizer is detecting a thing, it is set to `null`\n        var curRecognizer = session.curRecognizer;\n\n        // reset when the last recognizer is recognized\n        // or when we're in a new session\n        if (!curRecognizer || (curRecognizer && curRecognizer.state & STATE_RECOGNIZED)) {\n            curRecognizer = session.curRecognizer = null;\n        }\n\n        var i = 0;\n        while (i < recognizers.length) {\n            recognizer = recognizers[i];\n\n            // find out if we are allowed try to recognize the input for this one.\n            // 1.   allow if the session is NOT forced stopped (see the .stop() method)\n            // 2.   allow if we still haven't recognized a gesture in this session, or the this recognizer is the one\n            //      that is being recognized.\n            // 3.   allow if the recognizer is allowed to run simultaneous with the current recognized recognizer.\n            //      this can be setup with the `recognizeWith()` method on the recognizer.\n            if (session.stopped !== FORCED_STOP && ( // 1\n                    !curRecognizer || recognizer == curRecognizer || // 2\n                    recognizer.canRecognizeWith(curRecognizer))) { // 3\n                recognizer.recognize(inputData);\n            } else {\n                recognizer.reset();\n            }\n\n            // if the recognizer has been recognizing the input as a valid gesture, we want to store this one as the\n            // current active recognizer. but only if we don't already have an active recognizer\n            if (!curRecognizer && recognizer.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED)) {\n                curRecognizer = session.curRecognizer = recognizer;\n            }\n            i++;\n        }\n    },\n\n    /**\n     * get a recognizer by its event name.\n     * @param {Recognizer|String} recognizer\n     * @returns {Recognizer|Null}\n     */\n    get: function(recognizer) {\n        if (recognizer instanceof Recognizer) {\n            return recognizer;\n        }\n\n        var recognizers = this.recognizers;\n        for (var i = 0; i < recognizers.length; i++) {\n            if (recognizers[i].options.event == recognizer) {\n                return recognizers[i];\n            }\n        }\n        return null;\n    },\n\n    /**\n     * add a recognizer to the manager\n     * existing recognizers with the same event name will be removed\n     * @param {Recognizer} recognizer\n     * @returns {Recognizer|Manager}\n     */\n    add: function(recognizer) {\n        if (invokeArrayArg(recognizer, 'add', this)) {\n            return this;\n        }\n\n        // remove existing\n        var existing = this.get(recognizer.options.event);\n        if (existing) {\n            this.remove(existing);\n        }\n\n        this.recognizers.push(recognizer);\n        recognizer.manager = this;\n\n        this.touchAction.update();\n        return recognizer;\n    },\n\n    /**\n     * remove a recognizer by name or instance\n     * @param {Recognizer|String} recognizer\n     * @returns {Manager}\n     */\n    remove: function(recognizer) {\n        if (invokeArrayArg(recognizer, 'remove', this)) {\n            return this;\n        }\n\n        recognizer = this.get(recognizer);\n\n        // let's make sure this recognizer exists\n        if (recognizer) {\n            var recognizers = this.recognizers;\n            var index = inArray(recognizers, recognizer);\n\n            if (index !== -1) {\n                recognizers.splice(index, 1);\n                this.touchAction.update();\n            }\n        }\n\n        return this;\n    },\n\n    /**\n     * bind event\n     * @param {String} events\n     * @param {Function} handler\n     * @returns {EventEmitter} this\n     */\n    on: function(events, handler) {\n        if (events === undefined) {\n            return;\n        }\n        if (handler === undefined) {\n            return;\n        }\n\n        var handlers = this.handlers;\n        each(splitStr(events), function(event) {\n            handlers[event] = handlers[event] || [];\n            handlers[event].push(handler);\n        });\n        return this;\n    },\n\n    /**\n     * unbind event, leave emit blank to remove all handlers\n     * @param {String} events\n     * @param {Function} [handler]\n     * @returns {EventEmitter} this\n     */\n    off: function(events, handler) {\n        if (events === undefined) {\n            return;\n        }\n\n        var handlers = this.handlers;\n        each(splitStr(events), function(event) {\n            if (!handler) {\n                delete handlers[event];\n            } else {\n                handlers[event] && handlers[event].splice(inArray(handlers[event], handler), 1);\n            }\n        });\n        return this;\n    },\n\n    /**\n     * emit event to the listeners\n     * @param {String} event\n     * @param {Object} data\n     */\n    emit: function(event, data) {\n        // we also want to trigger dom events\n        if (this.options.domEvents) {\n            triggerDomEvent(event, data);\n        }\n\n        // no handlers, so skip it all\n        var handlers = this.handlers[event] && this.handlers[event].slice();\n        if (!handlers || !handlers.length) {\n            return;\n        }\n\n        data.type = event;\n        data.preventDefault = function() {\n            data.srcEvent.preventDefault();\n        };\n\n        var i = 0;\n        while (i < handlers.length) {\n            handlers[i](data);\n            i++;\n        }\n    },\n\n    /**\n     * destroy the manager and unbinds all events\n     * it doesn't unbind dom events, that is the user own responsibility\n     */\n    destroy: function() {\n        this.element && toggleCssProps(this, false);\n\n        this.handlers = {};\n        this.session = {};\n        this.input.destroy();\n        this.element = null;\n    }\n};\n\n/**\n * add/remove the css properties as defined in manager.options.cssProps\n * @param {Manager} manager\n * @param {Boolean} add\n */\nfunction toggleCssProps(manager, add) {\n    var element = manager.element;\n    if (!element.style) {\n        return;\n    }\n    var prop;\n    each(manager.options.cssProps, function(value, name) {\n        prop = prefixed(element.style, name);\n        if (add) {\n            manager.oldCssProps[prop] = element.style[prop];\n            element.style[prop] = value;\n        } else {\n            element.style[prop] = manager.oldCssProps[prop] || '';\n        }\n    });\n    if (!add) {\n        manager.oldCssProps = {};\n    }\n}\n\n/**\n * trigger dom event\n * @param {String} event\n * @param {Object} data\n */\nfunction triggerDomEvent(event, data) {\n    var gestureEvent = document.createEvent('Event');\n    gestureEvent.initEvent(event, true, true);\n    gestureEvent.gesture = data;\n    data.target.dispatchEvent(gestureEvent);\n}\n\nassign(Hammer, {\n    INPUT_START: INPUT_START,\n    INPUT_MOVE: INPUT_MOVE,\n    INPUT_END: INPUT_END,\n    INPUT_CANCEL: INPUT_CANCEL,\n\n    STATE_POSSIBLE: STATE_POSSIBLE,\n    STATE_BEGAN: STATE_BEGAN,\n    STATE_CHANGED: STATE_CHANGED,\n    STATE_ENDED: STATE_ENDED,\n    STATE_RECOGNIZED: STATE_RECOGNIZED,\n    STATE_CANCELLED: STATE_CANCELLED,\n    STATE_FAILED: STATE_FAILED,\n\n    DIRECTION_NONE: DIRECTION_NONE,\n    DIRECTION_LEFT: DIRECTION_LEFT,\n    DIRECTION_RIGHT: DIRECTION_RIGHT,\n    DIRECTION_UP: DIRECTION_UP,\n    DIRECTION_DOWN: DIRECTION_DOWN,\n    DIRECTION_HORIZONTAL: DIRECTION_HORIZONTAL,\n    DIRECTION_VERTICAL: DIRECTION_VERTICAL,\n    DIRECTION_ALL: DIRECTION_ALL,\n\n    Manager: Manager,\n    Input: Input,\n    TouchAction: TouchAction,\n\n    TouchInput: TouchInput,\n    MouseInput: MouseInput,\n    PointerEventInput: PointerEventInput,\n    TouchMouseInput: TouchMouseInput,\n    SingleTouchInput: SingleTouchInput,\n\n    Recognizer: Recognizer,\n    AttrRecognizer: AttrRecognizer,\n    Tap: TapRecognizer,\n    Pan: PanRecognizer,\n    Swipe: SwipeRecognizer,\n    Pinch: PinchRecognizer,\n    Rotate: RotateRecognizer,\n    Press: PressRecognizer,\n\n    on: addEventListeners,\n    off: removeEventListeners,\n    each: each,\n    merge: merge,\n    extend: extend,\n    assign: assign,\n    inherit: inherit,\n    bindFn: bindFn,\n    prefixed: prefixed\n});\n\n// this prevents errors when Hammer is loaded in the presence of an AMD\n//  style loader but by script tag, not by the loader.\nvar freeGlobal = (typeof window !== 'undefined' ? window : (typeof self !== 'undefined' ? self : {})); // jshint ignore:line\nfreeGlobal.Hammer = Hammer;\n\nif (typeof define === 'function' && define.amd) {\n    define(function() {\n        return Hammer;\n    });\n} else if (typeof module != 'undefined' && module.exports) {\n    module.exports = Hammer;\n} else {\n    window[exportName] = Hammer;\n}\n\n})(window, document, 'Hammer');\n\n\n\n// WEBPACK FOOTER //\n// ./~/hammerjs/hammer.js","// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = require(\"!!./../node_modules/css-loader/index.js!./../node_modules/less-loader/index.js!./Gallery.less\");\nif(typeof content === 'string') content = [[module.id, content, '']];\n// add the styles to the DOM\nvar update = require(\"!./../node_modules/style-loader/addStyles.js\")(content, {});\nif(content.locals) module.exports = content.locals;\n// Hot Module Replacement\nif(module.hot) {\n\t// When the styles change, update the <style> tags\n\tif(!content.locals) {\n\t\tmodule.hot.accept(\"!!./../node_modules/css-loader/index.js!./../node_modules/less-loader/index.js!./Gallery.less\", function() {\n\t\t\tvar newContent = require(\"!!./../node_modules/css-loader/index.js!./../node_modules/less-loader/index.js!./Gallery.less\");\n\t\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\t\t\tupdate(newContent);\n\t\t});\n\t}\n\t// When the module is disposed, remove the <style> tags\n\tmodule.hot.dispose(function() { update(); });\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/Gallery.less\n// module id = 2\n// module chunks = 0","exports = module.exports = require(\"./../node_modules/css-loader/lib/css-base.js\")();\n// imports\n\n\n// module\nexports.push([module.id, \".gallery{height:250px;background-color:#000;position:relative;overflow:hidden}.gallery.fullscreen{position:fixed;z-index:100;top:0;left:0;right:0;bottom:0;height:auto}.gallery .back-nav-icon,.gallery .forward-nav-icon{position:absolute;top:0;bottom:22px;margin:auto;width:30px;height:30px;opacity:0;z-index:3;transition:opacity .3s}.gallery .back-nav-icon:hover,.gallery .forward-nav-icon:hover{opacity:.75!important}.gallery:hover .back-nav-icon,.gallery:hover .forward-nav-icon{opacity:.5}.gallery .forward-nav-icon{right:15px}.gallery .back-nav-icon{left:15px}.gallery .status-bar{position:absolute;bottom:0;left:0;right:0;height:22px;text-align:center;background:#45484d;background:-moz-linear-gradient(top,#45484d 0,#000 100%);background:-webkit-linear-gradient(top,#45484d,#000);background:linear-gradient(180deg,#45484d 0,#000);filter:progid:DXImageTransform.Microsoft.gradient(startColorstr='#45484d',endColorstr='#000000',GradientType=0);-webkit-box-shadow:0 0 14px 0 rgba(0,0,0,.75);-moz-box-shadow:0 0 14px 0 rgba(0,0,0,.75);box-shadow:0 0 14px 0 rgba(0,0,0,.75);z-index:2;color:#fff;padding:5px;font-size:12px;box-sizing:border-box}.gallery .status-bar .fullscreen-icon{position:absolute;right:5px;top:5px;height:12px}.gallery .status-bar .navigation-status{position:absolute;left:5px;top:5px}.gallery .gallery-content{position:absolute;top:0;left:0;bottom:22px;width:100%;overflow:hidden;transition:left .5s;white-space:nowrap;z-index:1;overflow:visible}.gallery .gallery-content>*{width:100%;height:100%;display:inline-block;background-size:contain;background-repeat:no-repeat;background-position:50%;vertical-align:top;position:relative;overflow:hidden}.gallery .gallery-content>* iframe{width:100%;height:100%}.gallery .gallery-content>* img{position:absolute;top:0;left:0;transform:translateZ(0)}\", \"\"]);\n\n// exports\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/css-loader!./~/less-loader!./src/Gallery.less\n// module id = 3\n// module chunks = 0","/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n// css base code, injected by the css-loader\nmodule.exports = function() {\n\tvar list = [];\n\n\t// return the list of modules as css string\n\tlist.toString = function toString() {\n\t\tvar result = [];\n\t\tfor(var i = 0; i < this.length; i++) {\n\t\t\tvar item = this[i];\n\t\t\tif(item[2]) {\n\t\t\t\tresult.push(\"@media \" + item[2] + \"{\" + item[1] + \"}\");\n\t\t\t} else {\n\t\t\t\tresult.push(item[1]);\n\t\t\t}\n\t\t}\n\t\treturn result.join(\"\");\n\t};\n\n\t// import a list of modules into the list\n\tlist.i = function(modules, mediaQuery) {\n\t\tif(typeof modules === \"string\")\n\t\t\tmodules = [[null, modules, \"\"]];\n\t\tvar alreadyImportedModules = {};\n\t\tfor(var i = 0; i < this.length; i++) {\n\t\t\tvar id = this[i][0];\n\t\t\tif(typeof id === \"number\")\n\t\t\t\talreadyImportedModules[id] = true;\n\t\t}\n\t\tfor(i = 0; i < modules.length; i++) {\n\t\t\tvar item = modules[i];\n\t\t\t// skip already imported module\n\t\t\t// this implementation is not 100% perfect for weird media query combinations\n\t\t\t//  when a module is imported multiple times with different media queries.\n\t\t\t//  I hope this will never occur (Hey this way we have smaller bundles)\n\t\t\tif(typeof item[0] !== \"number\" || !alreadyImportedModules[item[0]]) {\n\t\t\t\tif(mediaQuery && !item[2]) {\n\t\t\t\t\titem[2] = mediaQuery;\n\t\t\t\t} else if(mediaQuery) {\n\t\t\t\t\titem[2] = \"(\" + item[2] + \") and (\" + mediaQuery + \")\";\n\t\t\t\t}\n\t\t\t\tlist.push(item);\n\t\t\t}\n\t\t}\n\t};\n\treturn list;\n};\n\n\n\n// WEBPACK FOOTER //\n// ./~/css-loader/lib/css-base.js","/*\r\n\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\tAuthor Tobias Koppers @sokra\r\n*/\r\nvar stylesInDom = {},\r\n\tmemoize = function(fn) {\r\n\t\tvar memo;\r\n\t\treturn function () {\r\n\t\t\tif (typeof memo === \"undefined\") memo = fn.apply(this, arguments);\r\n\t\t\treturn memo;\r\n\t\t};\r\n\t},\r\n\tisOldIE = memoize(function() {\r\n\t\treturn /msie [6-9]\\b/.test(window.navigator.userAgent.toLowerCase());\r\n\t}),\r\n\tgetHeadElement = memoize(function () {\r\n\t\treturn document.head || document.getElementsByTagName(\"head\")[0];\r\n\t}),\r\n\tsingletonElement = null,\r\n\tsingletonCounter = 0,\r\n\tstyleElementsInsertedAtTop = [];\r\n\r\nmodule.exports = function(list, options) {\r\n\tif(typeof DEBUG !== \"undefined\" && DEBUG) {\r\n\t\tif(typeof document !== \"object\") throw new Error(\"The style-loader cannot be used in a non-browser environment\");\r\n\t}\r\n\r\n\toptions = options || {};\r\n\t// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\r\n\t// tags it will allow on a page\r\n\tif (typeof options.singleton === \"undefined\") options.singleton = isOldIE();\r\n\r\n\t// By default, add <style> tags to the bottom of <head>.\r\n\tif (typeof options.insertAt === \"undefined\") options.insertAt = \"bottom\";\r\n\r\n\tvar styles = listToStyles(list);\r\n\taddStylesToDom(styles, options);\r\n\r\n\treturn function update(newList) {\r\n\t\tvar mayRemove = [];\r\n\t\tfor(var i = 0; i < styles.length; i++) {\r\n\t\t\tvar item = styles[i];\r\n\t\t\tvar domStyle = stylesInDom[item.id];\r\n\t\t\tdomStyle.refs--;\r\n\t\t\tmayRemove.push(domStyle);\r\n\t\t}\r\n\t\tif(newList) {\r\n\t\t\tvar newStyles = listToStyles(newList);\r\n\t\t\taddStylesToDom(newStyles, options);\r\n\t\t}\r\n\t\tfor(var i = 0; i < mayRemove.length; i++) {\r\n\t\t\tvar domStyle = mayRemove[i];\r\n\t\t\tif(domStyle.refs === 0) {\r\n\t\t\t\tfor(var j = 0; j < domStyle.parts.length; j++)\r\n\t\t\t\t\tdomStyle.parts[j]();\r\n\t\t\t\tdelete stylesInDom[domStyle.id];\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n}\r\n\r\nfunction addStylesToDom(styles, options) {\r\n\tfor(var i = 0; i < styles.length; i++) {\r\n\t\tvar item = styles[i];\r\n\t\tvar domStyle = stylesInDom[item.id];\r\n\t\tif(domStyle) {\r\n\t\t\tdomStyle.refs++;\r\n\t\t\tfor(var j = 0; j < domStyle.parts.length; j++) {\r\n\t\t\t\tdomStyle.parts[j](item.parts[j]);\r\n\t\t\t}\r\n\t\t\tfor(; j < item.parts.length; j++) {\r\n\t\t\t\tdomStyle.parts.push(addStyle(item.parts[j], options));\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tvar parts = [];\r\n\t\t\tfor(var j = 0; j < item.parts.length; j++) {\r\n\t\t\t\tparts.push(addStyle(item.parts[j], options));\r\n\t\t\t}\r\n\t\t\tstylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunction listToStyles(list) {\r\n\tvar styles = [];\r\n\tvar newStyles = {};\r\n\tfor(var i = 0; i < list.length; i++) {\r\n\t\tvar item = list[i];\r\n\t\tvar id = item[0];\r\n\t\tvar css = item[1];\r\n\t\tvar media = item[2];\r\n\t\tvar sourceMap = item[3];\r\n\t\tvar part = {css: css, media: media, sourceMap: sourceMap};\r\n\t\tif(!newStyles[id])\r\n\t\t\tstyles.push(newStyles[id] = {id: id, parts: [part]});\r\n\t\telse\r\n\t\t\tnewStyles[id].parts.push(part);\r\n\t}\r\n\treturn styles;\r\n}\r\n\r\nfunction insertStyleElement(options, styleElement) {\r\n\tvar head = getHeadElement();\r\n\tvar lastStyleElementInsertedAtTop = styleElementsInsertedAtTop[styleElementsInsertedAtTop.length - 1];\r\n\tif (options.insertAt === \"top\") {\r\n\t\tif(!lastStyleElementInsertedAtTop) {\r\n\t\t\thead.insertBefore(styleElement, head.firstChild);\r\n\t\t} else if(lastStyleElementInsertedAtTop.nextSibling) {\r\n\t\t\thead.insertBefore(styleElement, lastStyleElementInsertedAtTop.nextSibling);\r\n\t\t} else {\r\n\t\t\thead.appendChild(styleElement);\r\n\t\t}\r\n\t\tstyleElementsInsertedAtTop.push(styleElement);\r\n\t} else if (options.insertAt === \"bottom\") {\r\n\t\thead.appendChild(styleElement);\r\n\t} else {\r\n\t\tthrow new Error(\"Invalid value for parameter 'insertAt'. Must be 'top' or 'bottom'.\");\r\n\t}\r\n}\r\n\r\nfunction removeStyleElement(styleElement) {\r\n\tstyleElement.parentNode.removeChild(styleElement);\r\n\tvar idx = styleElementsInsertedAtTop.indexOf(styleElement);\r\n\tif(idx >= 0) {\r\n\t\tstyleElementsInsertedAtTop.splice(idx, 1);\r\n\t}\r\n}\r\n\r\nfunction createStyleElement(options) {\r\n\tvar styleElement = document.createElement(\"style\");\r\n\tstyleElement.type = \"text/css\";\r\n\tinsertStyleElement(options, styleElement);\r\n\treturn styleElement;\r\n}\r\n\r\nfunction createLinkElement(options) {\r\n\tvar linkElement = document.createElement(\"link\");\r\n\tlinkElement.rel = \"stylesheet\";\r\n\tinsertStyleElement(options, linkElement);\r\n\treturn linkElement;\r\n}\r\n\r\nfunction addStyle(obj, options) {\r\n\tvar styleElement, update, remove;\r\n\r\n\tif (options.singleton) {\r\n\t\tvar styleIndex = singletonCounter++;\r\n\t\tstyleElement = singletonElement || (singletonElement = createStyleElement(options));\r\n\t\tupdate = applyToSingletonTag.bind(null, styleElement, styleIndex, false);\r\n\t\tremove = applyToSingletonTag.bind(null, styleElement, styleIndex, true);\r\n\t} else if(obj.sourceMap &&\r\n\t\ttypeof URL === \"function\" &&\r\n\t\ttypeof URL.createObjectURL === \"function\" &&\r\n\t\ttypeof URL.revokeObjectURL === \"function\" &&\r\n\t\ttypeof Blob === \"function\" &&\r\n\t\ttypeof btoa === \"function\") {\r\n\t\tstyleElement = createLinkElement(options);\r\n\t\tupdate = updateLink.bind(null, styleElement);\r\n\t\tremove = function() {\r\n\t\t\tremoveStyleElement(styleElement);\r\n\t\t\tif(styleElement.href)\r\n\t\t\t\tURL.revokeObjectURL(styleElement.href);\r\n\t\t};\r\n\t} else {\r\n\t\tstyleElement = createStyleElement(options);\r\n\t\tupdate = applyToTag.bind(null, styleElement);\r\n\t\tremove = function() {\r\n\t\t\tremoveStyleElement(styleElement);\r\n\t\t};\r\n\t}\r\n\r\n\tupdate(obj);\r\n\r\n\treturn function updateStyle(newObj) {\r\n\t\tif(newObj) {\r\n\t\t\tif(newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap)\r\n\t\t\t\treturn;\r\n\t\t\tupdate(obj = newObj);\r\n\t\t} else {\r\n\t\t\tremove();\r\n\t\t}\r\n\t};\r\n}\r\n\r\nvar replaceText = (function () {\r\n\tvar textStore = [];\r\n\r\n\treturn function (index, replacement) {\r\n\t\ttextStore[index] = replacement;\r\n\t\treturn textStore.filter(Boolean).join('\\n');\r\n\t};\r\n})();\r\n\r\nfunction applyToSingletonTag(styleElement, index, remove, obj) {\r\n\tvar css = remove ? \"\" : obj.css;\r\n\r\n\tif (styleElement.styleSheet) {\r\n\t\tstyleElement.styleSheet.cssText = replaceText(index, css);\r\n\t} else {\r\n\t\tvar cssNode = document.createTextNode(css);\r\n\t\tvar childNodes = styleElement.childNodes;\r\n\t\tif (childNodes[index]) styleElement.removeChild(childNodes[index]);\r\n\t\tif (childNodes.length) {\r\n\t\t\tstyleElement.insertBefore(cssNode, childNodes[index]);\r\n\t\t} else {\r\n\t\t\tstyleElement.appendChild(cssNode);\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunction applyToTag(styleElement, obj) {\r\n\tvar css = obj.css;\r\n\tvar media = obj.media;\r\n\r\n\tif(media) {\r\n\t\tstyleElement.setAttribute(\"media\", media)\r\n\t}\r\n\r\n\tif(styleElement.styleSheet) {\r\n\t\tstyleElement.styleSheet.cssText = css;\r\n\t} else {\r\n\t\twhile(styleElement.firstChild) {\r\n\t\t\tstyleElement.removeChild(styleElement.firstChild);\r\n\t\t}\r\n\t\tstyleElement.appendChild(document.createTextNode(css));\r\n\t}\r\n}\r\n\r\nfunction updateLink(linkElement, obj) {\r\n\tvar css = obj.css;\r\n\tvar sourceMap = obj.sourceMap;\r\n\r\n\tif(sourceMap) {\r\n\t\t// http://stackoverflow.com/a/26603875\r\n\t\tcss += \"\\n/*# sourceMappingURL=data:application/json;base64,\" + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + \" */\";\r\n\t}\r\n\r\n\tvar blob = new Blob([css], { type: \"text/css\" });\r\n\r\n\tvar oldSrc = linkElement.href;\r\n\r\n\tlinkElement.href = URL.createObjectURL(blob);\r\n\r\n\tif(oldSrc)\r\n\t\tURL.revokeObjectURL(oldSrc);\r\n}\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/style-loader/addStyles.js\n// module id = 5\n// module chunks = 0","module.exports = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAwAAAAMCAYAAABWdVznAAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH4AscDSwos9M4EwAAAKpJREFUKM+Vkb1tw2AMBe8JgtbIPhkg6pRJ3DhFtEbc2VtlDDnFuRHtT44DxK/izxHgI/GmTwCVUsXqXFDPTT8ASa5gkuqdK+iBeYV36kuS9wZE/QIm4AMYNg31rI5NbVSXdWi7ZwN0Td6pb7/YdqjyRzWAjmf1j5XGR2yZXu52HtdDXE336rzeeQIOSU7VTHJUX4FJ/QYGmk/v/zKt7gtqTQ8FJ9l8vH3YBcyruitYNxLiAAAAAElFTkSuQmCC\"\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/assets/fullscreen.png\n// module id = 6\n// module chunks = 0","module.exports = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH4AscDSsfRC8L2wAAAoFJREFUSMetl79rU1EUxz/vtbVoKyV50KFaEREXKYlC01Ic3MRCl5gh6pApCCLi3+DQUKdS3cTBQREcHBSLFuOkEamJUIRIIES0oYg/ItW+NIm5Dt5bniU2977kwNnu935yzsm55zwLfQsCp4FTQAg4CAwAVWANWAGeAY+BImABAp9mAUeA64ArL9LxR8AU0OsHuhe4DHw3AG73eWDUBLofuNUB0OvPgeM60H3A3S5Blb8BjrVL70KXoU1P5C3T3gOc93l5zaDmva1SXDCFhsPhr4lEYgP4ramZkt0C8ldcNIWOj49/zufzPyqVSiOZTP40aLUt2wO8M4FGIpG1QqGwLoQQ9XrdjcViawb6Qwp81BBaLhaLv8Rfq8bj8bJBnQVwCcAGLuiKJiYmVkulkqug0Wh0FagblumBAt/wAd2cmZn5ZPCn8npBtdH9docnJyfLXuj09PRHy7KaPttvXYEftjm4sbS0VJVQsbi4mLdtu9nBo9JQ4HvtDjuO4y4vL9cUfHZ29qXnVTL1iqrxNR1BIBBwc7lcrdlsCiGESKVSGcuyGj7Ab9XMPasrUnAVeSqVem3bds0QfFv18aiJMBAI/JP2ubm5bH9/f9XgjnMKvBt4agJ3HMfNZDIK3kgkEq80ta5co7Ym0xnTWg0PD1fT6fRmNpv9EgqFPmjqFrZPpyE5M43gwWDQHRsbK2ue/wYcbrXYnexwx9J5o61Wy0AfcKWD/tzJbwKDO60/g8DVLsPvyEWjrQ3IyLuR9nlgxGTF7ZM1T/sEvpf9Ouj3S2IIiAJPNIErcr6PyDb978U61gPsAhzgBBAGDshovN9OL4CS3EYa7SLykwVrm9YbsZb9AUUpBP2ozu6MAAAAAElFTkSuQmCC\"\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/assets/back-nav.png\n// module id = 7\n// module chunks = 0","module.exports = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH4AscDSwGbwU13AAAAo5JREFUSMe1l89rE1EQxz+bWEFrKCq9pKmCSFqw1FhooMWDN5FCD5JLFXpKSRBF/wWPnizVm14EBcGDlIKgoJ48hoo/oFLSBFpbK81uNyVNGtqOl92yhNS894wDc/y+z87MmzezFup2CrgGXAUuAmeBE0ANWAO+Ae+BN8ASYAGCoVlAHHgEVL2DVHwOGAWOmEAjwB3A1gA2+jTQqwONAU//ARj0j8AlFWgP8KJNUN9zreARYKbN0P1A5E3THgZuahy4a/ARD5tduB5gUeWAeDy+nEqlVoC6QfSjXreA9xW3VMT9/f2r8/Pzq+Vy2Z6cnCwCdcuyRLPVDuw48F1FGIvFfm9sbNRFRFzXddPp9JIB/JwPvqCTrpGRkUqpVKqJiDiOU85kMrrw2wAhIKNbq6GhoYrjODUREdu2t7LZbF4D/toHPzZpk8HBwYrrugdwjcgX/TZ6ZdKjlmXtDwwMVGzb3vHTPjU1taRw27d88JzpAxEOh/ey2WxBPMvlcuVoNLqu8AYQBl6aQEOh0P7Y2NiyiOyIiOTz+e3h4eF1Be2mX+MHJmkOQguFQjWZTP5S1H/2Z+6EJnhvfHx8xYcWi8VaMplc09A/8/u4V6Omu6lU6qeI1AKRrml++IQPPga8UxH19fUti8i2X1ON9PpeBU4GJ9N1FWF3d7c7Ozu7ubCwUFG8SI0+ExwSAF3ezGwpjkQibiKRKBlAbeB8s8XuCuC0eRFofKOtZstAB3AP2PsP0CfeOnyodQL32wx/7i0aLa0TuNumtE8DUZ0Vt8Or+QdD4A/gRqv0/u1PostrtbeKwC/efI96bXrowSoWBo4Cp4HLQAI440VTBdaBr8AnoOiNxd1WEZlkwWrQBiNWsj9N1gQwvR+6JQAAAABJRU5ErkJggg==\"\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/assets/forward-nav.png\n// module id = 8\n// module chunks = 0","class ItemBuilder {\r\n    build (item) {\r\n        let itemContainer = document.createElement('div');\r\n        itemContainer.appendChild(item.element);\r\n        this._attachEvents(itemContainer, item);\r\n        return itemContainer;\r\n    }\r\n\r\n    _attachEvents(itemContainer, item) {\r\n        var mc = new Hammer.Manager(itemContainer);\r\n        var pinch = new Hammer.Pinch();\r\n        var pan = new Hammer.Pan();\r\n        mc.add(pinch);\r\n        mc.add(pan);\r\n\r\n        var pinchStartW = 0;\r\n        var pinchStartH = 0;\r\n        var pinchStartX = 0;\r\n        var pinchStartY = 0;\r\n        var pinchStartPointerX = 0;\r\n        var pinchStartPointerY = 0;\r\n        var focusPoint = {};\r\n        var pinchOffset = 0;\r\n        var imageStartX = 0;\r\n        var imageStartY = 0;\r\n        var panStartX = 0;\r\n        var panStartY = 0;\r\n\r\n        mc.on(\"pinchstart\", (e) => {\r\n            pinchStartW = item.element.offsetWidth;\r\n            pinchStartH = item.element.offsetHeight;\r\n            pinchStartX = item.element.offsetLeft;\r\n            pinchStartY = item.element.offsetTop;\r\n            pinchStartPointerX = e.pointers[0].clientX;\r\n            pinchStartPointerY = e.pointers[0].clientY;\r\n            imageStartX = item.element.offsetLeft;\r\n            imageStartY = item.element.offsetTop;\r\n\r\n            let x1 = e.pointers[0].clientX;\r\n            let x2 = e.pointers[1].clientX;\r\n            let y1 = e.pointers[0].clientY;\r\n            let y2 = e.pointers[1].clientY;\r\n            focusPoint.x = x1 + ((x2 - x1) / 2);\r\n            focusPoint.y = y1 + ((y2 - y1) / 2);\r\n        });\r\n\r\n        let pinchFn = (e) => {\r\n            item.resize((pinchStartW * e.scale), (pinchStartH * e.scale), focusPoint, pinchStartX, pinchStartY, pinchOffset);\r\n        };\r\n\r\n        mc.on(\"pinchin\", pinchFn);\r\n        mc.on(\"pinchout\",pinchFn);\r\n        mc.on(\"panstart\", (e) => {\r\n            panStartX = e.pointers[0].clientX;\r\n            panStartY = e.pointers[0].clientY;\r\n            imageStartX = item.element.offsetLeft;\r\n            imageStartY = item.element.offsetTop;\r\n        });\r\n        mc.on(\"pinchmove\", (e) => {\r\n            pinchOffset = {x: e.pointers[0].clientX - pinchStartPointerX,y:  e.pointers[0].clientY - pinchStartPointerY};\r\n            // this._moveImage(galleryImage, imageStartX - (startX - e.pointers[0].clientX) , imageStartY - (startY - e.pointers[0].clientY));\r\n        });\r\n        mc.on(\"panmove\", (e) => {\r\n            item.move(imageStartX - (panStartX - e.pointers[0].clientX) , imageStartY - (panStartY - e.pointers[0].clientY));\r\n        });\r\n    }\r\n}\r\n\r\n//Singleton export\r\nexport default new ItemBuilder();\n\n\n// WEBPACK FOOTER //\n// ./src/items/ItemBuilder.js","/**\r\n * Created by Kyle on 2016-11-28.\r\n */\r\n\r\nimport ImageItem from \"./ImageItem.js\";\r\nimport YouTubeItem from \"./YouTubeItem.js\";\r\n\r\nclass ItemFactory {\r\n    build (itemStub) {\r\n        switch (itemStub.type) {\r\n            case \"image\":\r\n                return new ImageItem(itemStub.title, itemStub.url);\r\n                break;\r\n            case \"youtube\":\r\n                return new YouTubeItem(itemStub.title, itemStub.video_id, itemStub.player_vars);\r\n                break;\r\n            default:\r\n                throw new TypeError(\"Item Stub Type is an invalid type!\");\r\n                break;\r\n        }\r\n    }\r\n}\r\n\r\nexport default new ItemFactory();\n\n\n// WEBPACK FOOTER //\n// ./src/items/ItemFactory.js","/**\r\n * Created by Kyle on 2016-11-28.\r\n */\r\nimport GalleryItem from \"./GalleryItem.js\";\r\nexport default class ImageItem extends GalleryItem {\r\n    constructor (title, url) {\r\n        super(\"image\", title);\r\n        this._url = url;\r\n\r\n        //Build Image\r\n        this._element = document.createElement('img');\r\n        this._element.onload = (e) => {\r\n            this.reset();\r\n        };\r\n        this._element.src = this._url;\r\n    }\r\n\r\n    get url () {\r\n        return this._url;\r\n    }\r\n\r\n    onHidden () {\r\n        this.reset();\r\n    }\r\n\r\n}\n\n\n// WEBPACK FOOTER //\n// ./src/items/ImageItem.js","/**\r\n * Created by Kyle on 2016-11-28.\r\n */\r\nexport default class GalleryItem {\r\n    constructor (type, title) {\r\n        this._type = type;\r\n        this._title = title;\r\n        this._element = null;\r\n    }\r\n\r\n    get title () {\r\n        return this._title;\r\n    }\r\n\r\n    get type () {\r\n        return this._type;\r\n    }\r\n\r\n    get element () {\r\n        return this._element;\r\n    }\r\n\r\n    resize (w, h, focusPoint, startX, startY, offset) {\r\n        let x;\r\n        let y;\r\n\r\n        //Constrain size\r\n        let displayAR = this.element.parentNode.offsetWidth / this.element.parentNode.offsetHeight;\r\n        let elementAR = this.element.offsetWidth / this.element.offsetHeight;\r\n\r\n        if (displayAR > elementAR && h < this.element.parentNode.offsetHeight) {\r\n            h = this.element.parentNode.offsetHeight;\r\n            w = this.element.offsetWidth;\r\n        } else if (displayAR < elementAR && w < this.element.parentNode.offsetWidth) {\r\n            h = this.element.offsetHeight;\r\n            w = this.element.parentNode.offsetWidth;\r\n        }\r\n\r\n        //Make sure it doesn't exceed original dimensions x2\r\n        if (h > this.element.parentNode.offsetHeight * 2 || w > this.element.parentNode.offsetWidth * 2) {\r\n            h = this.element.offsetHeight;\r\n            w = this.element.offsetWidth;\r\n        }\r\n        // console.log(focusPoint);\r\n        let scale;\r\n        if (displayAR > elementAR) {\r\n            scale = (this.element.offsetHeight / this.element.parentNode.offsetHeight) - 1;\r\n        } else {\r\n            scale = (this.element.offsetWidth / this.element.parentNode.offsetWidth) - 1;\r\n        }\r\n\r\n        //TODO: Redo focus point calculations to be more accurate\r\n        //Recenter image with new dimensions against focus point based on zoom level\r\n        let destination = {x: startX - ( focusPoint.x * 2), y: startY - (focusPoint.y * 2)};\r\n\r\n        x = (startX + (destination.x)) * scale;\r\n        y = (startY + (destination.y)) * scale;\r\n\r\n        x += offset.x;\r\n        y += offset.y;\r\n\r\n\r\n        //Boundry Enforcement\r\n        if (h < this.element.parentNode.offsetHeight) {\r\n            y = (this.element.parentNode.offsetHeight - h) / 2;\r\n        }  else if (h > this.element.parentNode.offsetHeight && y > 0) {\r\n            y = 0;\r\n        } else if (h > this.element.parentNode.offsetHeight && y < 0-((h - this.element.parentNode.offsetHeight))) {\r\n            y = 0-((h - this.element.parentNode.offsetHeight));\r\n        } else if (h === this.element.parentNode.offsetHeight) {\r\n            y = 0;\r\n        }\r\n\r\n        if (w < this.element.parentNode.offsetWidth) {\r\n            x = (this.element.parentNode.offsetWidth - w) / 2;\r\n        } else if (w > this.element.parentNode.offsetWidth && x > 0) {\r\n            x = 0;\r\n        } else if (w > this.element.parentNode.offsetWidth && x < 0-((w - this.element.parentNode.offsetWidth))) {\r\n            x = 0-((w - this.element.parentNode.offsetWidth));\r\n        } else if (w === this.element.parentNode.offsetWidth) {\r\n            x = 0;\r\n        }\r\n\r\n        this.element.style.display = \"none\";\r\n        this.element.style.top = Math.floor(y) + \"px\";\r\n        this.element.style.left = Math.floor(x) + \"px\";\r\n        this.element.style.width = Math.floor(w) + \"px\";\r\n        this.element.style.height = Math.floor(h) + \"px\";\r\n        this.element.style.display = \"block\";\r\n    }\r\n\r\n    move (x, y) {\r\n        //Constrain movement...\r\n        if (this.element.offsetWidth > this.element.parentNode.offsetWidth) {\r\n            if (x > 0) {\r\n                x = 0;\r\n            } else if (x < this.element.parentNode.offsetWidth - this.element.offsetWidth) {\r\n                x = this.element.parentNode.offsetWidth - this.element.offsetWidth;\r\n            }\r\n        } else {\r\n            //Don't allow it to move\r\n            x = this.element.offsetLeft;\r\n        }\r\n\r\n        if (this.element.offsetHeight > this.element.parentNode.offsetHeight) {\r\n            if (y > 0) {\r\n                y = 0;\r\n            } else if (y < this.element.parentNode.offsetHeight - this.element.offsetHeight) {\r\n                y = this.element.parentNode.offsetHeight - this.element.offsetHeight;\r\n            }\r\n        } else {\r\n            y = this.element.offsetTop;\r\n        }\r\n\r\n        //Set finalized coordinates\r\n        this.element.style.left = x + \"px\";\r\n        this.element.style.top = y + \"px\";\r\n    }\r\n\r\n    reset () {\r\n        //Remove all dimensions styling to insure a fresh slate\r\n        this.element.style.removeProperty(\"height\");\r\n        this.element.style.removeProperty(\"width\");\r\n\r\n        //Compare Aspect Ratios and set the size of the element\r\n        let displayAR = this.element.parentNode.offsetWidth / this.element.parentNode.offsetHeight;\r\n        let imageAR = this.element.offsetWidth / this.element.offsetHeight;\r\n\r\n        if (displayAR > imageAR) {\r\n            this.element.style.top = \"0px\";\r\n            this.element.style.height = this.element.parentNode.offsetHeight + \"px\";\r\n            this.element.style.left = ((this.element.parentNode.offsetWidth - this.element.offsetWidth) / 2) + \"px\";\r\n        } else if (displayAR < imageAR) {\r\n            this.element.style.left = \"0px\";\r\n            this.element.style.width = this.element.parentNode.offsetWidth + \"px\";\r\n            this.element.style.top = ((this.element.parentNode.offsetHeight - this.element.offsetHeight) /2) + \"px\";\r\n        } else {\r\n            this.element.style.top = \"0px\";\r\n            this.element.style.left = \"0px\";\r\n            this.element.style.height = this.element.parentNode.offsetHeight + \"px\";\r\n            this.element.style.width = this.element.parentNode.offsetWidth + \"px\";\r\n        }\r\n    }\r\n\r\n    onShown () {\r\n        //Abstract Method for when Item is shown in gallery\r\n    }\r\n\r\n    onHidden () {\r\n        //Abstract Method for when Item is Hidden in Gallery\r\n    }\r\n}\n\n\n// WEBPACK FOOTER //\n// ./src/items/GalleryItem.js","/**\r\n * Created by Kyle on 2016-11-28.\r\n */\r\n\r\nimport GalleryItem from \"./GalleryItem.js\";\r\nexport default class YouTubeItem extends GalleryItem {\r\n    constructor (title, video_id, player_vars) {\r\n        super(\"youtube\", title);\r\n\r\n        this._element = document.createElement('iframe');\r\n        this.element.setAttribute('id', \"player\");\r\n        this.element.setAttribute('type', 'text/html');\r\n        this.element.setAttribute('frameborder', '0');\r\n        var url = \"http://www.youtube.com/embed/\" + video_id + \"?enablejsapi=1\";\r\n        for (var i in player_vars) {\r\n            url += \"&\" + i + \"=\" + player_vars[i];\r\n        }\r\n        this.element.setAttribute('src', url);\r\n    }\r\n\r\n    reset () {\r\n        this.element.width = \"100%\";\r\n        this.element.height = \"100%\";\r\n    }\r\n\r\n    move () {\r\n        return false;\r\n    }\r\n\r\n    resize () {\r\n        return false;\r\n    }\r\n\r\n    onHidden () {\r\n        this.element.contentWindow.postMessage('{\"event\":\"command\",\"func\":\"stopVideo\",\"args\":\"\"}', \"*\");\r\n    }\r\n}\n\n\n// WEBPACK FOOTER //\n// ./src/items/YouTubeItem.js"],"sourceRoot":""}